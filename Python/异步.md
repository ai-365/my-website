

###  进程、线程、协程、并发、并行概念的区别

并发：   处理多个任务。并发依然是CPU依次处理每个任务，只不过切换的时间很快，执行时间很快，人类感知不到，所以看上去是多任务处理，其实微观来看，并发是单任务。并发通过新增新的线程方式实现。

并行 ：   通过多个CPU同时执行任务。并行是真正意义上的多任务，从微观来看，两个CPU可以同时执行任务。并行通过派生子进程方式实现。

进程：   每一个进程会分配隔离的内存。增加一个进程，内核会分配新的内存单元，由于CPU依次执行每个进程，所以，多进程程序会获得更多的CPU时间，但是缺点是会增加进程间切换的时间消耗、以及要处理进程间通信问题。

线程：  进程会有一个主线程，也可以增加线程，执行并发操作。线程之间共享内存。线程消耗的资源比进程少。

协程：  协程表示线程内的任务。协程改变了任务执行的先后顺序。协程基于事件循环机制，事件循环机制是编程语言层面的实现。事件循环机制中包含一个任务队列，每次取出一个任务出来执行。协程中只要有阻塞代码，事件循环和协程的执行就会受到阻塞。协程消耗的资源比线程少。

###   asyncio.create_task()

通过asyncio的create_task方法，可以将所有任务都收集到一个队列中。任务在这里具体表现为函数。如果这个队列中中存在耗时操作，例如文件读取、网络请求、sleep，并不会阻塞等待，而是会执行后面的任务。

```
import asyncio

async def task_one():
    print("开始执行任务一")
    await asyncio.sleep(3)  # 模拟一个耗时的操作
    print("经过了耗时操作后，任务一执行完成")

async def task_two():
    print("任务二，不耗时操作，提前完成")

async def main():
    task1 = asyncio.create_task(task_one())
    task2 = asyncio.create_task(task_two())
    await task1
    await task2

asyncio.run(main())
```

输出的结果如下：

```
开始执行任务一
(立即显示)任务二，不耗时操作，提前完成
(3秒后才显示)经过了耗时操作后，任务一执行完成
```

可以发现，任务一中有一个sleep耗时操作，但是任务二这个不耗时的操作在前面打印出来了。

