本页内容：
-  原始值的相等性判定
-  引用值的相等性判定

###   原始值的相等性判定

JavaScript原始值的相等性判定有两种情况：宽松相等、严格相等，分别使用两个和三个等号。这两种相等比较的区别只有一个：

```
是否预先进行类型转换
```

如果两个原始值的类型不同，宽松相等会预先将类型转换成同一类型后，再进行判断。如果是严格相等，则不会预先转换类型，类型不同直接就判定为不相等。

用一个示例可以很好的进行说明：

```js
console.log(1==true)  // true，预先转换了类型，相等

console.log(1===true)  // false 不进行类型转换
```


###   引用值的相等性判定

与原始值不同的是，引用值的相等比较只比较指针。

引用值的相等性判定不区分严格与宽松，两个和三个等号是完全等价的。引用值的相等判定只有一个依据：

```
比较两个引用值的指针是否指向同一处
```

例如，如下两个对象，虽然内容上看起来一样，但是它们实际的内容却存储在内存的不同地方，即指针的指向不一样，因此永远不会相等：

```js
const obj1 = {name:"bob"}
const obj2 = {name:"bob"}
console.log(obj1==obj2)  // false 
console.log(obj1===obj2)  // false 
```

将一个对象使用等号赋值给另一个对象时，默认使用浅拷贝，即只拷贝指针，那么这两个对象的指针指向同一处，因此相等，如下示例：

```
const obj1 = {name:"bob"}
obj2 = obj1   // 此时只拷贝了指针
console.log(obj1==obj2)  // true
console.log(obj1===obj2) // true
```

