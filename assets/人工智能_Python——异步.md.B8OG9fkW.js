import{_ as i,c as a,o as n,ae as t}from"./chunks/framework.rTUm5mJw.js";const c=JSON.parse('{"title":"异步","description":"","frontmatter":{},"headers":[],"relativePath":"人工智能/Python——异步.md","filePath":"人工智能/Python——异步.md"}'),p={name:"人工智能/Python——异步.md"};function h(l,s,k,e,r,E){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h1><h3 id="进程、线程、协程、并发、并行概念的区别" tabindex="-1">进程、线程、协程、并发、并行概念的区别 <a class="header-anchor" href="#进程、线程、协程、并发、并行概念的区别" aria-label="Permalink to &quot;进程、线程、协程、并发、并行概念的区别&quot;">​</a></h3><p>并发： 处理多个任务。并发依然是CPU依次处理每个任务，只不过切换的时间很快，执行时间很快，人类感知不到，所以看上去是多任务处理，其实微观来看，并发是单任务。并发通过新增新的线程方式实现。</p><p>并行 ： 通过多个CPU同时执行任务。并行是真正意义上的多任务，从微观来看，两个CPU可以同时执行任务。并行通过派生子进程方式实现。</p><p>进程： 每一个进程会分配隔离的内存。增加一个进程，内核会分配新的内存单元，由于CPU依次执行每个进程，所以，多进程程序会获得更多的CPU时间，但是缺点是会增加进程间切换的时间消耗、以及要处理进程间通信问题。</p><p>线程： 进程会有一个主线程，也可以增加线程，执行并发操作。线程之间共享内存。线程消耗的资源比进程少。</p><p>协程： 协程表示线程内的任务。协程改变了任务执行的先后顺序。协程基于事件循环机制，事件循环机制是编程语言层面的实现。事件循环机制中包含一个任务队列，每次取出一个任务出来执行。协程中只要有阻塞代码，事件循环和协程的执行就会受到阻塞。协程消耗的资源比线程少。</p><h3 id="asyncio-create-task" tabindex="-1">asyncio.create_task() <a class="header-anchor" href="#asyncio-create-task" aria-label="Permalink to &quot;asyncio.create_task()&quot;">​</a></h3><p>通过asyncio的create_task方法，可以将所有任务都收集到一个队列中。任务在这里具体表现为函数。如果这个队列中中存在耗时操作，例如文件读取、网络请求、sleep，并不会阻塞等待，而是会执行后面的任务。</p><div class="language-py vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> task_one</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;开始执行任务一&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio.sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 模拟一个耗时的操作</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;经过了耗时操作后，任务一执行完成&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> task_two</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;任务二，不耗时操作，提前完成&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    task1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio.create_task(task_one())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    task2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio.create_task(task_two())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">asyncio.run(main())</span></span></code></pre></div><p>输出的结果如下：</p><div class="language-py vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开始执行任务一</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(立即显示)任务二，不耗时操作，提前完成</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">3秒后才显示</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)经过了耗时操作后，任务一执行完成</span></span></code></pre></div><p>可以发现，任务一中有一个sleep耗时操作，但是任务二这个不耗时的操作在前面打印出来了。</p>`,13)]))}const y=i(p,[["render",h]]);export{c as __pageData,y as default};
