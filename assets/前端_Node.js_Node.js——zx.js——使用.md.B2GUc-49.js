import{_ as s,c as e,o as t,ae as n}from"./chunks/framework.rTUm5mJw.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/Node.js/Node.js——zx.js——使用.md","filePath":"前端/Node.js/Node.js——zx.js——使用.md"}'),o={name:"前端/Node.js/Node.js——zx.js——使用.md"};function p(l,a,i,r,d,c){return t(),e("div",null,a[0]||(a[0]=[n(`<h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><p>使用如下命令全局安装zx，以便在任何文件夹内使用：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm i -g zx</span></span></code></pre></div><h2 id="第一个示例" tabindex="-1">第一个示例 <a class="header-anchor" href="#第一个示例" aria-label="Permalink to &quot;第一个示例&quot;">​</a></h2><p>新建一个文件例如ls.mjs。编辑内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import { $ } from &quot;zx&quot;;</span></span>
<span class="line"><span>$.verbose = false;</span></span>
<span class="line"><span>const output = (await $\`ls\`).stdout.trim();</span></span>
<span class="line"><span>console.log(output);</span></span></code></pre></div><p>然后运行： zx ls.mjs</p><h2 id="代码解释" tabindex="-1">代码解释 <a class="header-anchor" href="#代码解释" aria-label="Permalink to &quot;代码解释&quot;">​</a></h2><p>$.verbose默认为true，会输出被调用的shell命令本身，我们这里设置为false。</p><p>$符号的作用是调用shell命令，大多数命令的调用都是异步的，所以加上await。</p><p>有些命令是用于执行操作，没有输出，例如mkdir、rename等。而有些命令我们是需要得到其输出结果的，例如ls、cat等。对于需要得到结果的命令，使用stdout（）函数以字符串的形式取回命令的输出结果，这相当于shell的重定向操作。最后，由于命令输出结果可能会在最后一行包含空白行，所以我们使用trim（）方法去掉字符串的空白行。</p>`,11)]))}const _=s(o,[["render",p]]);export{u as __pageData,_ as default};
