import{_ as d,c as e,o,ae as c}from"./chunks/framework.rTUm5mJw.js";const s=JSON.parse('{"title":"正则表达式","description":"","frontmatter":{},"headers":[],"relativePath":"前端/JavaScript/正则表达式.md","filePath":"前端/JavaScript/正则表达式.md"}'),r={name:"前端/JavaScript/正则表达式.md"};function a(h,t,p,b,i,l){return o(),e("div",null,t[0]||(t[0]=[c('<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to &quot;正则表达式&quot;">​</a></h1><h3 id="正则表达式常用符号汇总" tabindex="-1">正则表达式常用符号汇总 <a class="header-anchor" href="#正则表达式常用符号汇总" aria-label="Permalink to &quot;正则表达式常用符号汇总&quot;">​</a></h3><p>表示匹配数量的字符：</p><table tabindex="0"><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>+</code></td><td>常用，一个或多个前一个字符（组）</td></tr><tr><td><code>*</code></td><td>0个或多个前一个字符（组）</td></tr><tr><td><code> ？</code></td><td>0个或1个前一个字符</td></tr></tbody></table><p>用中括号表示单字符分组。中括号表示字符范围中的一个，只能匹配一个字符，例如：</p><table tabindex="0"><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>[1-9]</code></td><td>数字1-9中的任意一个数字</td></tr><tr><td><code>[a-f]</code></td><td>字母a-f中的任意一个字母</td></tr><tr><td><code>[a-zA-Z]</code></td><td>大写和小写字母中的任意一个</td></tr><tr><td><code>[abc123]</code></td><td>这六个字符中的一个</td></tr><tr><td><code>[^abc123]</code></td><td>不是这六个字符中的一个</td></tr><tr><td><code>[茴回囘囬]</code></td><td>茴字的四种写法中的一个</td></tr><tr><td>` [abc</td><td>cde] `</td></tr></tbody></table><p>用圆括号包裹的内容视同一个字符，用于多字符分组。</p><p>表示字母、数字集合的符号：</p><table tabindex="0"><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>\\d</code></td><td>digital，任意数字，相当于<code> [0-9]</code></td></tr><tr><td><code>\\D</code></td><td>任意非数字，相当于<code>[^0-9]</code></td></tr><tr><td><code>\\w</code></td><td>word，任意字母</td></tr><tr><td><code>\\W</code></td><td>任意非字母</td></tr><tr><td><code>\\s</code></td><td>space，任意空白字符</td></tr><tr><td><code>\\S</code></td><td>任意非空白字符</td></tr></tbody></table><p>需要转义的符号：</p><table tabindex="0"><thead><tr><th>需要转义的符号</th><th>说明及使用方式</th></tr></thead><tbody><tr><td><code>^</code></td><td>文本的开头，若要匹配该字符本身，需使用<code>\\^</code></td></tr><tr><td><code>$</code></td><td>文本的结尾，若要匹配该字符本身，需使用<code>\\$</code></td></tr><tr><td><code>.</code></td><td>任意字符，若要匹配该字符本身，需使用<code>\\. </code></td></tr><tr><td><code>*</code></td><td>匹配0个或多个前一个字符（组），若要匹配该字符本身，需使用<code>\\*</code></td></tr><tr><td><code>+</code></td><td>匹配1个或多个前一个字符（组），若要匹配该字符本身，需使用<code>\\+</code></td></tr><tr><td><code> ？</code></td><td>匹配0个或1个前一个字符（组），若要匹配该字符本身，需使用<code>\\?</code></td></tr><tr><td><code>=</code></td><td>若要匹配该字符本身，需使用<code>\\=</code></td></tr><tr><td><code>!</code></td><td>范围取反，若要匹配该字符本身，需使用<code>\\!</code></td></tr><tr><td><code>:</code></td><td>若要匹配该字符本身，需使用<code>\\:</code></td></tr><tr><td><code>|</code></td><td>任选，匹配左边的子表达式或右边的子表达式。若要匹配该字符本身，需使用<code>|</code></td></tr><tr><td><code>\\</code></td><td>转义，若要匹配该字符本身，需使用<code>\\\\</code></td></tr><tr><td><code>/</code></td><td>若要匹配该字符本身，需使用<code>\\/</code></td></tr><tr><td><code>(</code></td><td>表示分组的起始，若要匹配该字符本身，需使用<code>\\(</code></td></tr><tr><td><code>)</code></td><td>表示分组的结束，若要匹配该字符本身，需使用<code>\\)</code></td></tr><tr><td><code>[</code></td><td>若要匹配该字符本身，需使用<code>\\[</code></td></tr><tr><td><code>]</code></td><td>若要匹配该字符本身，需使用<code>\\]</code></td></tr><tr><td><code>{</code></td><td>命名捕获组，若要匹配该字符本身，需使用<code>\\{</code></td></tr><tr><td><code>}</code></td><td>命名捕获组，若要匹配该字符本身，需使用<code>\\}</code></td></tr></tbody></table><p>其它的不常见字符例如<code>@</code>、<code>#</code>、<code>%</code>、<code>&amp;</code>、<code>~</code>、<code>&#39;</code>、<code>&quot;</code>则不需要转义。</p><p>匹配模式：</p><table tabindex="0"><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>g</code></td><td>全局标志，意味着要找到所有匹配而不仅仅是第一个。</td></tr><tr><td><code>i</code></td><td>不区分大小写。</td></tr><tr><td><code>m</code></td><td>多行模式。类似于sed，对每一行进行匹配。这意味着<code>^</code>和<code>$</code>会匹配到每一行的开头和末尾，而不仅仅是文件的开头和结尾。</td></tr></tbody></table><h3 id="分组、前瞻和后顾" tabindex="-1">分组、前瞻和后顾 <a class="header-anchor" href="#分组、前瞻和后顾" aria-label="Permalink to &quot;分组、前瞻和后顾&quot;">​</a></h3><p>(?=@) 返回@符号前边的子字符串</p><p>正向后顾语法结构是<code>(?&lt;=pattern)</code><code>(?&lt;=@)</code>返回@符号后边的子字符串</p>',17)]))}const _=d(r,[["render",a]]);export{s as __pageData,_ as default};
