import{_ as a,c as o,o as i,ae as r}from"./chunks/framework.rTUm5mJw.js";const u=JSON.parse('{"title":"Docker","description":"","frontmatter":{},"headers":[],"relativePath":"Linux/Docker——Docker命令.md","filePath":"Linux/Docker——Docker命令.md"}'),c={name:"Linux/Docker——Docker命令.md"};function l(d,e,t,n,s,p){return i(),o("div",null,e[0]||(e[0]=[r('<h1 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h1><h2 id="镜像和容器的概念区别" tabindex="-1">镜像和容器的概念区别 <a class="header-anchor" href="#镜像和容器的概念区别" aria-label="Permalink to &quot;镜像和容器的概念区别&quot;">​</a></h2><p>一个镜像只是一个压缩文件，这是一种模板，可以使用镜像实例化多个容器。一个容器表示具体的一个实例，有自己的生命周期，包括启动、停止、删除。</p><p>镜像好比操作系统安装文件，容器好比通过此文件安装到机器上并运行起来的操作系统。</p><h2 id="docker主要命令汇总" tabindex="-1">docker主要命令汇总 <a class="header-anchor" href="#docker主要命令汇总" aria-label="Permalink to &quot;docker主要命令汇总&quot;">​</a></h2><ul><li>docker create imageName：从镜像创建一个容器</li><li>docker start imageName ：从镜像启动一个容器，或重启一个运行的容器</li><li>docker run imageName ： 从镜像启动一个容器</li><li>docker pause container ：挂起，也叫暂停</li><li>docker stop containerName：停止容器</li><li>docker kill containerName：停止容器</li><li>docker restart containerName ：重启</li><li>docker rm containerName：删除</li><li>docker ps : 查看容器信息</li><li>docker image ls ：查看本地镜像列表</li></ul><h2 id="docker-run命令" tabindex="-1">docker run命令 <a class="header-anchor" href="#docker-run命令" aria-label="Permalink to &quot;docker run命令&quot;">​</a></h2><p>docker run 用来启动一个容器，优先从本地寻找镜像，如果本地找不到，则从远程仓库拉取。</p><ul><li><code>-d</code> 后台启动，并返回容器ID。</li><li><code>-i</code>： 交互模式运行容器</li><li><code>-P</code> ： 随机端口映射，容器内部端口映射到主机是随机端口</li><li><code>-p</code> ： 指定端口映射，格式为 <code>-p 主机端口:容器端口</code>，如果端口一样，可以只写一个</li><li><code>-t</code>： 为容器重新分配一个伪输入终端，通常与-i搭配：-it</li><li><code>--name</code> ： 指定容器名称</li><li><code>-v</code> 指定一个目录映射到本地某个文件夹</li></ul><h2 id="docker-build命令" tabindex="-1">docker build命令 <a class="header-anchor" href="#docker-build命令" aria-label="Permalink to &quot;docker build命令&quot;">​</a></h2><p>根据Dockerfile配置文件，创建一个镜像。</p><p>默认配置文件为项目目录下的Dockerfile文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t 镜像名称:tag  .</span></span></code></pre></div><p>最后的点号(.)表示将本目录下的所有文件打包成一个镜像，一定不能忽略。</p><h2 id="目录映射" tabindex="-1">目录映射 <a class="header-anchor" href="#目录映射" aria-label="Permalink to &quot;目录映射&quot;">​</a></h2><p>使用 <code>-v</code> 选项，可以将容器内的目录映射到本地主机，这样，两个目录下的内容始终是同步的。语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run -it -v 宿主机目录:容器目录</span></span></code></pre></div>',17)]))}const h=a(c,[["render",l]]);export{u as __pageData,h as default};
