<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TCP IP | 我的个人博客网站</title>
    <meta name="description" content="个人博客网站">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/blog/assets/style.Dan5zzQf.css" as="style">
    <link rel="preload stylesheet" href="/blog/vp-icons.css" as="style">
    
    <script type="module" src="/blog/assets/app.CebyLLM_.js"></script>
    <link rel="preload" href="/blog/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/blog/assets/chunks/theme.BOSPpO_w.js">
    <link rel="modulepreload" href="/blog/assets/chunks/framework.rTUm5mJw.js">
    <link rel="modulepreload" href="/blog/assets/Linux_网络协议_TCP-IP.md.-BwLIwlG.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-bd45b254><!--[--><!--]--><!--[--><span tabindex="-1" data-v-40f86efc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-40f86efc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-bd45b254 data-v-fb232767><div class="VPNavBar" data-v-fb232767 data-v-da0c6bb0><div class="wrapper" data-v-da0c6bb0><div class="container" data-v-da0c6bb0><div class="title" data-v-da0c6bb0><div class="VPNavBarTitle" data-v-da0c6bb0 data-v-dcd02d3b><a class="title" href="/blog/" data-v-dcd02d3b><!--[--><!--]--><!----><span data-v-dcd02d3b>我的个人博客网站</span><!--[--><!--]--></a></div></div><div class="content" data-v-da0c6bb0><div class="content-body" data-v-da0c6bb0><!--[--><!--]--><div class="VPNavBarSearch search" data-v-da0c6bb0><!----></div><!----><!----><div class="VPNavBarAppearance appearance" data-v-da0c6bb0 data-v-60d4da9a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-60d4da9a data-v-dd4d226c data-v-27e5f2a7><span class="check" data-v-27e5f2a7><span class="icon" data-v-27e5f2a7><!--[--><span class="vpi-sun sun" data-v-dd4d226c></span><span class="vpi-moon moon" data-v-dd4d226c></span><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-da0c6bb0 data-v-700cb35d data-v-ec49d971><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-ec49d971><span class="vpi-more-horizontal icon" data-v-ec49d971></span></button><div class="menu" data-v-ec49d971><div class="VPMenu" data-v-ec49d971 data-v-381ce922><!----><!--[--><!--[--><!----><div class="group" data-v-700cb35d><div class="item appearance" data-v-700cb35d><p class="label" data-v-700cb35d>Appearance</p><div class="appearance-action" data-v-700cb35d><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-700cb35d data-v-dd4d226c data-v-27e5f2a7><span class="check" data-v-27e5f2a7><span class="icon" data-v-27e5f2a7><!--[--><span class="vpi-sun sun" data-v-dd4d226c></span><span class="vpi-moon moon" data-v-dd4d226c></span><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-da0c6bb0 data-v-aa5c404b><span class="container" data-v-aa5c404b><span class="top" data-v-aa5c404b></span><span class="middle" data-v-aa5c404b></span><span class="bottom" data-v-aa5c404b></span></span></button></div></div></div></div><div class="divider" data-v-da0c6bb0><div class="divider-line" data-v-da0c6bb0></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-bd45b254 data-v-1337b658><div class="container" data-v-1337b658><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-1337b658 data-v-05f14d6b><button data-v-05f14d6b>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-bd45b254 data-v-d83a6a16><div class="VPDoc has-aside" data-v-d83a6a16 data-v-ddd4901f><!--[--><!--]--><div class="container" data-v-ddd4901f><div class="aside" data-v-ddd4901f><div class="aside-curtain" data-v-ddd4901f></div><div class="aside-container" data-v-ddd4901f><div class="aside-content" data-v-ddd4901f><div class="VPDocAside" data-v-ddd4901f data-v-9ff60a05><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-9ff60a05 data-v-7cf8e59d><div class="content" data-v-7cf8e59d><div class="outline-marker" data-v-7cf8e59d></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-7cf8e59d>On this page</div><ul class="VPDocOutlineItem root" data-v-7cf8e59d data-v-385136ab><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-9ff60a05></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-ddd4901f><div class="content-container" data-v-ddd4901f><!--[--><!--]--><main class="main" data-v-ddd4901f><div style="position:relative;" class="vp-doc _blog_Linux_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_TCP-IP" data-v-ddd4901f><div><h1 id="tcp-ip" tabindex="-1">TCP IP <a class="header-anchor" href="#tcp-ip" aria-label="Permalink to &quot;TCP IP&quot;">​</a></h1><ul><li><a href="#osi七层模型">OSI七层模型</a></li><li><a href="#tcpip">TCP/IP</a></li><li><a href="#传输层tcp与udp">传输层：TCP与UDP</a><ul><li><a href="#端口">端口</a></li><li><a href="#tcp-三次握手">TCP 三次握手</a></li><li><a href="#tcp的四次挥手">TCP的四次挥手</a></li></ul></li><li><a href="#http协议">HTTP协议</a><ul><li><a href="#请求报文与响应报文">请求报文与响应报文</a></li><li><a href="#简介">简介</a></li><li><a href="#报文结构">报文结构</a></li><li><a href="#状态码">状态码</a></li><li><a href="#url的结构">URL的结构</a></li><li><a href="#方案">方案</a></li><li><a href="#查询">查询</a></li><li><a href="#cookie">Cookie</a></li><li><a href="#basic认证">BASIC认证</a></li><li><a href="#digest认证">digest认证</a></li><li><a href="#https3">https/3</a></li><li><a href="#方法">方法</a></li><li><a href="#响应码">响应码</a></li></ul></li><li><a href="#dhcp">DHCP</a></li><li><a href="#dns">DNS</a></li><li><a href="#远程文件服务器ftp">远程文件服务器：ftp</a><ul><li><a href="#客户端连接">客户端连接</a></li><li><a href="#服务器配置">服务器配置</a></li></ul></li><li><a href="#网络文件系统nfs">网络文件系统：NFS</a></li><li><a href="#网络层ip层">网络层（IP层）</a><ul><li><a href="#五类ip地址">五类IP地址</a></li><li><a href="#路由">路由</a></li><li><a href="#nat网络地址转换">NAT（网络地址转换）</a></li></ul></li><li><a href="#远程连接服务器ssh">远程连接服务器：SSH</a></li><li><a href="#oauth">OAuth</a><ul><li><a href="#github-授权">Github 授权</a></li><li><a href="#access-token">Access Token</a></li><li><a href="#微信授权">微信授权</a></li><li><a href="#github授权登陆流程">Github授权登陆流程</a></li><li><a href="#微信授权登陆流程">微信授权登陆流程</a></li></ul></li><li><a href="#加密协议">加密协议</a><ul><li><a href="#加密算法的分类">加密算法的分类</a></li><li><a href="#非对称秘钥的文件位置和内容">非对称秘钥的文件位置和内容</a></li><li><a href="#非对称加密传递信息">非对称加密传递信息</a></li><li><a href="#数字证书和数字签名">数字证书和数字签名</a></li><li><a href="#ssh">ssh</a></li><li><a href="#ssh-keygen">ssh-keygen</a></li><li><a href="#ssh-copy-id">ssh-copy-id</a></li></ul></li></ul><h2 id="osi七层模型" tabindex="-1">OSI七层模型 <a class="header-anchor" href="#osi七层模型" aria-label="Permalink to &quot;OSI七层模型&quot;">​</a></h2><p>将网络分为几个层次，每个层次都有特定独立的功能，每层独立实现、互不干扰。这就是TCP/IP的基础——OSI七层网络协议。</p><ul><li>第一层 物理层</li></ul><p>由于网络传输介质只能传送0与1这种比特位，因此物理层必须定义所使用的传输设备的电压与信号灯，同时还必须了解数据帧转换成比特流的编码方式，最后连接实际传输介质并发送/接收比特信号。</p><ul><li>第二层 数据链路层</li></ul><p>这一层是比较特殊的一个层，因为其下层都是实体的定义，而其上层则是软件封装的定义。因此第二层又分为两个子层进行数据的转换操作。在偏硬件部分，主要负责的MAC（Media Access Control），我们称这个数据包裹为MAC数据帧（frame），MAC是网络接口设备所能处理的主要数据包裹，这也是最终被物理层编码成比特流的数据。MAC必须要经过通信协议来取得网络介质的使用权，目前最常使用的则是IEEE 802.3的以太网络协议。 至于偏向软件的部分则是由逻辑链路层（Logical Link Control，LLC）所控制，主要在多任务处理来自上层的数据包数据（packet）并转成MAC的格式，负责的工作包括信息交换、流量控制、失误问题的处理等。</p><ul><li>第三层 网络层</li></ul><p>这一层就是IP（Internet Protocol）层，即路由协议层。同时也定义出计算机之间的连接建立、终止与维持、数据包的传输路径选择等。</p><ul><li>第四层 传输层</li></ul><p>这一个分层定义了发送端与接收端的连接技术（如TCP、UDP技术），同时包括该技术的数据包格式、数据包的发送、流程的控制、传输过程的侦测检查与重新传送等，以确保各个资料数据包可以正确无误的到底目的端。</p><ul><li>第五层 会话层</li></ul><p>在这个层次当中主要定义了两个地址之间的连接信道的连接与中断，此外，也可建立应用程序之间的会话、提供其他加强型服务如网络管理、建立与断开、会话控制等。如果说传输层是在判断数据包是否可以正确的到达目标，那么会话层则是在确定网络服务建立连接的确认。</p><ul><li>第六层 表示层</li></ul><p>我们通过应用程序生成出来的数据格式不一定符合网络传输的标准编码格式，所以，在这个层次当中，主要的操作是：将来自本地端应用程序的数据格式转换（或者重新编码）为网络的标准格式，然后再交给下面的传输层等的协议来进行处理。所以，在这个层次上面主要定义的是网络服务（或程序）之间的数据格式的转换，包括数据的加解密也是在这个层次上处理。</p><ul><li>第七层 应用层</li></ul><p>应用层本身不属于应用程序所有，而是在定义应用程序如何进入该层的沟通接口，以将数据接收或发送给应用程序，并最终展示给用户。</p><h2 id="tcp-ip-1" tabindex="-1">TCP/IP <a class="header-anchor" href="#tcp-ip-1" aria-label="Permalink to &quot;TCP/IP&quot;">​</a></h2><p>不过，事实上，OSI七层协议只是一个参考的模型，目前并没有什么知名的操作系统严格按照OSI七层协议实现。不过，OSI七层模型可以认为是TCP/IP的简化模型，将原来的七层简化为四层，实际的互联网程序代码都是基于TCP/IP模型。OSI七层协议与TCP/IP协议的对应关系如下：</p><ul><li>将最底下两层（物理层和链路层）简化为一层——网络接口层</li><li>OSI的网络层还是对应TCP/IP的网络层</li><li>OSI的传输层还是对应TCP/IP的传输层</li><li>将最上三层（会话层、表示层、应用层）简化为一层——应用层</li></ul><p>TCP/IP每层的相关通信协议与标准如下：</p><ul><li>网络接口层：WAN、LAN、ARP</li><li>网络层：IP、ICMP</li><li>传输层：TCP、UDP</li><li>应用层：HTTP(s)、FTP、SMTP、POP3、NFS、SSH</li></ul><p>拿一个访问网页的例子来演示TCP/IP协议的工作：</p><ul><li>应用程序阶段：打开浏览器，在地址栏输入网址，按下回车。此时网址信息与相关数据会被浏览器打包成一个数据包，向下传给应用层。</li><li>应用层：由应用层提供的HTTP通信协议，将来自浏览器的数据封装起来，并给予一个应用层报头，再向传输层丢去。</li><li>传输层：由于HTTP为可靠连接，因此将该数据包丢入TCP封装内，并给予一个TCP封装的报头，向网络层丢去。</li><li>网络层：将TCP数据封装到IP数据包内，再给予一个IP报头（主要就是来源于目标的IP），向网络接口层丢去。</li><li>网络接口层：如果使用以太网络事，此时IP会依据CSMA/CD的标准，封装到MAC数据帧中，并给予MAC帧头，再转成比特流后，利用传输介质发送到远程主机上。</li><li>等到目的主机收到数据包后，再以相反的方向拆解开头，每次交给对应的层次进行分析，最后WWW服务器软件获知你想要的数据，再取得正确的资料后，又遵循上述流程，一层一层的封装起来，最后传送到你的浏览器上。</li></ul><h2 id="传输层-tcp与udp" tabindex="-1">传输层：TCP与UDP <a class="header-anchor" href="#传输层-tcp与udp" aria-label="Permalink to &quot;传输层：TCP与UDP&quot;">​</a></h2><h3 id="端口" tabindex="-1">端口 <a class="header-anchor" href="#端口" aria-label="Permalink to &quot;端口&quot;">​</a></h3><p>我们都知道IP数据包的传送的起点和终点是IP地址，那么达到后具体应该连接到哪里去呢？一台主机可以部署多个服务，那么是连接到WWW服务器，还是FTP服务呢？这就需要通过端口区分不同的服务，一个特定的服务由两部分组成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>地址:端口</span></span></code></pre></div><p>地址可以是IP地址，也可以是主机名称。</p><p>端口的取值范围为0-65535，不过，0-1023已经分给了常用的应用程序，因此一般的取值范围是1024~65535。</p><p>常见的服务与端口的对应如下：</p><table tabindex="0"><thead><tr><th>服务</th><th>端口</th></tr></thead><tbody><tr><td>20</td><td>FTP</td></tr><tr><td>22</td><td>SSH 安全远程连接服务</td></tr><tr><td>25</td><td>SMTP 简单邮件传递协议</td></tr><tr><td>80</td><td>HTTP，超文本传输协议服务</td></tr><tr><td>110</td><td>POP3 邮件接收协议</td></tr><tr><td>443</td><td>HTTPS 安全加密的HTTP服务</td></tr><tr><td>3306</td><td>MySQL 默认端口号</td></tr></tbody></table><h3 id="tcp-三次握手" tabindex="-1">TCP 三次握手 <a class="header-anchor" href="#tcp-三次握手" aria-label="Permalink to &quot;TCP 三次握手&quot;">​</a></h3><p><img src="https://pics4.baidu.com/feed/1ad5ad6eddc451da91dfe64756fd5b6bd016327a.jpeg@f_auto?token=6a788b3425a128f386466dad924ccf99" alt="TCP的三次握手"></p><p>在TCP的连接模式中，在建立连接之前都必须通过三个确认的动作，所以这种连接方式也被称为三次握手，大致分为四个阶段。</p><ul><li><p>第一阶段，数据包发起 当可以的想要对服务器端连接时，就必须要送出一个要求连接的数据包，此时客户端必须随机取用一个大于1024的空闲的端口来作为程序沟通的接口。然后再TCP的报头当中，必须要带有SYN的主动连接（SYN=1），并且记下发出连接数据包给服务器端的序号（Sequence number = 10001）。</p></li><li><p>第二阶段，数据包接收与确认数据包发送 当服务器接收到这个数据包，并且确定要接收这个数据包后，就会开始制作一个同时带有SYN=1，ACK=1 的数据包，其中那个Acknowledge的号码是要给Client端确认用的，所以该数字会比A步骤里面的Sequence号码多一号（ack=10001+1=10002），那服务器也必须确认客户端确实可以接收我们的数据包才行，所以也会发送出一个Sequence（seq=20001）给客户端，并且开始等待客户端与服务器端的回应。</p></li><li><p>第三阶段，回送确认数据包 当客户端收到来自服务器端的ACK数字（10002）后，就能确认之前那个请求连接的数据包被正确接收了，接下来如果客户端也同意与服务器建立连接时，就会再次发送一个确认数据包（ACK=1）给服务器，即Acknowledge = 20001+1 = 20002.</p></li><li><p>第四阶段 取得最后确认 若一切都顺利，在服务器端收到带有ACK=1 且ack = 20002序号的数据包后，就能够建立起这次的连接了。</p></li></ul><p>举个通俗得了例子，好比两个人A和B在谈论事情之前打招呼：</p><ul><li>A说： B你听得到吗？</li><li>B说：我听得到，A你听得到吗？</li><li>A说：我也听得到</li></ul><p>可能有的人会有疑问，为什么B要再次询问一遍呢？B收到消息后直接建立连接不行吗？假设A说中文但听不懂英文，B说英文也可以听懂中文，这时候直接建立后A是听不懂的，必须要保证双方都能听懂对方说的话才行。</p><p>那为什么不来回更多次呢？理论上也是可以的，不过，为了节省资源，只需要双方都说一次，然后确认对方听懂了就够了。</p><p>总之，三次握手就是要确认两件事：</p><ul><li>服务端能有效识别客户端的信息</li><li>客户端能有效识别服务端的信息</li></ul><h3 id="tcp的四次挥手" tabindex="-1">TCP的四次挥手 <a class="header-anchor" href="#tcp的四次挥手" aria-label="Permalink to &quot;TCP的四次挥手&quot;">​</a></h3><p><img src="https://pics1.baidu.com/feed/c8177f3e6709c93d3b2db2957e3df1d1d0005486.jpeg@f_auto?token=d1003b5bd35811075409c512e0503094" alt="TCP的四次挥手"></p><p>TCP的四次挥手是为了结束已建立的连接，确保双方都能正确地关闭连接并释放资源。下面是四次挥手的过程：</p><ul><li><p>第一次挥手：客户端发送一个带有FIN（结束）标志的数据包，表示自己已经没有数据要发送了，请求关闭连接。</p></li><li><p>第二次挥手：服务器接收到客户端的结束请求后，会发送一个带有ACK（确认）标志的数据包作为响应，表示已收到客户端的结束请求。</p></li><li><p>第三次挥手：服务器发送一个带有FIN标志的数据包，表示自己也没有数据要发送了，请求关闭连接。</p></li><li><p>第四次挥手：客户端接收到服务器的结束请求后，会发送一个带有ACK标志的数据包作为确认，表示已收到服务器的结束请求。</p></li></ul><p>在关闭连接时，需要确保双方都完成了数据的传输和接收，以防止数据丢失或错误。如果只有三次挥手，可能会导致一些问题。</p><p>假设只有三次挥手，当客户端发送结束请求后，服务器收到后会发送确认，表示已收到客户端的结束请求。但是在此过程中，服务器可能还有未发送完的数据，如果直接关闭连接，那么这些数据就会丢失。因此，引入第三次挥手，服务器在发送结束请求前，先发送所有未发送完的数据，并等待客户端的确认。客户端接收到服务器的结束请求后，会确认并处理完未接收的数据，然后发送确认，表示自己已准备好关闭连接。</p><p>通过四次挥手，可以确保双方都能正确地结束连接，并处理未发送和未接收的数据，保证数据的完整性和可靠性。因此，关闭连接需要四次挥手。</p><h2 id="http协议" tabindex="-1">HTTP协议 <a class="header-anchor" href="#http协议" aria-label="Permalink to &quot;HTTP协议&quot;">​</a></h2><h3 id="请求报文与响应报文" tabindex="-1">请求报文与响应报文 <a class="header-anchor" href="#请求报文与响应报文" aria-label="Permalink to &quot;请求报文与响应报文&quot;">​</a></h3><p>客户端发送请求报文，服务器返回响应报文，报文有一定的格式约定，将格式约定好以便于发送和解析，这既是协议。</p><p>要查看报文实例，最好的方法是使用浏览器。</p><p>使用Edge浏览器，打开百度首页，按F12进入开发者工具，切换到网络选项卡，这时候应该有很多网络传输记录。</p><p>在右边的表头选项卡，我们能看到“常规”、“响应标头”、“请求标头”。这就是报文的内容。</p><p>我们解释几个典型的参数。</p><ul><li>请求URL：这就是我们常说的链接，只有通过链接才能拿到资源如HTML页面、文件、图片、视频。</li><li>请求方法：一般为GET，表示向服务器拿资源。开发中会用到POST表示携带正文向服务器发送。</li><li>状态代码：表示是成功还是错误，如果是200 OK表示成功返回了正确的资源。如果是4或5开头的代码，表示有错误。</li><li>远程地址：服务器的IP地址，这个地址是DNS系统通过解析之后得到的机器能够理解的地址。</li><li>请求标头：请求报文的头部，是对请求报文的概括和描述，如协议版本、能接受的编码等。</li><li>响应标头：响应报文的头部，是对响应报文的概括和描述，如字节大小等。</li></ul><h3 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h3><p>一般而言，网络传输的两端分为客户端和服务器。请求数据的叫做客户端，浏览器就是典型的客户端。接收请求，处理请求，将数据返回的机器叫做服务器。</p><p>客户端请求资源，就要用到资源定位符URI，URI是一个明确的地址，通过这个地址就能去到响应的服务器请求资源。</p><p>至于这中间是怎么从我们面前的浏览器到达世界另一个地方的服务器的过程比较复杂，包括数据的编码、打包、IP地址查询、路由、DNS轮询、握手、解包等，我们只需要知道有网络基础设施无时无刻都在为我们服务即可。</p><p>例如，我们访问百度。在浏览器地址栏输入<code>https://www.baidu.com</code>，这就是全球唯一的地址，通过这个地址就可以到达百度的服务器，然后服务器立即响应将HTML页面发回本地，我们就看到了百度的首页。</p><h3 id="报文结构" tabindex="-1">报文结构 <a class="header-anchor" href="#报文结构" aria-label="Permalink to &quot;报文结构&quot;">​</a></h3><p>请求和响应信息统称报文，结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>首部</span></span>
<span class="line"><span>&lt;空行&gt;</span></span>
<span class="line"><span>body</span></span></code></pre></div><p>首部每一行是一个键值对。</p><h3 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to &quot;状态码&quot;">​</a></h3><ul><li>1字头 正在处理的信息</li><li>2字头 成功时的响应，常用的是200 OK</li><li>3字头 服务器给客户端的命令，例如重东西或缓存</li><li>4字头 当客户端发送的请求中存在异常内容时发送的响应码</li><li>5字头 当服务器内部发生错误时发送给客户端的状态码</li></ul><h3 id="url的结构" tabindex="-1">URL的结构 <a class="header-anchor" href="#url的结构" aria-label="Permalink to &quot;URL的结构&quot;">​</a></h3><p>常见URL路径的结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>协议://主机名/路径</span></span></code></pre></div><p>而完整的URL路径的结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>协议:// 用户:密码@主机名:端口/路径?查询#片段</span></span></code></pre></div><h3 id="方案" tabindex="-1">方案 <a class="header-anchor" href="#方案" aria-label="Permalink to &quot;方案&quot;">​</a></h3><p>主要包括：</p><ul><li>http</li><li>https</li><li>mailto</li><li>file</li><li>ftp</li></ul><h3 id="查询" tabindex="-1">查询 <a class="header-anchor" href="#查询" aria-label="Permalink to &quot;查询&quot;">​</a></h3><p>用户要搜索的关键词，语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>key1=value1&amp;key2=value2</span></span></code></pre></div><h3 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h3><p>Cookie是将网站信息保存在浏览器的一种结构，由服务器指示客户端（浏览器）保存数据。</p><p>例如服务器发送的报文：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Set-Cookie: key1=value1</span></span>
<span class="line"><span>Set-Cookie: key2=value2</span></span></code></pre></div><p>客户端就会存储起来，下次请求时可以带上：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cookie: key1=value1</span></span>
<span class="line"><span>Cookie: key2=value2</span></span></code></pre></div><h3 id="basic认证" tabindex="-1">BASIC认证 <a class="header-anchor" href="#basic认证" aria-label="Permalink to &quot;BASIC认证&quot;">​</a></h3><p>如今大多数服务器需要登录，但通常的方式是只需要第一次登录，然后在一定的时间内免登陆。 basic认证是最简单的认证方式，通过base64编码，因为base64可逆，所以服务器可以还原出来原来的用户名和密码。将还原出来的用户名和密码与数据库中进行对比。如下是对用户名和密码进行编码后的示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>base64(用户名+&quot;:&quot;+密码)</span></span></code></pre></div><p>示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>base64(&#39;zhangsan&#39;+&#39;:&#39;+&#39;123456&#39;)  // emhhbmdzYW46MTIzNDU2</span></span>
<span class="line"><span>authorization: &quot;Basic emhhbmdzYW46MTIzNDU2&quot;</span></span></code></pre></div><h3 id="digest认证" tabindex="-1">digest认证 <a class="header-anchor" href="#digest认证" aria-label="Permalink to &quot;digest认证&quot;">​</a></h3><p>使用哈希函数。</p><h3 id="https-3" tabindex="-1">https/3 <a class="header-anchor" href="#https-3" aria-label="Permalink to &quot;https/3&quot;">​</a></h3><p>udp和tcp的区别：</p><ul><li>可靠的，需要进行三次我手</li><li>不可靠的，只负责发出去，不管有没有收到。</li></ul><p>http/2在与http同一层的tcp套接字上进行了实现，但google为了进一步提高通信速度，在udp套接字上提供了quic协议。</p><h3 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h3><p>HTTP协议有两种最常用的方法：</p><ul><li>get 通过url和query向服务器获取数据</li><li>post 在body中添加数据发给服务器，请求数据</li><li>put 新增文件</li><li>delete 删除文件</li></ul><h3 id="响应码" tabindex="-1">响应码 <a class="header-anchor" href="#响应码" aria-label="Permalink to &quot;响应码&quot;">​</a></h3><p>HTTP有4种常用的响应码，如下：</p><ul><li>200 | 客户端成功请求，服务器成功响应</li><li>3xx | 服务器指示客户端需要完成的工作，例如重定向</li><li>404 | 客户端出了错误，例如请求不存在的文件</li><li>5xx | 服 务器出了错误</li></ul><h2 id="dhcp" tabindex="-1">DHCP <a class="header-anchor" href="#dhcp" aria-label="Permalink to &quot;DHCP&quot;">​</a></h2><p>DHCP，Dynamic Host Configuration Protocol ，动态主机配置协议。DHCP服务器的主要工作，就是自动将正确的网络参数分配给网络中的每台主机，让客户端主机可以在联网的时候立即自动配置好网络的参数值，这些参数包括：IP、子网掩码、网段、网关、DNS地址等。现实生活中，我们的笔记本连上网络后，是不是很少去手动设置这些参数，而是直接就可以上网了，这就是因为DHCP服务器已经为我们配置好了。</p><p>DHCP为客户端提供的信息至少包括以下内容：</p><ul><li>IP地址</li><li>子网掩码</li><li>租赁时间：客户端并不是一直拥有该IP地址，当时间到期后必须再次请求。默认情况下，DHCP服务器会记住客户端并分配相同的地址。</li><li>域名服务器（DNS）地址：通常DHCP服务器会给一到三个DNS地址供客户端使用。</li><li>默认网关。为了让一个网络请求离开本地网络，必须知道网络上的哪个节点提供了到本地的网络之外地址的路由，这个节点就是网关。</li></ul><h2 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h2><p>实际上，要使一台主机连接到另一台主机的服务，必须知道IP地址和端口。端口的问题好说，如果是用浏览器上网，那么基本就是80端口，那么IP地址呢？为什么我们并不知道百度的IP地址却可以访问百度？这就用到了一种网络基础设施服务——DNS。</p><p>DNS，Domain Name System，域名系统，通过将由英文字母和数字组成的主机名转化成IP地址，使得数据包可以到达目的地。这个DNS也是网络中的一台主机，只是专门为我们提供DNS服务，DNS的地址是由DHCP服务器配置的。</p><p>例如，访问baidu.com，我们电脑的缓存中没有查到baidu.com对应的IP地址，此时就将baidu.com发送给DNS主机，DNS主机分析该路径的组成，再通过与全球其它的DNS服务器递归的查找和询问，最终得到了baidu.com的IP地址是xx.xx.xx.xx，再返回给我们的电脑，电脑拿到这个确定的IP地址后，就能够到达百度的服务器了。</p><p>这种询问过程的举例如下，例如访问baidu.com：</p><ul><li>我们的电脑将baidu.com发送给DNS服务器8.8.8.8</li><li>DNS服务器先去询问全球域名根服务器（/），得到管理com的服务器的IP地址</li><li>DNS服务器再去询问管理com的服务器，得到baidu.com的服务器的IP地址</li><li>DNS拿到具体的IP地址后，返回给我们的电脑。</li></ul><p>要知道具体是哪个IP地址，可以使用ping命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ ping baidu.com</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Pinging baidu.com [39.156.66.10] with 32 bytes of data:</span></span>
<span class="line"><span>Reply from 39.156.66.10: bytes=32 time=25ms TTL=48</span></span>
<span class="line"><span>Reply from 39.156.66.10: bytes=32 time=24ms TTL=48</span></span>
<span class="line"><span>Reply from 39.156.66.10: bytes=32 time=24ms TTL=48</span></span>
<span class="line"><span>Reply from 39.156.66.10: bytes=32 time=27ms TTL=48</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Ping statistics for 39.156.66.10:</span></span>
<span class="line"><span>    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</span></span>
<span class="line"><span>Approximate round trip times in milli-seconds:</span></span>
<span class="line"><span>    Minimum = 24ms, Maximum = 27ms, Average = 25ms</span></span></code></pre></div><p>也可以使用nslookup命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nslookup</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> baidu.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Server:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  public1.114dns.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Address:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  114.114.114.114</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Non-authoritative</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> answer:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    baidu.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Addresses:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  110.242.68.66</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          39.156.66.10</span></span></code></pre></div><h2 id="远程文件服务器-ftp" tabindex="-1">远程文件服务器：ftp <a class="header-anchor" href="#远程文件服务器-ftp" aria-label="Permalink to &quot;远程文件服务器：ftp&quot;">​</a></h2><h3 id="客户端连接" tabindex="-1">客户端连接 <a class="header-anchor" href="#客户端连接" aria-label="Permalink to &quot;客户端连接&quot;">​</a></h3><p>一般要提供如下参数：</p><ul><li>主机</li><li>端口，默认21</li><li>用户名和密码，如果允许匿名，则用户名为anonymous</li></ul><p>有三种方式连接到FTP服务器：</p><ul><li>命令行</li><li>客户端，例如FIlezilla</li><li>浏览器</li></ul><p>如果要使用浏览器连接ftp服务器，则在地址栏输入：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ftp://用户名:密码@主机地址</span></span></code></pre></div><h3 id="服务器配置" tabindex="-1">服务器配置 <a class="header-anchor" href="#服务器配置" aria-label="Permalink to &quot;服务器配置&quot;">​</a></h3><p>如果要自己搭建ftp服务器，则可以使用vsftpd这个软件。</p><h2 id="网络文件系统-nfs" tabindex="-1">网络文件系统：NFS <a class="header-anchor" href="#网络文件系统-nfs" aria-label="Permalink to &quot;网络文件系统：NFS&quot;">​</a></h2><p>NFS，Network File System，网络文件系统，作用是让不同的机器、不同的操作系统可以彼此共享文件。最主要的设置就是文件的权限。设置NFS服务器主要用到两个软件：rpcbind、nfs。</p><p>客户端如果要连接NFS服务器，只需要将NFS资源挂载到相关目录之下即可。</p><h2 id="网络层-ip层" tabindex="-1">网络层（IP层） <a class="header-anchor" href="#网络层-ip层" aria-label="Permalink to &quot;网络层（IP层）&quot;">​</a></h2><p>目前IP协议有两种版本：</p><ul><li>IPv4（因特网协议第四版）：由于地址仅有32位，预计2020年左右分配完毕。</li><li>IPv6（因特网协议第六版）：为了应对IPV4地址枯竭的问题，诞生了IPv6。ipv6的地址可以达到128位，这样的IP数据几乎是用不完的。不过，由于IPv6与IPv4协议互不兼容，需要从上而上大幅更换软硬件设施，因此推广问题值得关注。</li></ul><p>IP的组成是32位的数据，即由32个0与1组成的一连串数字。为了方便读写，将32位分为四小段，每段8位，又将每段换算为十进制，并且每段以小数点隔开，这就形成了我们日常见到的IP地址。例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>00000000.00000000.00000000.00000000   ==&gt;  0.0.0.0</span></span>
<span class="line"><span>11111111.11111111.11111111.11111111   ==&gt;  255.255.255.255</span></span></code></pre></div><p>这串数字中，又分为网络号码和主机号码。在同一个物理网段内，主机的IP具有相同的网络号码，并且具有唯一的主机号码。同时，同一个物理网段内，可以根据不同的IP设置，而设置成多个“IP网络”，也叫“子网段”。</p><p>另外，主机号码不能全部为0或1，全部为0表示整个网段的地址，全部为1表示广播地址。</p><h3 id="五类ip地址" tabindex="-1">五类IP地址 <a class="header-anchor" href="#五类ip地址" aria-label="Permalink to &quot;五类IP地址&quot;">​</a></h3><p>为了便于管理和方法，IP地址被分为了五类：</p><table tabindex="0"><thead><tr><th>类别</th><th style="text-align:center;">二进制网络号码开头</th><th>号段</th></tr></thead><tbody><tr><td>A类</td><td style="text-align:center;">0</td><td>0.xx.xx.xx ~ 127.xx.xx.xx</td></tr><tr><td>B类</td><td style="text-align:center;">10</td><td>128.xx.xx.xx ~ 191.xx.xx.xx</td></tr><tr><td>C类</td><td style="text-align:center;">110</td><td>192.xx.xx.xx ~ 223.xx.xx.xx</td></tr><tr><td>D类（组播使用）</td><td style="text-align:center;">1110</td><td>224.xx.xx.xx ~ 239.xx.xx.xx</td></tr><tr><td>E类（保留网段）</td><td style="text-align:center;">1111</td><td>240.xx.xx.xx ~ 255.xx.xx.xx</td></tr></tbody></table><p>能够用来一般系统上面的，只有A类、B类、C类地址，而普通人大概率只能申请到C类地址。</p><p>但是，上面的A、B、C类地址显示是不够用的，如果一个企业有10台主机，就要购买10个IP吗？为了解决这个问题，又提出了公有地址和私有地址。一个企业持有一个公有地址，下面可以规划若干了私有地址，这就解决了企业内部的IP地址问题。私有地址包括：</p><ul><li>A类私有地址： 10.0.0.0 ~ 10.255.255.255</li><li>B类私有地址 ： 172.16.0.0 ~ 172.31.255.255</li><li>C类私有地址 ： 192.168.0.0 ~ 192.168.255.255</li></ul><h3 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-label="Permalink to &quot;路由&quot;">​</a></h3><p>同一个网络段的主机可以直接通信，那么不同网络段呢？每一台主机都有一个路由表，每台主机传递数据时依据这个路由表决定“下一跳”。</p><h3 id="nat-网络地址转换" tabindex="-1">NAT（网络地址转换） <a class="header-anchor" href="#nat-网络地址转换" aria-label="Permalink to &quot;NAT（网络地址转换）&quot;">​</a></h3><p>如果私有IP要访问公网，需要通过NAT（网络地址转换）。一个公网IP加一个端口号映射到私有地址，这样私有地址的主机就可以访问公网了。</p><p>我们的手机可以访问公网，是因为连接到WiFi后，就会得到一个私有地址，持有公网IP的网络地址转换访问的公网。</p><h2 id="远程连接服务器-ssh" tabindex="-1">远程连接服务器：SSH <a class="header-anchor" href="#远程连接服务器-ssh" aria-label="Permalink to &quot;远程连接服务器：SSH&quot;">​</a></h2><p>远程连接服务器通过文字或图形的方式来远程登录系统，让你在远程的终端面前登录Linux主机以取得可操作得Shell，而登录后的感觉上就像坐在系统前面一样。</p><p>可以使用OpenSSH软件设置SSH服务。</p><p>客户端连接的语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [-p </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">端口号]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [账号@]主机地址 [命令]</span></span></code></pre></div><p>端口号一般默认为22，如果服务器设置了另外一个端口，使用新端口即可。</p><h2 id="oauth" tabindex="-1">OAuth <a class="header-anchor" href="#oauth" aria-label="Permalink to &quot;OAuth&quot;">​</a></h2><p>OAuth 是 Opne Authorizations的简写。</p><p>openid是微信用户在公众号appid下的唯一用户标识（appid不同，则获取到的openid就不同）</p><p><img src="https://bkimg.cdn.bcebos.com/pic/86d6277f9e2f0708ca1c2b2ceb24b899a901f285?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt="OAuth | 1200"></p><ul><li>AppID 应用ID</li><li>AppSecret 应用的密钥</li><li>Code 临时票据</li><li>返回access_token</li></ul><h3 id="github-授权" tabindex="-1">Github 授权 <a class="header-anchor" href="#github-授权" aria-label="Permalink to &quot;Github 授权&quot;">​</a></h3><p>打开<a href="https://github.com/settings/developers" target="_blank" rel="noreferrer">https://github.com/settings/developers</a> 注册一个OAuth应用。需要填写如下信息：</p><ul><li>Application Name：为应用取个名字。</li><li>homepageURL：主页地址</li><li>Authorization Callback URL为回调地址，当用户同意授权后，会回调该地址，并将授权码拼接到地址后面。</li></ul><p>注册完毕后会得到Client ID和Client Secret。</p><p>获取授权码请求路径 ：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  https://github.com/login/oauth/authorize?client_id=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">${clientId}&amp;redirect_uri</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">${redirect_uri}</span></span></code></pre></div><p>替换成应用的clientId和redirect_url。访问到授权服务器会重定向到redirect_url，并且在地址后面拼接授权码。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">POST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  https://github.com/login/oauth/access_token</span></span></code></pre></div><p>设置Accept: application/json。</p><p>带上body：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">	code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">授权码</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">	client_id:</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> your_client_id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">	client_secret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">your_secret_id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>得到Access Token，通过此令牌得到用户的信息：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Authorization: Bearer OAUTH-TOKEN</span></span>
<span class="line"><span>GET https://api.github.com/user</span></span></code></pre></div><h3 id="access-token" tabindex="-1">Access Token <a class="header-anchor" href="#access-token" aria-label="Permalink to &quot;Access Token&quot;">​</a></h3><p>最终的目的是获得一个Access Token，Access Token 唯一标识用户。</p><p>使用Refresh Token 获得一个新的Access Token。</p><p>三个地址：</p><ul><li>请求授权地址，例如 <code>授权服务器主机名/auth/login</code> 参数 client_id redict_id，请求后会打开授权页面</li><li>点击后，授权服务器返回的地址，即回调地址（携带Code）</li><li>请求回调地址，会得到Code</li><li>请求token地址，例如 <code>授权服务器主机名/auto/access_token</code> 参数Code + client_id + client_secret</li><li>获取Access_token</li><li>通过Access Token获取用户的OpenID</li></ul><h3 id="微信授权" tabindex="-1">微信授权 <a class="header-anchor" href="#微信授权" aria-label="Permalink to &quot;微信授权&quot;">​</a></h3><p>参考 ： <a href="https://blog.csdn.net/qq_36389060/article/details/124047449" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_36389060/article/details/124047449</a></p><p>获取 access_token 后可以进行哪些操作？</p><p>开发者可通过 OpenID 来获取用户基本信息</p><h3 id="github授权登陆流程" tabindex="-1">Github授权登陆流程 <a class="header-anchor" href="#github授权登陆流程" aria-label="Permalink to &quot;Github授权登陆流程&quot;">​</a></h3><table tabindex="0"><thead><tr><th>步骤</th><th>请求方式</th><th>请求URL</th><th>请求参数</th><th>返回内容</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td><code>https://github.com/login/oauth/authorize</code></td><td>client-id</td><td>redict-url</td></tr><tr><td>2</td><td>GET</td><td><code>redict_url</code></td><td>无</td><td>request-code</td></tr><tr><td>3</td><td>POST</td><td><code>https://github.com/login/oauth/access_token</code></td><td>client-id、client-secret、request-code</td><td>access-token</td></tr><tr><td>4</td><td>GET</td><td><code>https://api.github.com/user</code></td><td>请求头中添加access-token</td><td>github-id、github-url等GitHub用户信息</td></tr></tbody></table><h3 id="微信授权登陆流程" tabindex="-1">微信授权登陆流程 <a class="header-anchor" href="#微信授权登陆流程" aria-label="Permalink to &quot;微信授权登陆流程&quot;">​</a></h3><p>打开微信开发平台，地址：</p><table tabindex="0"><thead><tr><th>步骤</th><th>请求方式</th><th>请求URL</th><th>请求参数</th><th>返回内容</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td><code>https://open.weixin.qq.com/connect/qrconnect</code></td><td>client-id</td><td>redict-url</td></tr><tr><td>2</td><td>GET</td><td><code>redict_url</code></td><td>无</td><td>request-code</td></tr><tr><td>3</td><td>POST</td><td><code>https://api.weixin.qq.com/sns/oauth2/access_token</code></td><td>appid、secret、request-code</td><td>access-token、refresh-token</td></tr><tr><td>4</td><td>GET</td><td><code>https://api.weixin.qq.com/sns/userinfo</code></td><td>请求头中添加access-token</td><td>微信用户个人信息</td></tr><tr><td>5</td><td>GET</td><td><code>https://api.weixin.qq.com/sns/oauth2/refresh_token</code></td><td>appid、refresh-token</td><td>新的access-token</td></tr></tbody></table><h2 id="加密协议" tabindex="-1">加密协议 <a class="header-anchor" href="#加密协议" aria-label="Permalink to &quot;加密协议&quot;">​</a></h2><h3 id="加密算法的分类" tabindex="-1">加密算法的分类 <a class="header-anchor" href="#加密算法的分类" aria-label="Permalink to &quot;加密算法的分类&quot;">​</a></h3><ul><li>对称加密算法：在加密和解密时使用同一个密钥，这种算法不安全，几乎不再使用了。</li><li>非对称加密算法：通过密钥算法同时一对密钥：公钥和私钥，分别用于加密和解密。目前在各大安全协议中被使用。</li></ul><p>非对称加密算法主要包括：</p><ul><li>rsa：主流，ssh-keygen工具默认</li><li>dsa</li></ul><h3 id="非对称秘钥的文件位置和内容" tabindex="-1">非对称秘钥的文件位置和内容 <a class="header-anchor" href="#非对称秘钥的文件位置和内容" aria-label="Permalink to &quot;非对称秘钥的文件位置和内容&quot;">​</a></h3><p>公钥和私钥都是一个文本文件，里面存放着一定长度的字符串，默认放在~/.ssh目录。</p><p>公钥私钥是成对生成、成对存在的，其名字也应该对应。假设是用rsa算法生成的一对公私钥，那么其名称默认是：</p><ul><li>~/.ssh/id_rsa 私钥</li><li>~/.ssh/id_rsa.pub 公钥</li></ul><p>当然，名称也可以自己取一个有辨识度的名字。</p><p>公钥顾名思义就是可以公开的，A和B首先把自己的公钥发给对方，然后把对方的的公钥追加进自己的~/.ssh/known_hosts文件中，这个文件存放的是从网络上接收到的各个主机的公钥，每条信息占一行，每一行的格式如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>主机  加密算法   公钥字符串==</span></span></code></pre></div><h3 id="非对称加密传递信息" tabindex="-1">非对称加密传递信息 <a class="header-anchor" href="#非对称加密传递信息" aria-label="Permalink to &quot;非对称加密传递信息&quot;">​</a></h3><p>假设网络上的两台主机A和B需要传递信息。那么A和B首先生成自己的私钥和公钥。</p><p>现在A要跟B发送信息，A就使用B的公钥将原始信息加密，得到一条加密信息通过网络发送给B，由于原始信息是通过B的公钥加密的，那么加密信息只能通过B的私钥解密，A的公钥私钥、B的公钥、其它网络上任何人的公钥私钥都无法解密这条加密信息。B收到后通过自己的私钥成功界面，就看到了原始信息。在这个过程中，哪怕加密信息被别人截取到了，也无法解密。</p><p>总而言之，公钥是用来加密的，私钥是用来解密的。要给对方发送消息，就用对方的公钥加密，等信息到达对方主机后，对方就可以解密了。</p><p>非对称秘钥有几个特点：</p><ul><li>全局唯一：不同的人在同一时间，或同一个人在不同时间生成公钥私钥一定是不同的。也就是说，每个人的私钥一定是不同的，这确保了身份的准确性。</li><li>一对一：公钥和私钥是成对生成的，用公钥加密的信息只能通过对应的私钥解密，其它私钥绝对不可能解密。</li><li>确定性：用对应的私钥一定能解密，不用对应的私钥一定不能解密。</li></ul><h3 id="数字证书和数字签名" tabindex="-1">数字证书和数字签名 <a class="header-anchor" href="#数字证书和数字签名" aria-label="Permalink to &quot;数字证书和数字签名&quot;">​</a></h3><p>现在，又有一个问题，如何保证这条加密信息是由a发出来的？换句话说，C也可以生成一对公私钥，发送给B，然后对B说：“我是A，这是我的公钥”。</p><p>这种问题的漏洞在于，每个人都可以生成公钥私钥，但无法根据识别身份。这个时候，有一个第三方的权威机构，A向这家机构发动自己的公钥以及能够证明身份的信息（例如营业执照），完成自己在网络上的“实名认证”。这家权威机构在核实了A的信息和公钥之后，颁发给A一张数字证书，这家机构也叫数字证书颁发机构。有了权威机构的背书，任何人也无法冒充A了，因为现在人们获取公钥都直接从权威机构获取。</p><p>现在，A要向B发生信息，首先使用B的公钥加密原始信息，然后再用自己（A）的私钥再进行一道加密，这个过程就是数字签名。B收到加密信息后，首先向第三方权威机构获取A的公钥，然后使用A的公钥进行第一级解密，再用自己（B）的的私钥进行二级解密，就获取了原始信息。</p><p>数字证书颁发机构的作用就是完成公钥信息的“实名制”。</p><p>第一级加密和数字签名是对称的：</p><ul><li>第一级加密使用对方的公钥加密</li><li>第二级数字签名使用自己的私钥加密</li><li>收到信息后，首先向数字证书颁发机构获取发送方的公钥，完成数字签名信息的解密</li><li>然后使用自己的私钥解密出原始信息。</li></ul><p>总之，原始信息加密解密的方式是：接收的公钥加密，接收方的私钥解密。数字签名的加密解密方式是：发送方的私钥加密，发送到的公钥解密。</p><h3 id="ssh" tabindex="-1">ssh <a class="header-anchor" href="#ssh" aria-label="Permalink to &quot;ssh&quot;">​</a></h3><p>ssh命令用于登录远程主机</p><p>要登录远程主机，使用如下命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  远程用户名@远程主机</span></span></code></pre></div><p>此时会提示你输入密码。</p><p>输入<code>exit</code>退出登录。</p><p>如果是第一次登录该远程主机，则默认会将远程主机的公钥追加到文件~/.ssh/known_hosts 的末尾。</p><h3 id="ssh-keygen" tabindex="-1">ssh-keygen <a class="header-anchor" href="#ssh-keygen" aria-label="Permalink to &quot;ssh-keygen&quot;">​</a></h3><p>ssh-keygen可以用了生成一对公私钥，运行命令后，会提示你：</p><ul><li>输入私钥的文件名，默认为id_rsa。如果已经有一个私钥而想增加一个，可以自定义一个名称。公钥的名称为<code>私钥名称.pub</code>。</li><li>公钥的密码，默认不设密码</li></ul><h3 id="ssh-copy-id" tabindex="-1">ssh-copy-id <a class="header-anchor" href="#ssh-copy-id" aria-label="Permalink to &quot;ssh-copy-id&quot;">​</a></h3><p>使用ssh-copy-id将客户端的公钥复制到远程主机的同名家目录的.ssh目录的 <code>authorized_keys</code> 文件中。以后就可以直接连接而不用输入密码了。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh-copy-id</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 公钥路径</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 远程用户名@远程主机地址</span></span></code></pre></div></div></div></main><footer class="VPDocFooter" data-v-ddd4901f data-v-d088cbcb><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DAmnzHkr\",\"linux_ffmpeg.md\":\"FzfWtUVK\",\"linux_git_git-add.md\":\"CPj3v1KF\",\"linux_git_git-bash介绍.md\":\"Bzq7PvYb\",\"linux_git_git-branch分支管理.md\":\"BDQPTwCw\",\"linux_git_git-clone.md\":\"Do9zHSd3\",\"linux_git_git-commit.md\":\"Dadu13Ou\",\"linux_git_git-push.md\":\"DmlZ-ADI\",\"linux_git_git-remote_管理远程仓库.md\":\"DZzf_QBV\",\"linux_git_git常用命令汇总.md\":\"D0UWEhSY\",\"linux_git_git的原理和.git文件夹.md\":\"cKWqWnIK\",\"linux_git_index.md\":\"zCFPICDo\",\"linux_git_个人项目最常用的四个命令.md\":\"C9ZwpfYd\",\"linux_git_安装git.md\":\"75Z2ov_T\",\"linux_git_最佳实践——使用git-clone而不是git-init.md\":\"DcmDpy2l\",\"linux_git_查看提交历史.md\":\"BUToX9Gp\",\"linux_git_标签.md\":\"CPVtIcyD\",\"linux_git_版本回退.md\":\"BB2bprDN\",\"linux_git_配置用户名、邮箱和ssh秘钥.md\":\"C2shR9Pw\",\"linux_index.md\":\"BLHgTLhR\",\"linux_linux与内核_linux的进程和服务.md\":\"CgcyXAD9\",\"linux_linux与内核_分区管理.md\":\"B-d-boFm\",\"linux_shell_awk工具.md\":\"DI9MPl-Q\",\"linux_shell_bash-shell.md\":\"BAwG1KEh\",\"linux_shell_powershell.md\":\"DE9ve-LS\",\"linux_shell_sed工具.md\":\"BchXtfTS\",\"linux_shell_vim.md\":\"C9t0HI4M\",\"linux_shell_命令行语法规则.md\":\"CKa4oI0F\",\"linux_shell_常用命令.md\":\"d1RtVUnL\",\"linux_shell_文件权限.md\":\"DgfXtjAi\",\"linux_shell_文件系统管理.md\":\"DlB7-tGy\",\"linux_shell_管道和多命令组合.md\":\"BIZy1uC3\",\"linux_shell_编写脚本.md\":\"BJQ2htb_\",\"linux_virtualbox.md\":\"Ccyc3hHm\",\"linux_云计算_docker.md\":\"BR4nlvBr\",\"linux_云计算_函数计算.md\":\"DdHSvtdb\",\"linux_基础.md\":\"FrhlGG5A\",\"linux_常用语言入门_c__入门.md\":\"DiGClf8U\",\"linux_常用语言入门_c语言入门.md\":\"gH3sdo5o\",\"linux_常用语言入门_java入门.md\":\"B3afQF9e\",\"linux_网络协议_tcp-ip.md\":\"-BwLIwlG\",\"temp notes_office.md\":\"C5MITBlC\",\"人工智能_index.md\":\"Dg2YDT4Z\",\"人工智能_python_http和web.md\":\"BSB62P5H\",\"人工智能_python_index.md\":\"Br81O27V\",\"人工智能_python_jupyter.md\":\"CTkLuxIV\",\"人工智能_python_numpy.md\":\"DT7cvYLl\",\"人工智能_python_pandas.md\":\"DSfSS-aW\",\"人工智能_python_元组和映射.md\":\"DUj3K9G4\",\"人工智能_python_函数.md\":\"D98ZXQYr\",\"人工智能_python_列表.md\":\"ClljJYno\",\"人工智能_python_基础和语法.md\":\"N1ipSJZg\",\"人工智能_python_字典.md\":\"BKW-CCuz\",\"人工智能_python_字符串.md\":\"Ck3pcJd1\",\"人工智能_python_序列.md\":\"Bs8QPfFF\",\"人工智能_python_异步.md\":\"B-sTgisM\",\"人工智能_python_时间模块.md\":\"C-MLWOhD\",\"人工智能_python_模块和包管理.md\":\"CqWWwqU9\",\"人工智能_python_正则表达式.md\":\"w19OQgzn\",\"人工智能_python_系统控制.md\":\"DpHXd3CZ\",\"人工智能_python_读写文件系统.md\":\"BI257SWK\",\"人工智能_python_面向对象.md\":\"rzA_Grxy\",\"人工智能_sd_comfyui.md\":\"BjaYF3xK\",\"人工智能_sd_stable-diffusion.md\":\"COxso8et\",\"人工智能_大模型_gradio.md\":\"CXyzodCI\",\"人工智能_大模型_transformer.md\":\"DrwJnyzv\",\"人工智能_大模型_大模型.md\":\"CDPSnyYa\",\"前端_css_index.md\":\"D8HNU9Lf\",\"前端_css_tailwindcss——响应式设计.md\":\"DvOzfCgM\",\"前端_css_tailwindcss——圆角.md\":\"DvhlnkIR\",\"前端_css_tailwindcss——媒体查询.md\":\"B2ZVHmxx\",\"前端_css_tailwindcss——宽度和高度.md\":\"Bq1HJ_nF\",\"前端_css_tailwindcss——布局.md\":\"H6aUzPb6\",\"前端_css_tailwindcss——弹性布局.md\":\"BXnX70_O\",\"前端_css_tailwindcss——文本.md\":\"2PI3NfDG\",\"前端_css_tailwindcss——背景.md\":\"C2AAXRIs\",\"前端_css_媒体查询.md\":\"CojOgsZU\",\"前端_css_定位.md\":\"D4_7tKy_\",\"前端_css_容器查询.md\":\"0jDsIROh\",\"前端_css_常见的颜色名称参考.md\":\"CRVPZ1rF\",\"前端_css_文字样式.md\":\"CmZc-4O9\",\"前端_css_样式优先级.md\":\"BURYwMc_\",\"前端_css_浮动.md\":\"C7w2rSPK\",\"前端_css_特效.md\":\"P0pqKlYY\",\"前端_css_背景、边框、轮廓.md\":\"BorGPuUP\",\"前端_css_选择器.md\":\"BpX9GrUO\",\"前端_css_锚点定位.md\":\"DhcL8DeP\",\"前端_electron_index.md\":\"DQERyuYT\",\"前端_html_a元素.md\":\"D09cUJQE\",\"前端_html_input元素.md\":\"Dt6-0VfK\",\"前端_html_input元素与表单提交.md\":\"D6cMJLVk\",\"前端_html_select表单元素.md\":\"DrL2Nfh3\",\"前端_html_video元素.md\":\"Bx_A_MBS\",\"前端_html_段落元素：p.md\":\"Dx7BgoB0\",\"前端_html_节点的属性.md\":\"CVWgROJ0\",\"前端_html_表单.md\":\"Bx3_KAHS\",\"前端_html_表格.md\":\"CjZr2XVK\",\"前端_html_音频.md\":\"hL6P4v6f\",\"前端_html_预格式文本元素pre和代码块元素code.md\":\"CRWsINLW\",\"前端_javascript_index.md\":\"DCaH1esg\",\"前端_javascript_代理.md\":\"Biw7lNFH\",\"前端_javascript_函数.md\":\"l4rz7JLu\",\"前端_javascript_原型和原型链.md\":\"C8PcoUCY\",\"前端_javascript_基础和语法.md\":\"sDjTSVq6\",\"前端_javascript_字符串.md\":\"BfnNRK7W\",\"前端_javascript_对象.md\":\"CO4zr1p1\",\"前端_javascript_数组.md\":\"bJKraIuh\",\"前端_javascript_期约和异步.md\":\"BJg7a2N9\",\"前端_javascript_正则表达式.md\":\"DMnXAs0I\",\"前端_javascript_迭代器和生成器.md\":\"CMxIAgUz\",\"前端_javascript_集合和映射.md\":\"C7Yfim_y\",\"前端_javascript_面向对象.md\":\"B-v0IqrG\",\"前端_node.js_http.md\":\"C4rNOUvT\",\"前端_node.js_index.md\":\"CAPx-tHu\",\"前端_node.js_npm.md\":\"DPyu9DC9\",\"前端_node.js_zx.js——使用.md\":\"CfJ_9JGD\",\"前端_node.js_zx.js——内置函数.md\":\"D_fAfk7k\",\"前端_node.js_zx.js——简介.md\":\"C7vktvoW\",\"前端_node.js_文件读写.md\":\"UjNJ9q9G\",\"前端_node.js_模块.md\":\"CuBZ3Hf2\",\"前端_node.js_路径处理.md\":\"C0ni77P4\",\"前端_react-native_adb命令的使用.md\":\"OBMZdPtQ\",\"前端_react-native_android——activity节点.md\":\"B6R9Q7YF\",\"前端_react-native_android——android项目源码结构.md\":\"Cymp4Gvt\",\"前端_react-native_android——manifest节点和application节点.md\":\"CDRYPvTM\",\"前端_react-native_android——user-permission节点.md\":\"CbQOILQ8\",\"前端_react-native_android——xml文件中的变量.md\":\"BQhBIuUL\",\"前端_react-native_gradle.md\":\"A05Lln9v\",\"前端_react-native_index.md\":\"DHa8eFYM\",\"前端_react-native_jdk的安装和配置.md\":\"B2QxstlU\",\"前端_react-native_使用gradle打包安卓apk.md\":\"OaMenGxW\",\"前端_react-native_无线调试.md\":\"Clv8AaRR\",\"前端_react-native_有线调试.md\":\"DirBZpEx\",\"前端_react_index.md\":\"CQXSeQpm\",\"前端_react_next.js.md\":\"DX1ZqOTj\",\"前端_react_props传值.md\":\"Dt8hHk4L\",\"前端_react_react-hooks.md\":\"C9NEbvpC\",\"前端_react_react基础.md\":\"DXegdZRO\",\"前端_react_redux全局状态管理.md\":\"BUZJyZzg\",\"前端_webrtc_index.md\":\"DurRa6rR\",\"前端_浏览器中的javascript_cookie.md\":\"BizT8Q7E\",\"前端_浏览器中的javascript_document对象.md\":\"DPkKfgSk\",\"前端_浏览器中的javascript_dom.md\":\"Cf6S_6pY\",\"前端_浏览器中的javascript_htmlelement类型.md\":\"TCixBwah\",\"前端_浏览器中的javascript_local storage.md\":\"FY3drh_L\",\"前端_浏览器中的javascript_requestanimationframe.md\":\"DEJwNwul\",\"前端_浏览器中的javascript_socket和websocket.md\":\"Cjhnqic4\",\"前端_浏览器中的javascript_web-api.md\":\"DuSD0PAY\",\"前端_浏览器中的javascript_元素的属性.md\":\"BKvg55Qz\",\"前端_浏览器中的javascript_理解dom.md\":\"cnHGY8BC\",\"前端_浏览器中的javascript_自定义事件.md\":\"Cvdfg68I\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"我的个人博客网站\",\"description\":\"个人博客网站\",\"base\":\"/blog/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>