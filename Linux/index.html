<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>上篇：基础篇 | 我的个人博客网站</title>
    <meta name="description" content="个人博客网站">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/blog/assets/style.DojTdoJJ.css" as="style">
    <link rel="preload stylesheet" href="/blog/vp-icons.css" as="style">
    
    <script type="module" src="/blog/assets/app.NdgFzaQX.js"></script>
    <link rel="preload" href="/blog/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/blog/assets/chunks/theme.CnFomNyw.js">
    <link rel="modulepreload" href="/blog/assets/chunks/framework.CDwmhxVj.js">
    <link rel="modulepreload" href="/blog/assets/Linux_index.md.pFrvyMHe.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-bd45b254><!--[--><!--]--><!--[--><span tabindex="-1" data-v-40f86efc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-40f86efc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-bd45b254 data-v-fb232767><div class="VPNavBar" data-v-fb232767 data-v-da0c6bb0><div class="wrapper" data-v-da0c6bb0><div class="container" data-v-da0c6bb0><div class="title" data-v-da0c6bb0><div class="VPNavBarTitle" data-v-da0c6bb0 data-v-dcd02d3b><a class="title" href="/blog/" data-v-dcd02d3b><!--[--><!--]--><!----><span data-v-dcd02d3b>我的个人博客网站</span><!--[--><!--]--></a></div></div><div class="content" data-v-da0c6bb0><div class="content-body" data-v-da0c6bb0><!--[--><!--]--><div class="VPNavBarSearch search" data-v-da0c6bb0><!----></div><!----><!----><div class="VPNavBarAppearance appearance" data-v-da0c6bb0 data-v-60d4da9a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-60d4da9a data-v-dd4d226c data-v-27e5f2a7><span class="check" data-v-27e5f2a7><span class="icon" data-v-27e5f2a7><!--[--><span class="vpi-sun sun" data-v-dd4d226c></span><span class="vpi-moon moon" data-v-dd4d226c></span><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-da0c6bb0 data-v-700cb35d data-v-ec49d971><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-ec49d971><span class="vpi-more-horizontal icon" data-v-ec49d971></span></button><div class="menu" data-v-ec49d971><div class="VPMenu" data-v-ec49d971 data-v-381ce922><!----><!--[--><!--[--><!----><div class="group" data-v-700cb35d><div class="item appearance" data-v-700cb35d><p class="label" data-v-700cb35d>Appearance</p><div class="appearance-action" data-v-700cb35d><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-700cb35d data-v-dd4d226c data-v-27e5f2a7><span class="check" data-v-27e5f2a7><span class="icon" data-v-27e5f2a7><!--[--><span class="vpi-sun sun" data-v-dd4d226c></span><span class="vpi-moon moon" data-v-dd4d226c></span><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-da0c6bb0 data-v-aa5c404b><span class="container" data-v-aa5c404b><span class="top" data-v-aa5c404b></span><span class="middle" data-v-aa5c404b></span><span class="bottom" data-v-aa5c404b></span></span></button></div></div></div></div><div class="divider" data-v-da0c6bb0><div class="divider-line" data-v-da0c6bb0></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-bd45b254 data-v-1337b658><div class="container" data-v-1337b658><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-1337b658 data-v-05f14d6b><button data-v-05f14d6b>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-bd45b254 data-v-d83a6a16><div class="VPDoc has-aside" data-v-d83a6a16 data-v-ddd4901f><!--[--><!--]--><div class="container" data-v-ddd4901f><div class="aside" data-v-ddd4901f><div class="aside-curtain" data-v-ddd4901f></div><div class="aside-container" data-v-ddd4901f><div class="aside-content" data-v-ddd4901f><div class="VPDocAside" data-v-ddd4901f data-v-9ff60a05><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-9ff60a05 data-v-7cf8e59d><div class="content" data-v-7cf8e59d><div class="outline-marker" data-v-7cf8e59d></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-7cf8e59d>On this page</div><ul class="VPDocOutlineItem root" data-v-7cf8e59d data-v-385136ab><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-9ff60a05></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-ddd4901f><div class="content-container" data-v-ddd4901f><!--[--><!--]--><main class="main" data-v-ddd4901f><div style="position:relative;" class="vp-doc _blog_Linux_" data-v-ddd4901f><div><nav class="table-of-contents"><ul><li><a href="#管道">管道</a></li><li><a href="#重定向">重定向</a><ul><li><a href="#覆写">覆写</a></li><li><a href="#追加">追加</a></li><li><a href="#将输出和错误分别重定向">将输出和错误分别重定向</a></li><li><a href="#将输出和错误集中输出">将输出和错误集中输出</a></li><li><a href="#丢弃输出">丢弃输出</a></li><li><a href="#多个命令组重定向">多个命令组重定向</a></li></ul></li><li><a href="#子命令-命令替换">子命令（命令替换）</a></li><li><a href="#命令行的tab补全">命令行的Tab补全</a></li><li><a href="#通配符">通配符</a></li><li><a href="#命令的返回值">命令的返回值</a></li><li><a href="#单行多命令">单行多命令</a></li><li><a href="#shell子进程和脚本的执行方式">Shell子进程和脚本的执行方式</a></li><li><a href="#修改文件-目录所有者-所属组">修改文件/目录所有者/所属组</a></li><li><a href="#数字方法修改权限">数字方法修改权限</a></li><li><a href="#符号方法修改权限">符号方法修改权限</a></li><li><a href="#文件与目录的权限区别">文件与目录的权限区别</a></li><li><a href="#文件系统管理命令汇总">文件系统管理命令汇总</a></li><li><a href="#linux目录树的组织原则">Linux目录树的组织原则</a></li><li><a href="#ls命令">ls命令</a></li><li><a href="#切换当前目录-cd命令">切换当前目录：cd命令</a></li><li><a href="#复制文件">复制文件</a></li><li><a href="#复制目录">复制目录</a></li><li><a href="#mv命令">mv命令</a></li><li><a href="#rm命令">rm命令</a></li><li><a href="#获取文件名和目录名-basename和dirname命令">获取文件名和目录名：basename和dirname命令</a></li><li><a href="#查看文件内容">查看文件内容</a></li><li><a href="#cat命令">cat命令</a></li><li><a href="#head和tail命令">head和tail命令</a></li><li><a href="#比较文件内容-cmp命令">比较文件内容： cmp命令</a></li><li><a href="#split命令">split命令</a></li><li><a href="#cut">cut</a></li><li><a href="#排序-sort命令">排序：sort命令</a></li><li><a href="#grep命令">grep命令</a></li><li><a href="#which命令">which命令</a></li><li><a href="#type命令">type命令</a></li><li><a href="#输出到终端——echo命令">输出到终端——echo命令</a></li><li><a href="#写内容到文件的快速方式">写内容到文件的快速方式</a></li><li><a href="#read命令">read命令</a></li><li><a href="#将输入存入数组">将输入存入数组</a></li><li><a href="#查看系统与内核相关信息">查看系统与内核相关信息</a></li><li><a href="#远程连接-ssh命令">远程连接：ssh命令</a></li><li><a href="#网络请求-curl命令">网络请求：curl命令</a></li><li><a href="#find">find</a></li><li><a href="#locate">locate</a></li><li><a href="#进程管理">进程管理</a></li><li><a href="#更改apt镜像源">更改apt镜像源</a></li><li><a href="#使用apt管理软件包">使用apt管理软件包</a></li><li><a href="#bash的配置文件">Bash的配置文件</a></li><li><a href="#bash-shell的快捷键">Bash Shell的快捷键</a></li><li><a href="#打开文件">打开文件</a></li><li><a href="#三种模式的切换">三种模式的切换</a></li><li><a href="#命令模式下的操作">命令模式下的操作</a></li><li><a href="#选择模式下的操作">选择模式下的操作</a></li><li><a href="#插入内容">插入内容</a></li><li><a href="#回到命令模式">回到命令模式</a></li><li><a href="#常用按键汇总">常用按键汇总</a></li><li><a href="#声明变量">声明变量</a></li><li><a href="#打印变量">打印变量</a></li><li><a href="#字符串转义">字符串转义</a></li><li><a href="#变量内容的编辑">变量内容的编辑</a></li><li><a href="#几种特殊的内容替换结构">几种特殊的内容替换结构</a></li><li><a href="#shell脚本的参数">shell脚本的参数</a></li><li><a href="#条件表达式">条件表达式</a></li><li><a href="#数值比较">数值比较</a></li><li><a href="#字符串比较">字符串比较</a></li><li><a href="#文件判断">文件判断</a></li><li><a href="#if语句">if语句</a></li><li><a href="#for循环">for循环</a></li><li><a href="#函数">函数</a><ul><li><a href="#创建函数">创建函数</a></li><li><a href="#调用函数">调用函数</a></li><li><a href="#带参数的函数">带参数的函数</a></li><li><a href="#函数的返回值">函数的返回值</a></li></ul></li><li><a href="#数组">数组</a></li><li><a href="#给脚本传递参数">给脚本传递参数</a></li><li><a href="#语法">语法</a></li><li><a href="#示例">示例</a></li><li><a href="#内部变量">内部变量</a></li><li><a href="#行筛选条件">行筛选条件</a></li><li><a href="#if语句-1">if语句</a></li><li><a href="#设备名称">设备名称</a></li><li><a href="#分区、挂载、挂载点的概念">分区、挂载、挂载点的概念</a></li><li><a href="#分区表">分区表</a></li><li><a href="#分区管理">分区管理</a></li><li><a href="#挂载">挂载</a><ul><li><a href="#自动挂载">自动挂载</a></li><li><a href="#手动挂载">手动挂载</a></li><li><a href="#数组和指针">数组和指针</a></li><li><a href="#字符串和指针">字符串和指针</a></li><li><a href="#结构体和指针">结构体和指针</a></li><li><a href="#输出">输出</a></li><li><a href="#整数类型">整数类型</a></li><li><a href="#函数-1">函数</a></li><li><a href="#浮点数">浮点数</a></li><li><a href="#字符串">字符串</a></li><li><a href="#结构体">结构体</a></li><li><a href="#数组-1">数组</a></li><li><a href="#for循环-1">for循环</a></li><li><a href="#if语句-2">if语句</a></li><li><a href="#三元表达式">三元表达式</a></li><li><a href="#helloworld">HelloWorld</a></li><li><a href="#包和导入">包和导入</a></li><li><a href="#浮点类型">浮点类型</a></li><li><a href="#泛型数组">泛型数组</a></li><li><a href="#var">var</a></li><li><a href="#arraylist">ArrayList</a></li><li><a href="#hashmap">HashMap</a></li><li><a href="#泛型hashmap">泛型HashMap</a></li><li><a href="#map">Map</a></li><li><a href="#线程">线程</a></li><li><a href="#读取输入">读取输入</a></li></ul></li><li><a href="#触发器">触发器</a></li><li><a href="#函数处理程序">函数处理程序</a></li><li><a href="#event">event</a></li><li><a href="#node-js运行时">Node.js运行时</a></li><li><a href="#python运行时">Python运行时</a></li><li><a href="#linux简介">Linux简介</a></li><li><a href="#shell简介">Shell简介</a></li><li><a href="#在windows上获取bash">在Windows上获取bash</a></li><li><a href="#终端提示符">终端提示符</a></li><li><a href="#bash常用快捷键">Bash常用快捷键</a></li><li><a href="#tab补全">Tab补全</a></li><li><a href="#环境变量">环境变量</a><ul><li><a href="#bash的内置环境变量">Bash的内置环境变量</a></li><li><a href="#修改path环境变量">修改PATH环境变量</a></li><li><a href="#新增和修改自定义环境变量">新增和修改自定义环境变量</a></li><li><a href="#普通变量和环境变量的区别">普通变量和环境变量的区别</a></li></ul></li><li><a href="#镜像和容器的概念区别">镜像和容器的概念区别</a></li><li><a href="#docker主要命令汇总">docker主要命令汇总</a></li><li><a href="#docker-run命令">docker run命令</a></li><li><a href="#docker-build命令">docker build命令</a></li><li><a href="#目录映射">目录映射</a></li><li><a href="#编写dockerfile文件">编写Dockerfile文件</a><ul><li><a href="#from-获取基础镜像">FROM ： 获取基础镜像</a></li><li><a href="#copy-复制本地文件到镜像">COPY：复制本地文件到镜像</a></li><li><a href="#run-执行命令">RUN：执行命令</a></li><li><a href="#workdir-设置初始目录">WORKDIR ：设置初始目录</a></li><li><a href="#env-设置环境变量">ENV：设置环境变量</a></li><li><a href="#cmd-容器启动后的初识命令">CMD ：容器启动后的初识命令</a></li></ul></li><li><a href="#基础使用">基础使用</a><ul><li><a href="#音视频基础知识">音视频基础知识</a></li><li><a href="#安装">安装</a></li><li><a href="#音视频基本概念">音视频基本概念</a></li></ul></li><li><a href="#能力集列表">能力集列表</a><ul><li><a href="#ffmpeg命令汇总">ffmpeg命令汇总</a></li><li><a href="#格式转换">格式转换</a></li><li><a href="#截取视频片段">截取视频片段</a></li><li><a href="#去掉音频或去掉视频">去掉音频或去掉视频</a></li><li><a href="#合并视频">合并视频</a></li><li><a href="#裁剪画面尺寸">裁剪画面尺寸</a></li><li><a href="#合并多个音频">合并多个音频</a></li><li><a href="#调整音量">调整音量</a></li><li><a href="#音频淡入淡出">音频淡入淡出</a></li><li><a href="#声音变速不变调">声音变速不变调</a></li><li><a href="#ffplay的用法">ffplay的用法</a></li></ul></li><li><a href="#水印">水印</a><ul><li><a href="#文字水印">文字水印</a></li><li><a href="#图片水印">图片水印</a></li></ul></li><li><a href="#字幕">字幕</a><ul><li><a href="#字幕-1">字幕</a></li></ul></li><li><a href="#复杂滤镜">复杂滤镜</a><ul><li><a href="#常见的复杂滤镜">常见的复杂滤镜</a></li><li><a href="#复杂滤镜的语法">复杂滤镜的语法</a></li><li><a href="#subtitles字幕滤镜">subtitles字幕滤镜</a></li><li><a href="#drawtext-文字滤镜">drawtext 文字滤镜</a></li><li><a href="#crop">crop</a></li><li><a href="#select">select</a></li></ul></li><li><a href="#录屏">录屏</a></li><li><a href="#安装git">安装Git</a></li><li><a href="#配置ssh登录">配置SSH登录</a></li><li><a href="#配置用户名和邮箱">配置用户名和邮箱</a></li><li><a href="#git-bash">Git Bash</a></li><li><a href="#git的原理和-git-文件夹">Git的原理和 .git 文件夹</a></li><li><a href="#git-clone">git clone</a></li><li><a href="#使用git-clone-而不是-git-init">使用git clone 而不是 git init</a></li><li><a href="#git-add">git add</a></li><li><a href="#git-branch分支管理">git branch分支管理</a></li><li><a href="#远程仓库管理">远程仓库管理</a></li><li><a href="#git-commit">git commit</a></li><li><a href="#git-push">git push</a></li><li><a href="#个人项目git常用的命令">个人项目Git常用的命令</a></li><li><a href="#查看提交历史">查看提交历史</a></li><li><a href="#回退">回退</a></li><li><a href="#标签">标签</a></li><li><a href="#服务">服务</a><ul><li><a href="#进程和服务的区别">进程和服务的区别</a></li><li><a href="#初始化系统的分类">初始化系统的分类</a></li><li><a href="#systemd的单元、服务单元、目标单元">systemd的单元、服务单元、目标单元</a></li><li><a href="#systemd单元的配置文件">systemd单元的配置文件</a></li><li><a href="#启停服务">启停服务</a></li></ul></li><li><a href="#图形界面">图形界面</a><ul><li><a href="#x-window-system">X Window System</a></li><li><a href="#wayland">Wayland</a></li></ul></li><li><a href="#别名">别名</a></li><li><a href="#获取内置别名-get-alias">获取内置别名：Get-Alias</a></li><li><a href="#创建别名">创建别名</a></li><li><a href="#内置的常用别名">内置的常用别名</a></li><li><a href="#具有参数的命令的备用名称">具有参数的命令的备用名称</a></li><li><a href="#读取文本文件内容">读取文本文件内容</a></li><li><a href="#管道-1">管道</a></li><li><a href="#子命令">子命令</a></li><li><a href="#单行多命令-1">单行多命令</a></li><li><a href="#工作目录">工作目录</a></li><li><a href="#相对路径和绝对路径">相对路径和绝对路径</a></li><li><a href="#f7显示历史记录">F7显示历史记录</a></li><li><a href="#使用通配符">使用通配符</a></li><li><a href="#删除文件和文件夹">删除文件和文件夹</a></li><li><a href="#out-host">out-host</a></li><li><a href="#out-file">out-file</a></li><li><a href="#创建数组">创建数组</a></li><li><a href="#读取文本文件到数组中">读取文本文件到数组中</a></li><li><a href="#访问数组元素">访问数组元素</a></li><li><a href="#修改数组">修改数组</a></li><li><a href="#数组的长度">数组的长度</a><ul><li><a href="#合并两个数组">合并两个数组</a></li></ul></li><li><a href="#迭代数组">迭代数组</a></li><li><a href="#筛选数组">筛选数组</a></li><li><a href="#比较运算符">比较运算符</a></li><li><a href="#在powershell启动时运行的脚本">在PowerShell启动时运行的脚本</a></li><li><a href="#csv">CSV</a></li><li><a href="#json">JSON</a></li><li><a href="#变量的声明和打印">变量的声明和打印</a></li><li><a href="#字符串-1">字符串</a></li><li><a href="#变量内插">变量内插</a></li><li><a href="#布尔值">布尔值</a></li><li><a href="#数值">数值</a><ul><li><a href="#整数">整数</a></li><li><a href="#浮点数-1">浮点数</a></li></ul></li><li><a href="#没有参数的函数">没有参数的函数</a></li><li><a href="#有参数的函数">有参数的函数</a></li><li><a href="#参数的默认值">参数的默认值</a></li><li><a href="#for循环-2">for循环</a></li><li><a href="#foreach语句">foreach语句</a></li><li><a href="#foreach-方法">foreach()方法</a></li><li><a href="#内置变量">内置变量</a></li><li><a href="#内置环境变量">内置环境变量</a></li><li><a href="#读取和修改path环境变量">读取和修改PATH环境变量</a></li><li><a href="#新增和修改自定义环境变量-1">新增和修改自定义环境变量</a></li><li><a href="#普通变量和环境变量的区别-1">普通变量和环境变量的区别</a></li><li><a href="#psreadline">PSReadLine</a></li><li><a href="#以管理员身份运行">以管理员身份运行</a></li><li><a href="#获取帮助">获取帮助</a></li><li><a href="#不区分大小写">不区分大小写</a></li><li><a href="#提示符约定">提示符约定</a></li><li><a href="#注释">注释</a></li><li><a href="#配置文件">配置文件</a></li><li><a href="#sed命令语法">sed命令语法</a></li><li><a href="#找到匹配的行">找到匹配的行</a></li><li><a href="#基于整行的打印">基于整行的打印</a></li><li><a href="#基于整行的删除">基于整行的删除</a></li><li><a href="#基于整行的追加、插入和替换">基于整行的追加、插入和替换</a></li><li><a href="#基于字符的查找替换">基于字符的查找替换</a></li><li><a href="#sed配合管道、重定向">sed配合管道、重定向</a></li><li><a href="#osi七层模型">OSI七层模型</a></li><li><a href="#tcp-ip-1">TCP/IP</a></li><li><a href="#传输层-tcp与udp">传输层：TCP与UDP</a><ul><li><a href="#端口">端口</a></li><li><a href="#tcp-三次握手">TCP 三次握手</a></li><li><a href="#tcp的四次挥手">TCP的四次挥手</a></li></ul></li><li><a href="#http协议">HTTP协议</a><ul><li><a href="#请求报文与响应报文">请求报文与响应报文</a></li><li><a href="#简介">简介</a></li><li><a href="#报文结构">报文结构</a></li><li><a href="#状态码">状态码</a></li><li><a href="#url的结构">URL的结构</a></li><li><a href="#方案">方案</a></li><li><a href="#查询">查询</a></li><li><a href="#cookie">Cookie</a></li><li><a href="#basic认证">BASIC认证</a></li><li><a href="#digest认证">digest认证</a></li><li><a href="#https-3">https/3</a></li><li><a href="#方法">方法</a></li><li><a href="#响应码">响应码</a></li></ul></li><li><a href="#dhcp">DHCP</a></li><li><a href="#dns">DNS</a></li><li><a href="#远程文件服务器-ftp">远程文件服务器：ftp</a><ul><li><a href="#客户端连接">客户端连接</a></li><li><a href="#服务器配置">服务器配置</a></li></ul></li><li><a href="#网络文件系统-nfs">网络文件系统：NFS</a></li><li><a href="#网络层-ip层">网络层（IP层）</a><ul><li><a href="#五类ip地址">五类IP地址</a></li><li><a href="#路由">路由</a></li><li><a href="#nat-网络地址转换">NAT（网络地址转换）</a></li></ul></li><li><a href="#远程连接服务器-ssh">远程连接服务器：SSH</a></li><li><a href="#oauth">OAuth</a><ul><li><a href="#github-授权">Github 授权</a></li><li><a href="#access-token">Access Token</a></li><li><a href="#微信授权">微信授权</a></li><li><a href="#github授权登陆流程">Github授权登陆流程</a></li><li><a href="#微信授权登陆流程">微信授权登陆流程</a></li></ul></li><li><a href="#加密协议">加密协议</a><ul><li><a href="#加密算法的分类">加密算法的分类</a></li><li><a href="#非对称秘钥的文件位置和内容">非对称秘钥的文件位置和内容</a></li><li><a href="#非对称加密传递信息">非对称加密传递信息</a></li><li><a href="#数字证书和数字签名">数字证书和数字签名</a></li><li><a href="#ssh">ssh</a></li><li><a href="#ssh-keygen">ssh-keygen</a></li><li><a href="#ssh-copy-id">ssh-copy-id</a></li></ul></li></ul></nav><h1 id="上篇-基础篇" tabindex="-1">上篇：基础篇 <a class="header-anchor" href="#上篇-基础篇" aria-label="Permalink to &quot;上篇：基础篇&quot;">​</a></h1><h1 id="命令行语法规则" tabindex="-1">命令行语法规则 <a class="header-anchor" href="#命令行语法规则" aria-label="Permalink to &quot;命令行语法规则&quot;">​</a></h1><h2 id="管道" tabindex="-1">管道 <a class="header-anchor" href="#管道" aria-label="Permalink to &quot;管道&quot;">​</a></h2><p>管道可以说是命令行的灵魂，如同管道的名字一样，管道使得命令行的操作如行云流水一般。</p><p>一个实用的例子是求出本目录下文件的数量：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -l</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   nl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  tail</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -1</span></span></code></pre></div><p>这里暂且先不考虑链接文件的情况， 本例子先使用<code>ls -l</code>将每个文件一行的形式输出，然后使用<code>nl</code>为每一行打上行号，然后使用<code>tail</code>倒序查看最后一行，这样便得出了本目录下文件的数量。</p><h2 id="重定向" tabindex="-1">重定向 <a class="header-anchor" href="#重定向" aria-label="Permalink to &quot;重定向&quot;">​</a></h2><h3 id="覆写" tabindex="-1">覆写 <a class="header-anchor" href="#覆写" aria-label="Permalink to &quot;覆写&quot;">​</a></h3><p>使用<code>&gt;</code> 符号将左边本来应该输出到终端的内容重定向到文件，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><h3 id="追加" tabindex="-1">追加 <a class="header-anchor" href="#追加" aria-label="Permalink to &quot;追加&quot;">​</a></h3><p>不过这会覆盖file.txt本来的内容，有些时候我们只是想追加输出，则可以使用<code>&gt;&gt;</code> 符号：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><h3 id="将输出和错误分别重定向" tabindex="-1">将输出和错误分别重定向 <a class="header-anchor" href="#将输出和错误分别重定向" aria-label="Permalink to &quot;将输出和错误分别重定向&quot;">​</a></h3><p>如果要将输出和错误定向到不同文件，使用 <code>&gt;</code> 和 <code>2&gt;</code> 符号。</p><p>例如，当前目录中，exist.txt存在，noexist.txt不存在，运行如下命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exist.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> noexist.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sure.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 2&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> error.txt</span></span></code></pre></div><p>这把 exist.txt 的文件拷贝到sure.txt。而由于noexist.md不存在，所以读取出错，会把错误信息“no such file...”等信息输出到error.txt。</p><h3 id="将输出和错误集中输出" tabindex="-1">将输出和错误集中输出 <a class="header-anchor" href="#将输出和错误集中输出" aria-label="Permalink to &quot;将输出和错误集中输出&quot;">​</a></h3><p>如下命令将输出和错误发送到同一文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exist.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> noexist.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  &gt;&amp;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> out.txt</span></span></code></pre></div><h3 id="丢弃输出" tabindex="-1">丢弃输出 <a class="header-anchor" href="#丢弃输出" aria-label="Permalink to &quot;丢弃输出&quot;">​</a></h3><p>如果要丢弃输出，使用 <code>&gt; /dev/null 2&gt;&amp;1</code> ，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  /dev/null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  2&gt;&amp;1</span></span></code></pre></div><h3 id="多个命令组重定向" tabindex="-1">多个命令组重定向 <a class="header-anchor" href="#多个命令组重定向" aria-label="Permalink to &quot;多个命令组重定向&quot;">​</a></h3><p>可以使用多个命令组合重定向，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pwd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><p>pwd和ls依然会输出到屏幕，只会把date的结果保存到1.md</p><p>可以使用括号，先在子shell中执行，然后重定向：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pwd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> file.txt</span></span></code></pre></div><h2 id="子命令-命令替换" tabindex="-1">子命令（命令替换） <a class="header-anchor" href="#子命令-命令替换" aria-label="Permalink to &quot;子命令（命令替换）&quot;">​</a></h2><p>shell命令行或脚本最有用的特性之一是可以从命令输出中提取信息并将其赋值给变量，称为子命令，也可以叫做命令替换。</p><p>有两种等价的方式使用子命令：</p><ul><li>使用反引号包裹</li><li>美元符加圆括号： <code>$(子命令)</code></li></ul><p>例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">today1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $today1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">today2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $today2</span></span></code></pre></div><p>命令替换会创建出子 shell来运行指定命令，这是由运行脚本的 shell所生成的一个独立的shell。因此，在子 shell 中运行的命令无法使用脚本中的变量。如果在命令行中使用./路径执行命令，就会创建子 shell，但如果不加路径，则不会创建子 shell。不过，内建的 shell 命令也不会创建子 shell。在命令行中运行脚本时要当心。</p><h2 id="命令行的tab补全" tabindex="-1">命令行的Tab补全 <a class="header-anchor" href="#命令行的tab补全" aria-label="Permalink to &quot;命令行的Tab补全&quot;">​</a></h2><p>使用命令行最多的按键或许就是Tab键了，所以单独使用一小节讲解。Tab键会根据你已经输入的少数几个字符自动猜测这个单词剩下的内容并进行补全。</p><p>可以通过bash shell补全的单词有：</p><ul><li>命令、别名或函数</li><li>变量，如果以美元符<code>$</code>开头，则会寻找当前环境下的变量名</li><li>用户名，如果以~开头，则shell尝试使用用户名补齐</li><li>主机名，如果以@开头，则会寻找主机名补全</li></ul><p>常见的情况有以下几种。</p><ul><li><p>命令补全：例如先输入ec两个字符，按Tab键，Bash会补全成echo。不过Linux命令一般都比较简短，一般都是直接写完整的命令。</p></li><li><p>文件名称补全：这是最实用的功能，一般来说文件名都比较长，如果每次都要输入完整的文件名不仅费时而且极容易出错。此时，只需要输入文件名的前一个或少数几个字符，再按下Tab键就可以自动补全文件名，如果匹配的文件名超过1个，那么终端就会输出匹配的文件名供我们再次输入以缩小范围。</p></li></ul><h2 id="通配符" tabindex="-1">通配符 <a class="header-anchor" href="#通配符" aria-label="Permalink to &quot;通配符&quot;">​</a></h2><ul><li><code>*</code> 匹配任意数量的字符</li><li><code>?</code> 字符占位，表示有且只有一个字符</li><li><code>[]</code>，匹配其中的任何一个单字符</li><li><code>{str1,str2}</code>，匹配以逗号分隔，匹配其中的任何一个单词</li></ul><p>通配符在命令行中用的非常多。</p><p>例如，输出以.txt的文件名：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span></span></code></pre></div><p>使用连字符指定范围，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file[1-3].txt</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">file1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file2.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file3.txt</span></span></code></pre></div><p>使用单个字符组成的逻辑或分组，例如如下命令表示匹配以file开头，紧接着以A或B或C结尾的文本文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file[ABC].txt</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fileA.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fileB.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fileC.txt</span></span></code></pre></div><p>有时候需要用到字符串组成的逻辑或分组，这时候就用到了花括号。例如如下命令表示筛选以txt或md结尾的文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.{txt,md}</span></span></code></pre></div><h2 id="命令的返回值" tabindex="-1">命令的返回值 <a class="header-anchor" href="#命令的返回值" aria-label="Permalink to &quot;命令的返回值&quot;">​</a></h2><p>既然两个命令有依赖性，而这个依赖性的判断地方就在于前一个命令执行的结果。在shell中，如果前一个命令成功执行或逻辑为真，则内置变量环境变量<code>$?</code>的值会设为0。如果执行有错误或逻辑为假，则<code>$?≠0</code>。例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  pwd</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 成功执行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  echo</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $?</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 输出0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 不存在的文件</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 执行错误</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  echo</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $?</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 输出2 不同的错误有不同的返回值</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -eq</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 不会输出内容，但是这个表达式逻辑值为假</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  echo</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $?</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  #  输出1 </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -gt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 不会输出内容，但是这个表达式逻辑值为真</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  echo</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $?</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 输出0</span></span></code></pre></div><h2 id="单行多命令" tabindex="-1">单行多命令 <a class="header-anchor" href="#单行多命令" aria-label="Permalink to &quot;单行多命令&quot;">​</a></h2><p>有些情况下，可以在一行中同时执行多个逻辑相关的命令，以提高效率。有三种情况：</p><ul><li><code>命令1 &amp;&amp; 命令2</code> ： 如果命令1成功执行或逻辑为真<code>（$?=0）</code>，则执行命令2。如果命令1执行发生错误或者逻辑为假<code>（$?≠0）</code>，则命令2不执行。</li><li><code>命令1 || 命令2</code> ： 如果命令1执行发生错误或者逻辑为假<code>（$?≠0）</code>，则命令2执行。如果命令1成功执行或者逻辑为真<code>（$?=0）</code>，则命令2不执行。</li><li><code>命令1 ; 命令2</code> ： 两个命令没有相关性，按顺序执行。其中一个命令的成功与否与逻辑真假都不影响其它的命令的执行。</li></ul><p>需要说明的是，这三种情况可以随意的组合搭配出自己的逻辑链条，例如比较使用的三元条件表达式：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">expression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">条件为真时执行</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 条件为假时执行</span></span></code></pre></div><p>具体的示例如下，这个例子的意思是：如果file.txt存在，就查看其内容；如果不存在，就先新建。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> touch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><p>再比如：如果目录不存在就新建目录，如果存在就读取文件列表：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir</span></span></code></pre></div><h2 id="shell子进程和脚本的执行方式" tabindex="-1">Shell子进程和脚本的执行方式 <a class="header-anchor" href="#shell子进程和脚本的执行方式" aria-label="Permalink to &quot;Shell子进程和脚本的执行方式&quot;">​</a></h2><ul><li>相对路径执行：例如./test，新开一个子进程执行。</li><li>source命令执行：直接在当前进程中执行，不开子进程。</li><li>bash或sh命令执行：与相对路径执行的方式等价，新开一个子进程执行</li></ul><p>由于bash命令会新开子进程，所以在设置环境变量时，无法真正的生效，当这个子进程退出时，相当于没有设置环境变量，所以如果要设置环境变量，只能是 <code>source $HOME/.bashrc</code>，而不能是 <code>bash $HOME/.bashrc</code>。</p><h1 id="文件权限" tabindex="-1">文件权限 <a class="header-anchor" href="#文件权限" aria-label="Permalink to &quot;文件权限&quot;">​</a></h1><h2 id="修改文件-目录所有者-所属组" tabindex="-1">修改文件/目录所有者/所属组 <a class="header-anchor" href="#修改文件-目录所有者-所属组" aria-label="Permalink to &quot;修改文件/目录所有者/所属组&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [-R]  所有者:所属组  文件或目录</span></span></code></pre></div><p>说明：-R表示递归修改。</p><h2 id="数字方法修改权限" tabindex="-1">数字方法修改权限 <a class="header-anchor" href="#数字方法修改权限" aria-label="Permalink to &quot;数字方法修改权限&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chmod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [-R]  xyz  文件或目录</span></span></code></pre></div><p>说明：xyz表示所有者、所属组、其他人对应的权限数字，是r、w、x对应的数字累加的结果，各具体操作权限的数字对照表是r:4、w:2、x:1，如果没有某种操作权，该数字为0。</p><h2 id="符号方法修改权限" tabindex="-1">符号方法修改权限 <a class="header-anchor" href="#符号方法修改权限" aria-label="Permalink to &quot;符号方法修改权限&quot;">​</a></h2><p>用等于的方式：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chmod</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   u=rwx,g=rx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  文件或目录</span></span></code></pre></div><p>用增减的方式：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chmod</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   g+w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 文件或目录</span></span></code></pre></div><p>说明：有四种符号表示身份，分别是u（所有者）、g（所属组）、o（其他人）、a（所有人）</p><h2 id="文件与目录的权限区别" tabindex="-1">文件与目录的权限区别 <a class="header-anchor" href="#文件与目录的权限区别" aria-label="Permalink to &quot;文件与目录的权限区别&quot;">​</a></h2><p>某种身份对文件有 r 权限，表示可以读取文件内容；对目录有r权限，表示可以列出（例如使用ls）目录下的文件列表和相关属性。</p><p>某种身份对文件有 w 权限，表示可以向该文件写入内容；对目录有w权限，表示可以向该目录增加、删除文件。</p><p>某种身份对文件有 x 权限，表示可以执行该文件（二进制方式、脚本方式）；对目录有x权限，表示可以以此目录为工作目录（例如cd到该目录）。</p><h1 id="系统管理常见命令" tabindex="-1">系统管理常见命令 <a class="header-anchor" href="#系统管理常见命令" aria-label="Permalink to &quot;系统管理常见命令&quot;">​</a></h1><h2 id="文件系统管理命令汇总" tabindex="-1">文件系统管理命令汇总 <a class="header-anchor" href="#文件系统管理命令汇总" aria-label="Permalink to &quot;文件系统管理命令汇总&quot;">​</a></h2><p>如下表格是常见的文件系统管理命令，涵盖目录的操作、文件内容的操作，会使用这些命令，那么基本就能使用命令行熟练操作文件系统了。</p><table tabindex="0"><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>cd</td><td>设置工作目录</td></tr><tr><td>pwd</td><td>显示当前工作目录</td></tr><tr><td>ls</td><td>列出目录下的文件列表</td></tr><tr><td>mkdir</td><td>建立一个空目录</td></tr><tr><td>rmdir</td><td>删除一个空目录</td></tr><tr><td>rm</td><td>删除文件</td></tr><tr><td>touch</td><td>新建文件</td></tr><tr><td>rename</td><td>文件重命名</td></tr><tr><td>cp</td><td>复制文件或目录</td></tr><tr><td>mv</td><td>移动文件或目录</td></tr><tr><td>cat</td><td>读取文件内容</td></tr><tr><td>tac</td><td>从最后一行往前读取文件内容</td></tr><tr><td>head</td><td>取出文件内容的前几行</td></tr><tr><td>tail</td><td>取出文件内容的后几行</td></tr><tr><td>nc</td><td>显示行号</td></tr><tr><td>wc</td><td>统计字数、行数</td></tr><tr><td>sed</td><td>查询、替换、增减文件内容</td></tr><tr><td>awk</td><td>以列为单位编辑结构化数据文件</td></tr><tr><td>grep</td><td>查询文件内容</td></tr></tbody></table><h2 id="linux目录树的组织原则" tabindex="-1">Linux目录树的组织原则 <a class="header-anchor" href="#linux目录树的组织原则" aria-label="Permalink to &quot;Linux目录树的组织原则&quot;">​</a></h2><p>Linux目录的组织是有一定的规律的，虽然不是强制的，但是用户在使用时也应该尽量遵循这种约定：</p><ul><li>/bin 常见的Linux用户命令，如ls、date、chmod</li><li>/boot 包含Linux内核、启动配置文件（GRUB）</li><li>/dev 包含设备访问的文件位置。包括终端设备tty、硬盘、鼠标、键盘等</li><li>/etc 管理配置文件</li><li>/home 用户的家目录，root是个例外，以/root为家目录</li><li>/media 自动挂载的设备的位置，例如一个名为myusb的USB设备被挂载到/media/myusb</li><li>/lib /bin和/sbin所需要的共享库</li><li>/mnt 许多常见设备的挂载点，例如硬盘分区、远程文件系统</li><li>/opt 附近应用程序软件</li><li>/sbin root用户使用的管理命令</li><li>/sys 包含管理某些内核行为的控制文件</li><li>/usr UNIX resource 系统资源的简称，注意，不是user。</li><li>/var 不同应用程序的数据目录，例如/var/ftp、/var/www。</li><li>~ 每个用户是家目录，存放用户自己的文件，自定义是配置文件等</li></ul><h2 id="ls命令" tabindex="-1">ls命令 <a class="header-anchor" href="#ls命令" aria-label="Permalink to &quot;ls命令&quot;">​</a></h2><p>ls是用的最多的命令，其作用是列出目录下的文件列表，或者列出某个文件信息。</p><p>ls的选项如下：</p><table tabindex="0"><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示使用文件包括隐藏文件，以及.和..</td></tr><tr><td>-A</td><td>类似-a，但不显示.和..</td></tr><tr><td>-l</td><td>使用长列表格式，每行显示一个文件的详细信息</td></tr><tr><td>-t</td><td>按照修改时间排序</td></tr><tr><td>-d</td><td>只列出目录本身，而不是目录下的文件</td></tr><tr><td>-r</td><td>逆序排列</td></tr><tr><td>-R</td><td>递归显示子目录</td></tr><tr><td>-1</td><td>每行只显示一个文件名</td></tr><tr><td>-S</td><td>按照文件大小排序</td></tr></tbody></table><h2 id="切换当前目录-cd命令" tabindex="-1">切换当前目录：cd命令 <a class="header-anchor" href="#切换当前目录-cd命令" aria-label="Permalink to &quot;切换当前目录：cd命令&quot;">​</a></h2><p>cd命令的作用是切换当前目录。</p><p>有一些特定目录的简写，包括：</p><ul><li><code>~</code>或者不写任何内容：回到当前用户的家目录，即$HOME。</li><li><code>.</code> ：一个点，当前目录 -<code>..</code> 两个点，当前目录的上一级目录</li><li><code>$PWD</code> ：当前目录</li><li><code>$OLDPWD</code>： 当前目录之前的目录</li></ul><h2 id="复制文件" tabindex="-1">复制文件 <a class="header-anchor" href="#复制文件" aria-label="Permalink to &quot;复制文件&quot;">​</a></h2><p>复制一个文件到目标目录下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   dir</span></span></code></pre></div><p>复制的同时重命名：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir/2.txt</span></span></code></pre></div><p>复制多个文件到目标目录下，这种情况就不能重命名了：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir</span></span></code></pre></div><h2 id="复制目录" tabindex="-1">复制目录 <a class="header-anchor" href="#复制目录" aria-label="Permalink to &quot;复制目录&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  dir1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir2</span></span></code></pre></div><p>此时，dir1会放到dir2下，形成dir2/dir1路径。</p><p>-r表示递归，在复制目录时，必须带上-r。</p><h2 id="mv命令" tabindex="-1">mv命令 <a class="header-anchor" href="#mv命令" aria-label="Permalink to &quot;mv命令&quot;">​</a></h2><p>mv命令的作用是移动文件，其主要选项如下：</p><table tabindex="0"><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>即force，如果目标文件已存在，则不会询问直接覆盖</td></tr><tr><td>-i</td><td>如果目标文件已存在，会询问</td></tr><tr><td>-u</td><td>如果目标文件已经存在，只有源文件较新才会覆盖</td></tr></tbody></table><h2 id="rm命令" tabindex="-1">rm命令 <a class="header-anchor" href="#rm命令" aria-label="Permalink to &quot;rm命令&quot;">​</a></h2><p>rm命令的作用是删除文件或目录，其主要选项如下：</p><table tabindex="0"><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>即force，忽略不存在的文件，不会出现警告信息</td></tr><tr><td>-I</td><td>交互模式，在删除前会询问是否确认删除</td></tr><tr><td>-r</td><td>递归删除，常用于目录的删除，<em>这个选项非常危险</em>。</td></tr></tbody></table><p>例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 删除dir目录本身及其子项</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 删除dir目录下的东西，此时dir是个空目录</span></span></code></pre></div><h2 id="获取文件名和目录名-basename和dirname命令" tabindex="-1">获取文件名和目录名：basename和dirname命令 <a class="header-anchor" href="#获取文件名和目录名-basename和dirname命令" aria-label="Permalink to &quot;获取文件名和目录名：basename和dirname命令&quot;">​</a></h2><p>有时候需要根据路径获取文件名和目录名，可以使用basename命令和dirname命令，这两个命令分别用于获取文件名和目录名，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">basename</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  /usr/bin/sed</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 取得路径的最后一个名称</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">输出：sed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dirname</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/bin/sed</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 去掉路径最后一个名称</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">输出：/usr/bin</span></span></code></pre></div><h2 id="查看文件内容" tabindex="-1">查看文件内容 <a class="header-anchor" href="#查看文件内容" aria-label="Permalink to &quot;查看文件内容&quot;">​</a></h2><p>查看文件内容的方式有很多，可以根据具体的情况选择，查看文件内容的命令汇总如下：</p><table tabindex="0"><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>cat</td><td>最常用，正常显示文件内容</td></tr><tr><td>tac</td><td>从最后一行开始显示</td></tr><tr><td>nl</td><td>显示的时候，输出行号</td></tr><tr><td>more</td><td>一页一页的显示</td></tr><tr><td>less</td><td>于more类似，但可以往前翻页</td></tr><tr><td>head</td><td>只看前面几行</td></tr><tr><td>tail</td><td>只看后面几行</td></tr><tr><td>od</td><td>以二进制的方式显示文件内容</td></tr></tbody></table><h2 id="cat命令" tabindex="-1">cat命令 <a class="header-anchor" href="#cat命令" aria-label="Permalink to &quot;cat命令&quot;">​</a></h2><p>查看文件内容最常用的就是cat命令，其选项如下：</p><table tabindex="0"><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>对非空白行显示行号，空白行则不显示</td></tr><tr><td>-E</td><td>将结尾的换行符<code>$</code>显示出来</td></tr><tr><td>-n</td><td>显示行号，包括空白行</td></tr><tr><td>-v</td><td>列出不可见的特殊字符</td></tr></tbody></table><h2 id="head和tail命令" tabindex="-1">head和tail命令 <a class="header-anchor" href="#head和tail命令" aria-label="Permalink to &quot;head和tail命令&quot;">​</a></h2><p>与cat读取文件的全部内容不同，head和tail命令用于读取文件的前几行或最后几行，在部分情况下非常有用。</p><p>head命令的作用是读取文件内容的前多少行。使用head命令一般只使用-n选项，该选项指定要读取前面多少行。</p><p>例如，如果想输出前25行，下面三个命令是等价的：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">head</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n25</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   1.md</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">head</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">       25</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   1.md</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">head</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -25</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   1.md</span></span></code></pre></div><p>-n 后面也可以跟负数，例如下面的命令输出除了最后5行以外的全部内容：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">head</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> input.txt</span></span></code></pre></div><p>与head相反，tail命令用于读取文件内容的后多少行。下面两个命令均读取文件最后10行。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tail</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   1.md</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tail</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    1.md</span></span></code></pre></div><p>如果数字带加号，表示从第几行开始输出，例如从第一行开始输出，即全部输出：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tail</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   +1</span></span></code></pre></div><p>从第25行开始输出：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tail</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   +25</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    1.md</span></span></code></pre></div><h2 id="比较文件内容-cmp命令" tabindex="-1">比较文件内容： cmp命令 <a class="header-anchor" href="#比较文件内容-cmp命令" aria-label="Permalink to &quot;比较文件内容： cmp命令&quot;">​</a></h2><p>Linux cmp 命令用于比较两个文件是否有差异。当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为&quot;-&quot;，则cmp指令会从标准输入设备读取数据。</p><p>cmp命令的语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [-clsv][-i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字符数目</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][--help][第一个文件][第二个文件]</span></span></code></pre></div><p>cmp命令的选项如下：</p><table tabindex="0"><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-c或--print-chars</td><td>除了标明差异处的十进制字码之外，一并显示该字符所对应字符。</td></tr><tr><td><code>-i&lt;字符数目&gt;</code>或<code>--ignore-initial=&lt;字符数目&gt;</code></td><td>指定一个数目。</td></tr><tr><td>-l或--verbose</td><td>标示出所有不一样的地方。</td></tr><tr><td>-s或--quiet或--silent</td><td>不显示错误信息。</td></tr><tr><td>-v或--version</td><td>显示版本信息。</td></tr><tr><td>--help</td><td>在线帮助。</td></tr></tbody></table><p>如下命令比较两个文本文件的差异：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cmp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   file2.txt</span></span></code></pre></div><h2 id="split命令" tabindex="-1">split命令 <a class="header-anchor" href="#split命令" aria-label="Permalink to &quot;split命令&quot;">​</a></h2><p>Linux split命令用于将一个文件分割成数个。该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</p><p>split命令语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [--help][--version][-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">行数</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][-b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字节</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][-C </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字节</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][-l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">行数</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][要切割的文件][输出文件名]</span></span></code></pre></div><p>split命令的选项如下：</p><table tabindex="0"><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-行数</td><td>指定每多少行切成一个小文件</td></tr><tr><td>-b 字节数</td><td>指定每多少字节切成一个小文件</td></tr><tr><td>-C 字节数</td><td>与参数&quot;-b&quot;相似，但是在切 割时将尽量维持每行的完整性</td></tr><tr><td>输出文件名</td><td>设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号</td></tr></tbody></table><p>将文件file.txt每6行切割成一个文件，可使用如下命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -6</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><h2 id="cut" tabindex="-1">cut <a class="header-anchor" href="#cut" aria-label="Permalink to &quot;cut&quot;">​</a></h2><p>cut命令的作用是以指定的分隔符分割文件内容，常用于结构化的文本内容，类似于Excel的数据分列。</p><p>cut命令的主要选项如下：</p><ul><li>-d : 指定分隔符</li><li>-f n ： 取出第n列</li><li>-f n-m ： 取出第n到第m列</li></ul><p>例如有如下文本文件1.md：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">10.0.0.20</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">192.168.0.4</span></span></code></pre></div><p>可以看到每一行都以点号分隔，可以使用如下命令取出第一列：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cut</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;.&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.md</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">输出：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">10</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">192</span></span></code></pre></div><p>使用如下命令取出第2-3列：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  cut</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;.&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  2-3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.md</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 输出：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">168.0</span></span></code></pre></div><h2 id="排序-sort命令" tabindex="-1">排序：sort命令 <a class="header-anchor" href="#排序-sort命令" aria-label="Permalink to &quot;排序：sort命令&quot;">​</a></h2><p>可以使用sort命令对每行进行排序，默认每从第一个字符开始，比较ASCII值进行排序。</p><p>sort命令选项如下：</p><ul><li>-r ： 逆序</li><li>-f ： 不区分大小写</li><li>-n ： 以数字为依据</li></ul><p>对于文本的排序，例如如下文本文件1.md：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aa</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">abd</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">abc</span></span></code></pre></div><p>运行<code>sort 1.md</code>后输出如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A</span></span>
<span class="line"><span>aa</span></span>
<span class="line"><span>abc</span></span>
<span class="line"><span>abd</span></span></code></pre></div><p>对于数值的排序，假设一个文件2.md如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>2</span></span>
<span class="line"><span>3</span></span>
<span class="line"><span>10</span></span>
<span class="line"><span>111</span></span></code></pre></div><p>必须加上-n告诉以数值为依据，否则会当成字符串以ASCII逐字符比较。如下示例：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sort</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  2.md</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">输出：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">10</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">111</span></span></code></pre></div><p>删除重复行前先进行排序，然后使用管道传递给uniq命令即可。</p><p>如下文本文件3.md：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A</span></span>
<span class="line"><span>B</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>A</span></span>
<span class="line"><span>B</span></span></code></pre></div><p>运行如下命令删除重复行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sort</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 3.md</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uniq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">输出：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">B</span></span></code></pre></div><h2 id="grep命令" tabindex="-1">grep命令 <a class="header-anchor" href="#grep命令" aria-label="Permalink to &quot;grep命令&quot;">​</a></h2><p>可以在一个或多个文件中查找字符串</p><p>按行查找的。</p><p>在文本文件1.txt中查找word：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> word</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span></span></code></pre></div><p>在多个文件中，在输出前加上文件名及冒号，然后是包含搜索内容的文本。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> word</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        1.txt中包含word的行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2.txt:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        2.txt中包含word的行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">3.txt:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        3.txt中包含word的行</span></span></code></pre></div><p>只显示包含内容的文件名：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -l</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   text</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span></span></code></pre></div><p>不区分大小写，如下示例搜索包含word、Word、WORD的行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  word</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span></span></code></pre></div><p>grep命令也支持管道，如下示例筛选出以.txt为后缀的文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span></span></code></pre></div><h1 id="系统管理常见命令-1" tabindex="-1">系统管理常见命令 <a class="header-anchor" href="#系统管理常见命令-1" aria-label="Permalink to &quot;系统管理常见命令&quot;">​</a></h1><h2 id="which命令" tabindex="-1">which命令 <a class="header-anchor" href="#which命令" aria-label="Permalink to &quot;which命令&quot;">​</a></h2><p>which命令用于查找命令的路径，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">which</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/usr/bin/ls</span></span></code></pre></div><h2 id="type命令" tabindex="-1">type命令 <a class="header-anchor" href="#type命令" aria-label="Permalink to &quot;type命令&quot;">​</a></h2><p>type命令用于检查命令是否是shell自带命令，也就是说安装了这个shell就可以执行这个命令。与之相对的，外部命令是指系统安装的，与Shell无关的命令，一般情况下，一般用户执行的命令存放于/usr/bin/里面的，管理员命令存放于/usr/sbin里面。</p><p>如果输出一个路径则表示是系统命令，如下示例检测是Shell自带还是系统命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cd</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># cd is shell builtin  # cd是shell自带</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> awk</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># awk is /usr/bin/awk  # 系统命令</span></span></code></pre></div><h2 id="输出到终端——echo命令" tabindex="-1">输出到终端——echo命令 <a class="header-anchor" href="#输出到终端——echo命令" aria-label="Permalink to &quot;输出到终端——echo命令&quot;">​</a></h2><p>echo是非常常见的命令，它的作用是输出内容到终端，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  hello</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  bash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># hello bash</span></span></code></pre></div><p>echo会解析所有的命令行参数，而且会忽略空白符：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$a=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bash&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$echo   hello        $data</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># hello bash</span></span></code></pre></div><p>要想保留空白字符，需要将其放入单引号或双引号中：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &#39;   hello     bash   &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;   hello     bash   &quot;</span></span></code></pre></div><p>单引号和双引号的区别是对变量的解析与否，双引号会读取以$开头的单词并尝试解析变量值，再插入到字符串中，这种方式叫做“内插”。而单引号则不理会进行变量解析。</p><p>如果不需要解析变量，则使用单引号即可：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;hello $bash&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $bash</span></span></code></pre></div><h2 id="写内容到文件的快速方式" tabindex="-1">写内容到文件的快速方式 <a class="header-anchor" href="#写内容到文件的快速方式" aria-label="Permalink to &quot;写内容到文件的快速方式&quot;">​</a></h2><p>echo命令经常用来快速将少量文本内容写入到文本文件，使用重定向符号<code>&gt;</code>或<code>&gt;&gt;</code>将内容保存到文件而不输出到终端。这两个符号分别可以覆盖内容和追加内容到文件。例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bash</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    1.md</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bash</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  &gt;&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.md</span></span></code></pre></div><h2 id="read命令" tabindex="-1">read命令 <a class="header-anchor" href="#read命令" aria-label="Permalink to &quot;read命令&quot;">​</a></h2><p>Linux read命令用于从标准输入读取值。</p><p>read命令选项如下：</p><table tabindex="0"><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>后面跟提示信息，即在输入前打印提示信息。</td></tr><tr><td>-n</td><td>后跟一个数字，定义输入文本的长度，很实用。</td></tr><tr><td>-a</td><td>后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。</td></tr><tr><td>-s</td><td>安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</td></tr></tbody></table><p>-p 参数很常用，允许在 read 命令行中直接指定一个提示信息。例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">read</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;your name:&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  name</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;welcome，</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span></code></pre></div><p>上面的示例运行后，在终端会看到提示字符“your name：”，此时直接输入后按回车，即可将输入的值赋予给变量name。</p><h2 id="将输入存入数组" tabindex="-1">将输入存入数组 <a class="header-anchor" href="#将输入存入数组" aria-label="Permalink to &quot;将输入存入数组&quot;">​</a></h2><p>如果需要用户依次输入多个单词，彼此以空格隔开，那么可以使用-a将输入存入数组。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">read</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;arr: &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> arr</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;arr的长度: ${</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]}&quot;</span></span></code></pre></div><h2 id="查看系统与内核相关信息" tabindex="-1">查看系统与内核相关信息 <a class="header-anchor" href="#查看系统与内核相关信息" aria-label="Permalink to &quot;查看系统与内核相关信息&quot;">​</a></h2><p>要查看系统与内核相关信息，使用uname命令。-a选项表示输出所有信息。-r选项输出内核版本。</p><h2 id="远程连接-ssh命令" tabindex="-1">远程连接：ssh命令 <a class="header-anchor" href="#远程连接-ssh命令" aria-label="Permalink to &quot;远程连接：ssh命令&quot;">​</a></h2><p>ssh命令用于登录远程主机</p><p>要登录远程主机，使用如下命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  user@ip</span></span></code></pre></div><p>此时会提示你输入密码。</p><p>输入<code>exit</code>退出登录。</p><p>在文件 ~/.ssh/known_hosts 中可查询该服务器公钥。</p><h2 id="网络请求-curl命令" tabindex="-1">网络请求：curl命令 <a class="header-anchor" href="#网络请求-curl命令" aria-label="Permalink to &quot;网络请求：curl命令&quot;">​</a></h2><p>curl命令的作用是执行网络请求，取回响应结果，主要是http请求。</p><p>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。</p><p>cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。</p><p>curl还支持SSL认证、HTTP POST、HTTP PUT、FTP上传,</p><p>例如如下一行命令访问百度，可用于检测是否联网：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://www.baidu.com</span></span></code></pre></div><p>这会输出百度首页的HTML代码。</p><p>如下命令将返回的内容保存到本地：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> URL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.html</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  https://www.baidu.com</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  2.html</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   https://www.baidu.com</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -O</span></span></code></pre></div><p>-o选项在本地重命名，-O选项使用服务器上的名称。</p><p>如下示例保存图片：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  图片链接</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> image.png</span></span></code></pre></div><p>如下示例保存cookie：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cookie.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  http://www.linux.com</span></span></code></pre></div><p>如下示例发送cookie：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;a=1&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;b=2&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  https://www.baidu.com</span></span></code></pre></div><p>如下示例保存header：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> header.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://www.baidu.com</span></span></code></pre></div><p>如下示例模拟Chrome访问：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -A</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://google.com</span></span></code></pre></div><h2 id="find" tabindex="-1">find <a class="header-anchor" href="#find" aria-label="Permalink to &quot;find&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>find  要查找的目录  查找选项</span></span></code></pre></div><p>查找选项包括：</p><ul><li>-name 根据文件名，支持通配符</li><li>-type 根据类型，fS文件、d目录</li><li>-size 根据大小</li><li>-user 根据所有者</li><li>-mmin -10 过去10分钟修改的文件</li></ul><p>还可以对找到的文件执行命令，语法：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 要查找的目录</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  查找选项</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 命令</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {}</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \;</span></span></code></pre></div><ul><li>花括号表示查找出来的文件名</li><li>在命令末尾，需要家反斜杠和分号</li></ul><p>例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $HOME </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-name</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;已经找到{}&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  \;</span></span></code></pre></div><h2 id="locate" tabindex="-1">locate <a class="header-anchor" href="#locate" aria-label="Permalink to &quot;locate&quot;">​</a></h2><p>与find从文件系统查找文件不同，locate命令从一个包含系统文件名的数据库中查找，因此查找效果更快。</p><p>如果运行完update后又新建了文件，那么locate是查找不到的，此时必须再次运行update命令。</p><p>更新数据库：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updatedb</span></span></code></pre></div><p>查找文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">locate.bashrc</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/etc/skel/.bashrc</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/home/student/.bashrc</span></span></code></pre></div><h2 id="进程管理" tabindex="-1">进程管理 <a class="header-anchor" href="#进程管理" aria-label="Permalink to &quot;进程管理&quot;">​</a></h2><p>进程管理命令汇总：</p><ul><li>ps aux ： 查看系统所有进程</li><li>kill -9 进程ID： 终止进程</li><li>命令 &amp; ： 后台执行</li><li>jobs： 查看后台</li><li>fg 编号： 将任务拿到前台</li><li>bg 编号： 使后台任务由Stopped变为Running</li></ul><p>使用<code>ps aux</code>查看系统所有进程。不过这会输出很多内容，通常使用<code>grep</code>管道过滤需要查看的进程。</p><p>要终止进程，运行 <code>kill -9 进程ID </code>。</p><p>在命令行后面加上<code>&amp;</code>，可以将命令放到后台执行。此时会输出 <code>[任务编号] 进程编号</code>。</p><p>如果已经在执行某个操作，例如vim正在编辑文件，或者find正在查找文件，此时使用<code>Ctrl-Z</code>可以暂时将其放到后台。不过，使用<code>Ctrl-Z</code>会使任务变为暂停Stopped状态。</p><p>使用<code>jobs</code>查看后台。会在输出到任务编号后面看到<code>+</code>、<code>-</code>。这表示最近放到后台和最近第二个放到后台的任务。</p><p>使用<code>fg 任务编号</code> 将某个任务拿到前台。如果使用<code>fg</code>会将最近放到后台的任务拿到前台，就是任务列表中带加号的那个任务。</p><p>要使后台的某个任务由Stopped变为Running，使用<code>bg 任务编号</code>命令。</p><h2 id="更改apt镜像源" tabindex="-1">更改apt镜像源 <a class="header-anchor" href="#更改apt镜像源" aria-label="Permalink to &quot;更改apt镜像源&quot;">​</a></h2><p>Ubuntu的/etc/source/sourcs.list 文件格式如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>deb或deb-src  仓库地址 发行版代号-软件类别 自由软件 非自由软件 ......</span></span></code></pre></div><p>我们说镜像加速，实际上就是修改仓库地址即可，其它结构是完全同步过来的。比如默认仓库地址是<code>http://archive.ubuntu.com/ubuntu/ </code>，把这个换成 <code>https://mirrors.aliyun.com/ubuntu/ </code>即可。</p><p>使用如下命令更换镜像源：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo  sed  -i  s*http://archive.ubuntu.com/ubuntu/*https://mirrors.aliyun.com/ubuntu/*g  /etc/apt/sources.list</span></span></code></pre></div><p>然后，运行如下命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cat /etc/apt/sources.list  # 检查文件内容</span></span>
<span class="line"><span>sudo apt  update    # 更新软件列表</span></span>
<span class="line"><span>sudo  apt  upgrade  # 更新软件</span></span></code></pre></div><h2 id="使用apt管理软件包" tabindex="-1">使用apt管理软件包 <a class="header-anchor" href="#使用apt管理软件包" aria-label="Permalink to &quot;使用apt管理软件包&quot;">​</a></h2><p>apt是Ubuntu系统默认的软件包管理器，其主要操作如下表：</p><ul><li>apt search ^python$ ： 搜索软件包</li><li>apt update： 更新包列表</li><li>apt install python ： 安装包</li></ul><p>这里在搜索软件包时，使用了 <code>^</code> 和 <code>$</code> 正则符号，分别表示匹配单词首部和尾部，目的是严格限定软件的名称，避免搜索结果过多。</p><h1 id="bash-shell" tabindex="-1">Bash Shell <a class="header-anchor" href="#bash-shell" aria-label="Permalink to &quot;Bash Shell&quot;">​</a></h1><h2 id="bash的配置文件" tabindex="-1">Bash的配置文件 <a class="header-anchor" href="#bash的配置文件" aria-label="Permalink to &quot;Bash的配置文件&quot;">​</a></h2><p>登录shell之后会从5个不同的文件中读取命令：</p><ul><li>etc/profile ： 主启动文件，每个用户登录后都会读取 其余的四个文件都用于同一个目的：提供用户专属的启动文件来为该用户使用shell时提前设置，例如设置环境变量，预先执行一些命令。另外要注意，shell会按顺序执行第一个被找打的文件，余下的则被忽略。</li><li>$HOME/.bash_profile</li><li>$HOME/.bashrc</li><li>$HOME/.bash_login</li><li>$HOME/.profile</li></ul><h2 id="bash-shell的快捷键" tabindex="-1">Bash Shell的快捷键 <a class="header-anchor" href="#bash-shell的快捷键" aria-label="Permalink to &quot;Bash Shell的快捷键&quot;">​</a></h2><p>移动光标：</p><ul><li>ctrl+a:光标移到行首</li><li>ctrl+e:光标移到行尾</li><li>ctrl+b:光标左移一个字母</li><li>ctrl+f: 光标右移一个字母</li><li>esc+f: 往右跳一个单词</li><li>esc+b: 往左跳一个 单 词</li></ul><p>删除：</p><ul><li>ctrl+h:删除光标前一个字符，同 backspace 键相同</li><li>ctrl+w: 删除光标前的一个单词</li><li>esc+d: 删除光标后的一个词</li><li>ctrl+k:清除光标后至行尾的内容。</li><li>ctrl+u: 清除光标前至行首间的所有内容。</li><li>ctrl+d: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符</li></ul><p>修改：</p><ul><li>ctrl+t: 交换光标位置前的两个字符</li><li>esc+t: 交换光标位置前的两个单词</li></ul><p>其他：</p><ul><li>ctrl+y: 粘贴或者恢复上次的删除</li><li>ctrl+l:清屏，相当于clear。</li><li>ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history</li><li>ctrl+d:退出当前 Shell</li><li>ctrl+c:杀死当前进程</li><li>ctrl+z : 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z ，到后台，然后fg,重新恢复</li></ul><h1 id="vim" tabindex="-1">Vim <a class="header-anchor" href="#vim" aria-label="Permalink to &quot;Vim&quot;">​</a></h1><h2 id="打开文件" tabindex="-1">打开文件 <a class="header-anchor" href="#打开文件" aria-label="Permalink to &quot;打开文件&quot;">​</a></h2><p>使用<code>vim &lt;file&gt; </code>即可打开文件，如果该文件不存在就会新建。</p><p>如果仅仅是删除、移动，而不增加内容，那么只在命令模式就可以完成操作。</p><h2 id="三种模式的切换" tabindex="-1">三种模式的切换 <a class="header-anchor" href="#三种模式的切换" aria-label="Permalink to &quot;三种模式的切换&quot;">​</a></h2><p>vim默认打开的模式为命令模式。</p><p>按 i 进入编辑模式，按 v/V 进入字符/整行选择模式，按 Esc 重新回到命令模式。</p><h2 id="命令模式下的操作" tabindex="-1">命令模式下的操作 <a class="header-anchor" href="#命令模式下的操作" aria-label="Permalink to &quot;命令模式下的操作&quot;">​</a></h2><p>单行删除、复制、粘贴：</p><table tabindex="0"><thead><tr><th>若要</th><th>依次按下</th></tr></thead><tbody><tr><td>整行删除</td><td>dd</td></tr><tr><td>整行复制</td><td>yy</td></tr><tr><td>粘贴到光标所在行的下一行/上一行</td><td>p/P</td></tr></tbody></table><p>多行删除、复制、粘贴：</p><table tabindex="0"><thead><tr><th>若要</th><th>依次按下</th></tr></thead><tbody><tr><td>删除光标所在到最后一行/第一行</td><td>dG/d1G</td></tr><tr><td>复制光标所在行到最后一行/第一行</td><td>yG/y1G</td></tr></tbody></table><p>行内删除、复制、粘贴：</p><table tabindex="0"><thead><tr><th>若要</th><th>依次按下</th></tr></thead><tbody><tr><td>删除光标所在到该行的行尾/行首</td><td>d$/d0</td></tr><tr><td>复制光标所在到该行的行尾/行首</td><td>y0/y$</td></tr></tbody></table><p>查找、替换：</p><table tabindex="0"><thead><tr><th>若要</th><th>在底部输入命令</th></tr></thead><tbody><tr><td>从光标所在处正向查找</td><td><code>:/&lt;text&gt; </code></td></tr><tr><td>从光标所在处逆向查找</td><td><code>:?&lt;text&gt;</code></td></tr><tr><td>全部替换不确认：</td><td><code> :1,$s/&lt;oldText&gt;/&lt;newText&gt;/g</code></td></tr><tr><td>逐一确认是否替换（加c）</td><td><code>:1,$s/&lt;oldText&gt;/&lt;newText&gt;/gc</code></td></tr></tbody></table><p>说明：上面两种查找中，按 <code>n</code> 键查找下一个，按 <code>N</code> 键查找上一个。</p><p>保存：</p><table tabindex="0"><thead><tr><th>若要</th><th>在底部输入命令</th></tr></thead><tbody><tr><td>保存</td><td>:w</td></tr><tr><td>强制退出而不保存</td><td>:q!</td></tr><tr><td>保存后退出（最常用）</td><td>:wq</td></tr><tr><td>另存为新文件</td><td><code> :w &lt;filename&gt;</code></td></tr><tr><td>读入另一个文件内容追加到光标所在行的下一行</td><td><code> :r &lt;filename&gt; </code></td></tr></tbody></table><h2 id="选择模式下的操作" tabindex="-1">选择模式下的操作 <a class="header-anchor" href="#选择模式下的操作" aria-label="Permalink to &quot;选择模式下的操作&quot;">​</a></h2><table tabindex="0"><thead><tr><th>若要</th><th>按下</th></tr></thead><tbody><tr><td>进入上下左右字符选择模式</td><td>v</td></tr><tr><td>进入行选择模式</td><td>V</td></tr><tr><td>进入列选择模式</td><td>Ctrl+V</td></tr><tr><td>复制选择的内容</td><td>y</td></tr><tr><td>将选择的内容粘贴到游标之后</td><td>p</td></tr><tr><td>将选择的内容删除</td><td>d</td></tr></tbody></table><h2 id="插入内容" tabindex="-1">插入内容 <a class="header-anchor" href="#插入内容" aria-label="Permalink to &quot;插入内容&quot;">​</a></h2><p>在命令模式下按i进入编辑状态，此时编辑器下部显示<code>---insert---</code>。</p><p>编辑状态就和一般的编辑器一样，按键盘上的上下左右键可移动光标，按<code>Ctrl+C</code>可复制、按<code>Ctrl+V</code>可粘贴。</p><h2 id="回到命令模式" tabindex="-1">回到命令模式 <a class="header-anchor" href="#回到命令模式" aria-label="Permalink to &quot;回到命令模式&quot;">​</a></h2><p>按<code>Esc</code>键回到命令模式。</p><h2 id="常用按键汇总" tabindex="-1">常用按键汇总 <a class="header-anchor" href="#常用按键汇总" aria-label="Permalink to &quot;常用按键汇总&quot;">​</a></h2><table tabindex="0"><thead><tr><th>模式</th><th>按键</th><th>含义</th></tr></thead><tbody><tr><td>命令模式</td><td>:w</td><td>保存更改，加 ! 强制保存</td></tr><tr><td>命令模式</td><td>:q</td><td>退出，加 ! 强制退出</td></tr><tr><td>命令模式</td><td>:wq</td><td>保存并退出，常用</td></tr><tr><td>命令模式</td><td>u</td><td>撤销</td></tr><tr><td>命令模式</td><td>dd</td><td>删除整行</td></tr><tr><td>命令模式</td><td>yy</td><td>复制整行</td></tr><tr><td>命令模式</td><td>p</td><td>粘贴到下一行</td></tr><tr><td>命令模式</td><td>v</td><td>进入单字符选择-- VISUAL --</td></tr><tr><td>命令模式</td><td>V</td><td>进入整行字符选择-- VISUAL --</td></tr><tr><td>-- VISUAL --</td><td>d</td><td>删除已选择的字符</td></tr><tr><td>-- VISUAL --</td><td>y</td><td>复制已选择的字符</td></tr><tr><td>-- VISUAL --</td><td>p</td><td>粘贴到光标后面</td></tr><tr><td>命令模式</td><td>:1,$s/旧文本/新文本/g</td><td>查找替换，/ 可以换成其它字符</td></tr><tr><td>命令模式</td><td>i</td><td>进入 -- INSERT --</td></tr></tbody></table><h1 id="virtualbox" tabindex="-1">VirtualBox <a class="header-anchor" href="#virtualbox" aria-label="Permalink to &quot;VirtualBox&quot;">​</a></h1><ol><li>下载Virtual Box最新版本，安装。如果报错内容是缺少VC++2019，则去<a href="https://learn.microsoft.com/ZH-cn/cpp/windows/latest-supported-vc-redist?view=msvc-170" target="_blank" rel="noreferrer">https://learn.microsoft.com/ZH-cn/cpp/windows/latest-supported-vc-redist?view=msvc-170</a>下载支持文件。</li></ol><p><img src="https://pics5.baidu.com/feed/91529822720e0cf39f8620b98bd2ee14bf09aa9a.png@f_auto?token=af0b3c59d267ec1cf710db8a2579d98c" alt="VC++2019"></p><ol start="2"><li>启动VirtualBox，新建</li></ol><p><img src="https://img-blog.csdnimg.cn/89a5eb1afb894bd48806e011767ec2ce.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ef67b02d6a8f462185c4e45fe2e6c8af.png" alt=""></p><p>内存大小、硬盘容量基本选择默认即可。</p><ol start="3"><li>新建好后，点击设置，修改启动顺序为：光驱第一、硬盘第二。因为我们是通过光驱来安装系统的，如果选错顺序将会导致后续的安装失败。</li></ol><p><img src="https://img-blog.csdnimg.cn/116ff2b533f946cb8c857b2b15c7c113.png" alt=""></p><ol start="4"><li>继续点击设置里面的存储，点击“没有盘片”，选择下载好的系统镜像。点击确定，启动虚拟机即可。 <img src="https://img-blog.csdnimg.cn/8431cd167ced46c98c46b002a860333b.png" alt=""></li></ol><h1 id="脚本" tabindex="-1">脚本 <a class="header-anchor" href="#脚本" aria-label="Permalink to &quot;脚本&quot;">​</a></h1><h2 id="声明变量" tabindex="-1">声明变量 <a class="header-anchor" href="#声明变量" aria-label="Permalink to &quot;声明变量&quot;">​</a></h2><p>变量在Linux脚本中非常常见。</p><p>声明变量很简单，只需要使用等号将变量名和变量值连接起来即可：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>a=1</span></span>
<span class="line"><span>str=hello</span></span>
<span class="line"><span>echo $a</span></span>
<span class="line"><span>echo $str</span></span></code></pre></div><p>如果值有空格，则需要使用引号：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">str</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =&quot;hello bash&quot;</span></span></code></pre></div><p>要特别注意，等号两边不能有空格，下面的命令是错的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>a  =  1</span></span>
<span class="line"><span>bash: a: command not found</span></span></code></pre></div><p>bash会把a当做命令、= 和1当做参数去执行。</p><h2 id="打印变量" tabindex="-1">打印变量 <a class="header-anchor" href="#打印变量" aria-label="Permalink to &quot;打印变量&quot;">​</a></h2><p>使用echo加上美元符号$和花括号打印变量：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>echo $PATH</span></span>
<span class="line"><span>echo ${PATH}</span></span></code></pre></div><p>如果变量名称不存在空格和特殊字符，上面两种方式都可以。如果存在空格或特殊字符，变量名称就要用花括号括起来。</p><h2 id="字符串转义" tabindex="-1">字符串转义 <a class="header-anchor" href="#字符串转义" aria-label="Permalink to &quot;字符串转义&quot;">​</a></h2><p>有些时候我们恰好需要用到特殊字符本来的含义，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;coffee is </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$five</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span></code></pre></div><p>这里会找到名为five的变量解析出来，但我们的本意是只想显示“咖啡是5美元”，所以使用转义：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;coffee is </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">five&quot;</span></span></code></pre></div><p>这样就输出了“coffee is $five”。</p><h2 id="变量内容的编辑" tabindex="-1">变量内容的编辑 <a class="header-anchor" href="#变量内容的编辑" aria-label="Permalink to &quot;变量内容的编辑&quot;">​</a></h2><ul><li><code>${变量#关键词}</code> 若变量内容从头开始的数据符合关键词，则将符合的最短数据删除</li><li><code>${变量##关键词}</code> 若变量内容从头开始的数据符合关键词，则将符合的最长数据删除</li><li><code>{变量%关键词}</code> 若变量内容从尾向前的数据符合关键词，则将符合的最短数据删除</li><li><code>{变量%%关键词}</code> 若变量内容从尾向前的数据符合关键词，则将符合的最长数据删除</li><li><code>{变量/旧字符串/新字符串}</code> 若变量内容符合旧字符串，则第一个旧字符串会被新字符串替换</li><li><code>{变量//旧字符串/新字符串}</code> 若变量内容符合旧字符串，则全部的旧字符串会被新字符串替换</li></ul><p>示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>str=&quot;hello,hello,world&quot;</span></span>
<span class="line"><span>echo ${str#h*o} # 输出 ,hello,world</span></span>
<span class="line"><span>echo ${str##h*o}  # 输出 rld</span></span>
<span class="line"><span></span></span>
<span class="line"><span>echo ${str/hello/HELLO} # 输出 HELLO,hello,world</span></span>
<span class="line"><span>echo ${str//hello/HELLO} # 输出 HELLO,HELLO,world</span></span></code></pre></div><h2 id="几种特殊的内容替换结构" tabindex="-1">几种特殊的内容替换结构 <a class="header-anchor" href="#几种特殊的内容替换结构" aria-label="Permalink to &quot;几种特殊的内容替换结构&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>${var:-string} </span></span>
<span class="line"><span>${var:+string} </span></span>
<span class="line"><span>${var:=string}</span></span>
<span class="line"><span>${var:?string}</span></span></code></pre></div><p>1、<code>{var:-string}</code>和<code>${var:=string}</code>:若变量var为空，则用在命令行中用string来替换<code>${var:-string}</code>，否则变量var不为空时，则用变量var的值来替换<code>${var:-string}</code>；对于<code>${var:=string}</code>的替换规则和<code>${var:-string}</code>是一样的，所不同之处是<code>${var:=string}</code>若var为空时，用string替换<code>${var:=string}</code>的同时，把string赋给变量var： <code>${var:=string}</code>很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</p><p>2、<code>${var:+string}</code>的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)</p><p>3、<code>{var:?string}</code>替换规则为：若变量var不为空，则用变量var的值来替换<code>${var:?string}</code>；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</p><p>补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p><h2 id="shell脚本的参数" tabindex="-1">shell脚本的参数 <a class="header-anchor" href="#shell脚本的参数" aria-label="Permalink to &quot;shell脚本的参数&quot;">​</a></h2><p>新建一个Shell脚本1.sh内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>echo  $1</span></span></code></pre></div><p>$1表示该脚本的第一个参数，类似的 $2 、$3表示第2、3个参数，以此类推。</p><p>然后运行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ./test.sh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  hello</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello</span></span></code></pre></div><p>另外，$*引用所有参数列表。$#：表示执行脚本传入参数的所有个数</p><h2 id="条件表达式" tabindex="-1">条件表达式 <a class="header-anchor" href="#条件表达式" aria-label="Permalink to &quot;条件表达式&quot;">​</a></h2><p>在脚本中经常会用到条件表达式，条件表达式常用在if语句中，用中括号包裹，各个部分用空格隔开，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if [ 2 -eq 3 ] then </span></span>
<span class="line"><span>        echo 相等</span></span>
<span class="line"><span>fi</span></span></code></pre></div><p>条件表达式中最常见的情况是比较，比较常用的比较是数值比较和字符串比较。</p><h2 id="数值比较" tabindex="-1">数值比较 <a class="header-anchor" href="#数值比较" aria-label="Permalink to &quot;数值比较&quot;">​</a></h2><p>与数学公式不同，数值比较需要用到-gt、-lt、-eq表示大于、小于、等于号，而不能是<code>&gt;</code>、<code>&lt;</code>、=。</p><table tabindex="0"><thead><tr><th>比较运算符</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>-eq</td><td>相等</td><td>[ 1 -eq 2 ]</td></tr><tr><td>-ne</td><td>不等于</td><td>[ 1 ne 2 ]</td></tr><tr><td>-ge</td><td>大于等于</td><td>[ 1 -eq 2 ]</td></tr><tr><td>-gt</td><td>大于</td><td>[ 2 -gt 1 ]</td></tr><tr><td>-le</td><td>小于等于</td><td>[ 1 -le 2 ]</td></tr><tr><td>-lt</td><td>小于</td><td>[ 1 -le 2 ]</td></tr></tbody></table><p>表格示例中空格间距比较大，就是为了题型注意各个部分一定要加上空格。</p><h2 id="字符串比较" tabindex="-1">字符串比较 <a class="header-anchor" href="#字符串比较" aria-label="Permalink to &quot;字符串比较&quot;">​</a></h2><p>字符串的比较方式是根据ASCII逐个字母比较，常用的字符串比较运算符如下：</p><table tabindex="0"><thead><tr><th>比较运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>=</td><td>相同</td><td>[ &#39;a&#39; = &#39;a&#39; ]</td></tr><tr><td>!=</td><td>不同</td><td>[ &#39;a&#39; != &#39;b&#39; ]</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code> [ &#39;a&#39; &lt; &#39;A&#39; ]</code></td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code> [ &#39;a&#39; &gt; &#39;A&#39; ]</code></td></tr><tr><td>-n str</td><td>字符串str长度是否非0</td><td>[ -n &#39;a&#39; ]</td></tr><tr><td>-z str</td><td>字符串str长度是否为0</td><td>[ -z &#39;&#39; ]</td></tr></tbody></table><h2 id="文件判断" tabindex="-1">文件判断 <a class="header-anchor" href="#文件判断" aria-label="Permalink to &quot;文件判断&quot;">​</a></h2><p>文件判断常用的运算符如下表：</p><table tabindex="0"><thead><tr><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td>-d file</td><td>判断file是否为目录</td></tr><tr><td>-e file</td><td>判断file是否存在</td></tr><tr><td>-f file</td><td>检查file是否为文件</td></tr><tr><td>-r file</td><td>判断文件是否可读</td></tr><tr><td>-s file</td><td>判断file是否存在并非空</td></tr><tr><td>-w file</td><td>判断file是可写</td></tr><tr><td>-x file</td><td>判断file是可执行</td></tr></tbody></table><h2 id="if语句" tabindex="-1">if语句 <a class="header-anchor" href="#if语句" aria-label="Permalink to &quot;if语句&quot;">​</a></h2><p>if语句的作用是根据条件执行不同的指令。if语句的通用语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if [ 条件表达式 ]; then</span></span>
<span class="line"><span>    指令</span></span></code></pre></div><p>注意条件表达式各个部分都要有空格，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if [ 2 -gt 1 ] then </span></span>
<span class="line"><span>        echo 大于 </span></span>
<span class="line"><span>fi</span></span></code></pre></div><p>单分支就是只有一个分支，如同上面的示例。</p><p>双分支有一个if和一个else，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if [ 2 -eq 3 ]  then </span></span>
<span class="line"><span>        echo 相等</span></span>
<span class="line"><span>else </span></span>
<span class="line"><span>        echo 不相等</span></span>
<span class="line"><span>fi</span></span></code></pre></div><p>多分支有一个以上的elif，例如如下脚本1.sh：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if [ $1 -ge 80 ] then </span></span>
<span class="line"><span>        echo 优秀</span></span>
<span class="line"><span>elif [ $1 -ge 60 ] then </span></span>
<span class="line"><span>        echo 及格</span></span>
<span class="line"><span>else </span></span>
<span class="line"><span>        echo 不及格</span></span>
<span class="line"><span>fi</span></span></code></pre></div><p>这里$1表示传入脚本的第一个参数，运行如下示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ bash  1.sh 88</span></span>
<span class="line"><span>优秀</span></span>
<span class="line"><span>$ bash  1.sh 76</span></span>
<span class="line"><span>及格</span></span>
<span class="line"><span>$ bash  1.sh 50</span></span>
<span class="line"><span>不及格</span></span></code></pre></div><h2 id="for循环" tabindex="-1">for循环 <a class="header-anchor" href="#for循环" aria-label="Permalink to &quot;for循环&quot;">​</a></h2><p>for循环的基本语法格式如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>for item in con1 con2 con3</span></span>
<span class="line"><span>do</span></span>
<span class="line"><span>    命令</span></span>
<span class="line"><span>done</span></span></code></pre></div><p>遍历文件</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filelist</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 当前目录所有文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filename </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ${filelist}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">i+1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}个文件是：${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filename</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">done</span></span></code></pre></div><p>还有一种写法</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (( 初始值; 限制条件; 赋值))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    程序段</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">done</span></span></code></pre></div><p>示例</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (( i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    touch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;file${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}.txt&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">done</span></span></code></pre></div><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2><h3 id="创建函数" tabindex="-1">创建函数 <a class="header-anchor" href="#创建函数" aria-label="Permalink to &quot;创建函数&quot;">​</a></h3><p>使用关键字:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function 函数名 {</span></span>
<span class="line"><span>    函数体</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>第二种方式是不使用function关键字,但要带上括号,</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>函数名(){</span></span>
<span class="line"><span>    函数体</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="调用函数" tabindex="-1">调用函数 <a class="header-anchor" href="#调用函数" aria-label="Permalink to &quot;调用函数&quot;">​</a></h3><p>要使用函数,直接写上函数名即可,不要带括号。</p><p>一个具体的示例如下:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Welcome {</span></span>
<span class="line"><span>    read -p &quot;你的名字:&quot; name</span></span>
<span class="line"><span>    echo &quot;你好,${name}&quot; </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Welcome</span></span></code></pre></div><h3 id="带参数的函数" tabindex="-1">带参数的函数 <a class="header-anchor" href="#带参数的函数" aria-label="Permalink to &quot;带参数的函数&quot;">​</a></h3><p>与脚本的参数一样，函数的参数不需要指定名称，而是使用$1 、$2指代。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Welcome{</span></span>
<span class="line"><span>  echo &quot;你好，$1&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Welcome 张三  #输出：你好，张三</span></span></code></pre></div><h3 id="函数的返回值" tabindex="-1">函数的返回值 <a class="header-anchor" href="#函数的返回值" aria-label="Permalink to &quot;函数的返回值&quot;">​</a></h3><p>函数使用echo返回值，这与常用的return习惯不太一样。注意，echo在函数体外是向终端输出内容，但在这里表示返回值，也就是说，分两种情况：</p><ul><li>如果有一个变量接住这个函数，此echo就失去了原有的作用——也就不会在终端输出值。</li><li>如果没有变量接住这个函数，那么echo就会在终端输出。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Welcome {</span></span>
<span class="line"><span>    echo &quot;你好，$1&quot;  # 此时不会在终端输出</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>out=$(Welcome)  # 变量接住了，没有输出</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Welcome 张三  # 没有变量接住，输出 你好，张三</span></span></code></pre></div><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h2><p>如果已经知道数组元素，使用如下方式新建数组：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>arr=(1 2 three four)</span></span></code></pre></div><p>空格分隔的每个部分都对应一个元素，如下示例按索引位置打印元素：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>echo ${arr[0]}  ${arr[3]}</span></span>
<span class="line"><span>1 four</span></span></code></pre></div><h2 id="给脚本传递参数" tabindex="-1">给脚本传递参数 <a class="header-anchor" href="#给脚本传递参数" aria-label="Permalink to &quot;给脚本传递参数&quot;">​</a></h2><ul><li><code>$0</code> 第0个参数，即执行文件本身</li><li><code>$1</code> 第1个参数</li><li><code>$n</code> 第n个参数, n是正整数</li><li 10="">注意, 如果参数过多, 达到了两位数,那么就要加花括号,例如 $</li><li><code>$#</code> 表示脚本运行时携带的命令行参数的个数</li><li><code>$*</code>变量会将所有的命令行参数视为一个单词, 该选项不常用</li><li><code>$@</code>变量会将所有的命令行参数视为同一字符串中的多个独立的单词，以便你能通过for循环遍历,</li></ul><p>新建一个Shell脚本test.sh内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>echo  &quot;第0个参数也就是脚本名称是：$0&quot;</span></span>
<span class="line"><span>echo  &quot;第1个参数是：$1&quot;</span></span>
<span class="line"><span>echo  &quot;第2个参数是：$2&quot;</span></span>
<span class="line"><span>echo  &quot;参数个数为: $#&quot;</span></span>
<span class="line"><span>echo  &quot;参数列表为: $@&quot;</span></span></code></pre></div><p>$1表示该脚本的第一个参数，类似的 $2 、$3表示第2、3个参数，以此类推。</p><p>然后运行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ./test.sh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  hello</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shell</span></span></code></pre></div><p>输出如下结果:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>第0个参数也就是脚本名称是：test.txt</span></span>
<span class="line"><span>第1个参数是：hello</span></span>
<span class="line"><span>第2个参数是：bash</span></span>
<span class="line"><span>参数个数为: 3</span></span>
<span class="line"><span>参数列表为: hello bash shell</span></span></code></pre></div><h1 id="列字段筛选工具-awk命令" tabindex="-1">列字段筛选工具：awk命令 <a class="header-anchor" href="#列字段筛选工具-awk命令" aria-label="Permalink to &quot;列字段筛选工具：awk命令&quot;">​</a></h1><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>awk  选项  &#39;行筛选条件{列编辑指令}&#39; 文件或列表</span></span></code></pre></div><p>选项： -F 指定分隔符</p><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cat /etc/passwd | awk -F &quot;:&#39; &quot;{print $1,$3,$4}&#39;&#39;</span></span></code></pre></div><p>以&quot;:&quot;为分隔符，输出1，3，4列内容</p><h2 id="内部变量" tabindex="-1">内部变量 <a class="header-anchor" href="#内部变量" aria-label="Permalink to &quot;内部变量&quot;">​</a></h2><ul><li>FS：指定每行文本的字段分隔符，默认为空格或制表位。 与-F一样</li><li>NF：当前处理的行的字段个数。</li><li>NR：当前处理的行的行号（序数）。</li><li>$0：当前处理的行的整行内容。</li><li>$n：当前处理行的第 n 个字段（第 n 列）。</li><li>FILENAME：被处理的文件名。</li><li>RS：数据记录分隔，默认为\n，即每行为一条记录。</li></ul><h2 id="行筛选条件" tabindex="-1">行筛选条件 <a class="header-anchor" href="#行筛选条件" aria-label="Permalink to &quot;行筛选条件&quot;">​</a></h2><p>输出奇数行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nl /etc/passwd | awk &#39;(NR%2)==1{print}&#39;</span></span></code></pre></div><p>输出1、3行的内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cat /etc/passwd | awk &#39;NR==1||NR==3{print}&#39;</span></span></code></pre></div><h2 id="if语句-1" tabindex="-1">if语句 <a class="header-anchor" href="#if语句-1" aria-label="Permalink to &quot;if语句&quot;">​</a></h2><p>必须用在{}中，且比较内容用()扩起来</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>awk -F: &#39;{if($1~/mail/) print $1}&#39; /etc/passwd                                       //简写</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>awk -F: &#39;{if($1~/mail/) {print $1}}&#39;  /etc/passwd                                   //全写</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>awk -F: &#39;{if($1~/mail/) {print $1} else {print $2}}&#39; /etc/passwd            //if...else...</span></span></code></pre></div><h1 id="管理分区与文件系统" tabindex="-1">管理分区与文件系统 <a class="header-anchor" href="#管理分区与文件系统" aria-label="Permalink to &quot;管理分区与文件系统&quot;">​</a></h1><h2 id="设备名称" tabindex="-1">设备名称 <a class="header-anchor" href="#设备名称" aria-label="Permalink to &quot;设备名称&quot;">​</a></h2><p>在Linux中，硬盘一般命名为/dev/sda，如果有第二块，则继续命名为/dev/sdb。</p><p>分区一般在硬盘名称后加数字，例如/dev/sda1、/dev/sda2。</p><p>不过，对于Windows和Linux双系统而言，这种命名方式可能不适应，具体硬盘名称需要打开 /etc/fstab 查看。</p><h2 id="分区、挂载、挂载点的概念" tabindex="-1">分区、挂载、挂载点的概念 <a class="header-anchor" href="#分区、挂载、挂载点的概念" aria-label="Permalink to &quot;分区、挂载、挂载点的概念&quot;">​</a></h2><p>一块硬盘往往分为几个区，例如Windows的C盘、D盘、E盘，就是三个分区。</p><p>在Linux中，一个分区只有连接到文件系统中的某个目录才能使用这个分区，将硬盘的某个分区对应到Linux的某个目录称为“挂载”。</p><p>将U盘这个“特殊的分区”对应到某个目录（例如/mnt/sandisk）也称为“挂载”。</p><p>每个硬盘、每个分区都统一使用“设备”来称呼，每个硬盘、每个分区都使用一个设备名称来唯一标识。</p><p>关于分区、设备名称、挂载点的信息都记录在/etc/fstab文件中，该文件的每一行都表示一个分区及其挂载点，还包括分区容量等其它信息。</p><h2 id="分区表" tabindex="-1">分区表 <a class="header-anchor" href="#分区表" aria-label="Permalink to &quot;分区表&quot;">​</a></h2><p>分区表用来存储关于硬盘每个分区的大小和布局信息，有两种标准：</p><ul><li>传统的MBR，适用于古老的BIOS启动方式，MBR分区大小限制在了2TB。</li><li>新兴的GUID，gpt分区，适用于UEFI体系，取代BIOS。GUID分区可以支持高达9.4ZB的分区。</li></ul><p>由于fdisk并不支持gpt分区，所以使用parted命令。</p><h2 id="分区管理" tabindex="-1">分区管理 <a class="header-anchor" href="#分区管理" aria-label="Permalink to &quot;分区管理&quot;">​</a></h2><p>查看硬盘分区信息：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>parted -l 硬盘名称</span></span></code></pre></div><h2 id="挂载" tabindex="-1">挂载 <a class="header-anchor" href="#挂载" aria-label="Permalink to &quot;挂载&quot;">​</a></h2><h3 id="自动挂载" tabindex="-1">自动挂载 <a class="header-anchor" href="#自动挂载" aria-label="Permalink to &quot;自动挂载&quot;">​</a></h3><p>编辑/etc/fstab文件</p><h3 id="手动挂载" tabindex="-1">手动挂载 <a class="header-anchor" href="#手动挂载" aria-label="Permalink to &quot;手动挂载&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mount -t ext3 -o ro dev/sdb1 /mnt/tmp</span></span></code></pre></div><h1 id="c-语言" tabindex="-1">C 语言 <a class="header-anchor" href="#c-语言" aria-label="Permalink to &quot;C 语言&quot;">​</a></h1><p>printf()函数的作用是打印内容到控制台。</p><p>printf()最简单的用法是传递一个字符串字面量：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>printf(&quot;hello,world!&quot;)</span></span></code></pre></div><p>如果要输出包含变量的字符串，则需要使用转换说明语法，该语法使用一个百分号加一个字母，用于匹配变量的类型以及输出形式，从第二个参数开始，依次匹配变量和转换说明。常见的转换说明包括：</p><ul><li>%d： 有符号十进制整数</li><li>%s： 字符串</li><li>%p： 指针</li><li>%f： 浮点数</li><li>%c： 单个字符</li></ul><p>printf()同时也会解析转义字符：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int a = 1;</span></span>
<span class="line"><span>char str[20] = &quot;hello,wolrd&quot;; </span></span>
<span class="line"><span>printf(&quot;output:\n %d \n %s&quot;,  a , str );</span></span></code></pre></div><h3 id="数组和指针" tabindex="-1">数组和指针 <a class="header-anchor" href="#数组和指针" aria-label="Permalink to &quot;数组和指针&quot;">​</a></h3><p>数组表示多个相同类型的元素的有序集合，数组在内存中是连续分布的，因此，使用指针运算读取元素非常快。</p><p>声明数组需要定义元素的类型，然后将数组名称后面加上中括号，中括号里面可以写上数组的最大长度，也可以不写，不过，最佳实践是永远都写上最大长度。等号右边将元素用花括号包裹，逗号隔开：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int arr[3] = {1,2,3};</span></span></code></pre></div><p>实际元素的数量可以少于定义的长度，但是不能超过定义的长度。</p><p>数组名称是一个指针类型，指向数组的第一个元素的地址，也叫数组的首地址：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int arr[3] = {1,2,3};</span></span>
<span class="line"><span>printf(&quot;first element address: %p \n&quot;, &amp;arr[0]);</span></span>
<span class="line"><span>printf(&quot;%p&quot;,  arr);</span></span></code></pre></div><p>通过输出的结果可以看到，arr的值是一个地址，与数组首地址&amp;arr[0]是相同的。</p><p>数组名是一个指针，如果该指针加1，表示该指针向后移动一个元素类型所占字节的长度，也就是跳到下一个元素，例如本例中，元素类型是int，占4个字节，所以向后移动了4个字节，刚好跳到了下一个元素的位置。</p><p>在下述代码中，定义了一个指针p，并将数组名称赋给它。此时p指向第一个元素，之后p++，此时p跳到了下一个元素。分别用p和*p打印除了此时的地址及值：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int arr[3] = {1,2,3};</span></span>
<span class="line"><span>int * p = arr;</span></span>
<span class="line"><span>printf(&quot;first address: %p \n&quot;, p);</span></span>
<span class="line"><span>printf(&quot;first address: %p \n&quot;, &amp;arr[0]);</span></span>
<span class="line"><span>printf(&quot;first value: %d \n&quot;, *p);</span></span>
<span class="line"><span>printf(&quot;first value: %d \n&quot;, arr[0]);</span></span>
<span class="line"><span>p++;</span></span>
<span class="line"><span>printf(&quot;second address: %p \n&quot;, p);</span></span>
<span class="line"><span>printf(&quot;second address: %p \n&quot;, &amp;arr[1]);</span></span>
<span class="line"><span>printf(&quot;second value: %d \n&quot;, *p);</span></span>
<span class="line"><span>printf(&quot;second value: %d \n&quot;, arr[1]);</span></span>
<span class="line"><span>p++;</span></span>
<span class="line"><span>printf(&quot;thrid address: %p \n&quot;, p);</span></span>
<span class="line"><span>printf(&quot;thrid address: %p \n&quot;, &amp;arr[2]);</span></span>
<span class="line"><span>printf(&quot;third value: %d \n&quot;, *p);</span></span>
<span class="line"><span>printf(&quot;third value: %d \n&quot;, arr[2]);</span></span></code></pre></div><p>输出结果如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>first address: 0x7ffdb1610e80 </span></span>
<span class="line"><span>first address: 0x7ffdb1610e80 </span></span>
<span class="line"><span>first value: 1 </span></span>
<span class="line"><span>first value: 1 </span></span>
<span class="line"><span>second address: 0x7ffdb1610e84 </span></span>
<span class="line"><span>second address: 0x7ffdb1610e84 </span></span>
<span class="line"><span>second value: 2 </span></span>
<span class="line"><span>second value: 2 </span></span>
<span class="line"><span>thrid address: 0x7ffdb1610e88 </span></span>
<span class="line"><span>thrid address: 0x7ffdb1610e88 </span></span>
<span class="line"><span>third value: 3 </span></span>
<span class="line"><span>third value: 3</span></span></code></pre></div><p>根据结果可以得知，每次指针加1，地址就加了4个字节，刚好是整数类型所需的字节数。同时，使用*p读取元素值，和使用arr[1]读取元素值是等价的。</p><p>请注意，指针p并不知道自己指向的是数组的某个元素，还是一个独立的整数，它只知道自己指向了一个存储整型数据的内存地址而已。运行p++，它也只是按照数据类型移动了4个字节而已，它也并不知道移到了下一个元素，只是因为数组在内存中是连续分布的，指针的移动“刚好对上了”下一个元素的地址而已。总而言之，指针不认识数组，只知道自己指向一个地址，然后根据指针运算规则移动一定的字节长度，然后取出值而已。</p><p>我们可以接着上面的代码，虽然上面已经移动到了最后一个元素的位置，但是仍然可以再继续移动：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">p++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;next address: %p \n&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;next value: %d \n&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>输出结果是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>thrid address: 0x7ffdb1610e8c </span></span>
<span class="line"><span>third value: -1025609304</span></span></code></pre></div><p>可以看到，指针依然移动了4个字节，依然读取了内存中的值，但这个值是没有意义的，它也不知道自己是否还处于数组所在的内存区域中。</p><h3 id="字符串和指针" tabindex="-1">字符串和指针 <a class="header-anchor" href="#字符串和指针" aria-label="Permalink to &quot;字符串和指针&quot;">​</a></h3><p>C语言并没有专门用于存储字符串的数据类型，字符串存储在char类型的数组中，如下定义了一个字符串变量：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>char a[10] = &quot;hello&quot;;</span></span></code></pre></div><p>要让字符数组表示为字符串，该字符数组的末尾一定要是空字符&#39;\0&#39;，这是普通的字符数组和字符串的最显著的区别，只有在，只有这样，系统才会识别为字符串。上面的字符串声明示例等价于：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>char a[10] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;};</span></span></code></pre></div><p>如下示例中，a会识别为字符串，而b只是由字符组成的数组，因为末尾没有空字符&#39;\0&#39;：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;e&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;l&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;l&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;o&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;e&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;l&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;l&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;o&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>因此，在指定字符数组的长度时，要确保该值至少比字符个数多1，因为与要容纳最后的空字符。也就是说，字符串的长度永远比字符数量多1。</p><p>不过，通常并不使用字符串数组的方式声明字符串字面量，而是直接采用引号的方式，编译器会自动加入末尾的空字符&#39;\0&#39;。</p><p>除了使用字符数组的方式声明字符串以外，还可以使用字符指针：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>与数值、字符这种单一类型不同的是，str的数据类型虽然是指针，但是打印字符串时依然使用的是a，只需要使用%s转换说明即可：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;address: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%p</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> value : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, str, str );</span></span></code></pre></div><h3 id="结构体和指针" tabindex="-1">结构体和指针 <a class="header-anchor" href="#结构体和指针" aria-label="Permalink to &quot;结构体和指针&quot;">​</a></h3><p>结构体变量表示一组属性的集合，使用结构体变量首先要使用struct 关键字声明一个结构体类型，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct book{</span></span>
<span class="line"><span>        char name[20];</span></span>
<span class="line"><span>        float price;</span></span>
<span class="line"><span>};</span></span></code></pre></div><p>结构体类型book包含两个属性成员：字符数组类型的name和浮点类型的price。</p><p>定义了结构体类型后，就可以新建一个该类型的结构体变量并对成员依次赋值：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct book book1 = {</span></span>
<span class="line"><span>        &quot;C Primer Plus&quot;,</span></span>
<span class="line"><span>        89.00</span></span>
<span class="line"><span>};</span></span></code></pre></div><p>也可以先定义结构变量，再单独为每个成员赋值：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct book  book1 ;</span></span>
<span class="line"><span>book1.name = &quot;C Primer Plus&quot;;</span></span>
<span class="line"><span>book1.price = 89.00;</span></span></code></pre></div><p>除了声明单个结构体变量，还可以声明结构体数组，数组中的每个元素都是一个结构变量，成员相同，对应的值不同。如下示例定义了结构体数组books，其中有2个结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct book books[2];</span></span></code></pre></div><p>books[0]表示第一个结构体，要读写其中的成员，使用books[0].name和books[0].price。类似地，books[1]表示第二个结构体，其中的成员是books[1].name和books[1].price。</p><p>在生命结构体数组的时候也可以同时为每个元素的成员赋值：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct book{</span></span>
<span class="line"><span>        char name[20];</span></span>
<span class="line"><span>        float price;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct book books[2] = {</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>                &quot;C Primer Plus&quot;,</span></span>
<span class="line"><span>                89.00</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>                &quot;C++ Primer Plus&quot;,</span></span>
<span class="line"><span>                99.00</span></span>
<span class="line"><span>        } </span></span>
<span class="line"><span>};</span></span></code></pre></div><p>指针表示指向某个变量的内存地址，结构体类型的指针则表示指向某个结构体变量的内存地址。</p><p>指向结构的指针比结构本身更容易操控。结构体数组本质是也是数组，所以使用指针运算可以直接跳到下一个结构体元素的地址。对于函数调用，传递指针比拷贝结构体变量副本更有效率。</p><p>如下示例代码先定义一个结构体类型book，然后定义了一个结构体数组books，随后声明了指向该数组的指针，该指针首先指向第一个结构体元素，然后通过解引用方式读取结构体变量中的成员，最后通过指针运算移动指针，读取下一个结构体元素：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct book{</span></span>
<span class="line"><span>        char name[20];</span></span>
<span class="line"><span>        float price;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct book books[2] = {</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>                &quot;C Primer Plus&quot;,</span></span>
<span class="line"><span>                89.00</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>                &quot;C++ Primer Plus&quot;,</span></span>
<span class="line"><span>                99.00</span></span>
<span class="line"><span>        } </span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* 这是一个指向结构变量的指针 */</span></span>
<span class="line"><span>struct book * p;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/*  由于books是数组，所以等价于 p=&amp;books[0]  */</span></span>
<span class="line"><span>p= books;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* 由于优先级的原因，*p需要用括号括起来 */</span></span>
<span class="line"><span>printf(&quot;%s \n&quot;,(*p).name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* 指针指向了数组中的下一个结构变量 */</span></span>
<span class="line"><span>p ++ ;</span></span>
<span class="line"><span>printf(&quot;%s \n&quot;,(*p).name);</span></span></code></pre></div><h1 id="c" tabindex="-1">C++ <a class="header-anchor" href="#c" aria-label="Permalink to &quot;C++&quot;">​</a></h1><h3 id="输出" tabindex="-1">输出 <a class="header-anchor" href="#输出" aria-label="Permalink to &quot;输出&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cout &lt;&lt; &quot;hello,world!&quot; ;</span></span>
<span class="line"><span>cout  &lt;&lt;  endl ;  </span></span>
<span class="line"><span>cout &lt;&lt; endl &lt;&lt; &quot;hello,world&quot; ;</span></span>
<span class="line"><span>cout  &lt;&lt; &quot;hello&quot;  &lt;&lt; endl &lt;&lt; &quot;world&quot; ;</span></span></code></pre></div><h3 id="整数类型" tabindex="-1">整数类型 <a class="header-anchor" href="#整数类型" aria-label="Permalink to &quot;整数类型&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int  a = 1;</span></span>
<span class="line"><span>cout  &lt;&lt; a ;</span></span></code></pre></div><h3 id="函数-1" tabindex="-1">函数 <a class="header-anchor" href="#函数-1" aria-label="Permalink to &quot;函数&quot;">​</a></h3><ul><li>无返回值无参数</li></ul><div class="language-cs vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#  include   &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello,world&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>有返回值有参数</li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#  include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ;}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#  include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">string</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> msg;}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello,world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="浮点数" tabindex="-1">浮点数 <a class="header-anchor" href="#浮点数" aria-label="Permalink to &quot;浮点数&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>float a = 1.5f;</span></span>
<span class="line"><span>    cout &lt;&lt; a;</span></span></code></pre></div><p>默认的带小数点的字面量是double类型，如果需要为float类型，需要在字面量后面加上f。</p><h3 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-label="Permalink to &quot;字符串&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#  include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    string a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello,world你好&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a ;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="结构体" tabindex="-1">结构体 <a class="header-anchor" href="#结构体" aria-label="Permalink to &quot;结构体&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#  include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   people</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    string name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">people  p1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tim&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">39</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} ;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">people  p2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cook&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} ;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;:&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> endl ;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;:&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> endl ;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="数组-1" tabindex="-1">数组 <a class="header-anchor" href="#数组-1" aria-label="Permalink to &quot;数组&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#  include   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">iostream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">using namespace std;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] ;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="for循环-1" tabindex="-1">for循环 <a class="header-anchor" href="#for循环-1" aria-label="Permalink to &quot;for循环&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#  include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> endl;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="if语句-2" tabindex="-1">if语句 <a class="header-anchor" href="#if语句-2" aria-label="Permalink to &quot;if语句&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#  include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 75</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;优秀&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;及格&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;不及格&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="三元表达式" tabindex="-1">三元表达式 <a class="header-anchor" href="#三元表达式" aria-label="Permalink to &quot;三元表达式&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#  include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 75</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;及格&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;不及格&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result ;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h1 id="java" tabindex="-1">Java <a class="header-anchor" href="#java" aria-label="Permalink to &quot;Java&quot;">​</a></h1><h3 id="helloworld" tabindex="-1">HelloWorld <a class="header-anchor" href="#helloworld" aria-label="Permalink to &quot;HelloWorld&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class HelloJava{</span></span>
<span class="line"><span>        public static void main(String[]  args){</span></span>
<span class="line"><span>                System.out.println(&quot;Hello,Java!&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="包和导入" tabindex="-1">包和导入 <a class="header-anchor" href="#包和导入" aria-label="Permalink to &quot;包和导入&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import javax.swing.*;</span></span></code></pre></div><h3 id="浮点类型" tabindex="-1">浮点类型 <a class="header-anchor" href="#浮点类型" aria-label="Permalink to &quot;浮点类型&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>double d = 8.31;</span></span>
<span class="line"><span>float f = 8.31f;</span></span></code></pre></div><h3 id="泛型数组" tabindex="-1">泛型数组 <a class="header-anchor" href="#泛型数组" aria-label="Permalink to &quot;泛型数组&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import java.util.*;</span></span>
<span class="line"><span>public class 学习{</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>       </span></span>
<span class="line"><span>      ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>      arr.add(1);   </span></span>
<span class="line"><span>      arr.add(2);   </span></span>
<span class="line"><span>      </span></span>
<span class="line"><span>      System.out.println(arr);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="var" tabindex="-1">var <a class="header-anchor" href="#var" aria-label="Permalink to &quot;var&quot;">​</a></h3><p>var关键字的意思是，让编译器自己推断数据类型，而且一旦推断出来，那么类型不可改变，例如：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>等价于</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="arraylist" tabindex="-1">ArrayList <a class="header-anchor" href="#arraylist" aria-label="Permalink to &quot;ArrayList&quot;">​</a></h3><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ArrayList&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sites </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sites.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Google&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sites.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Runoob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sites.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Taobao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sites.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Weibo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sites);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[Google, Runoob, Taobao, Weibo]</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 学习</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ArrayList arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>会出现警告，原因是类型未经过检查。</p><h3 id="hashmap" tabindex="-1">HashMap <a class="header-anchor" href="#hashmap" aria-label="Permalink to &quot;HashMap&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import java.util.*;</span></span>
<span class="line"><span>public class 学习{</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>       </span></span>
<span class="line"><span>      HashMap m = new HashMap();</span></span>
<span class="line"><span>      m.put(&quot;a&quot;,1);</span></span>
<span class="line"><span>      m.put(&quot;b&quot;,2);</span></span>
<span class="line"><span>      System.out.println(m);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="泛型hashmap" tabindex="-1">泛型HashMap <a class="header-anchor" href="#泛型hashmap" aria-label="Permalink to &quot;泛型HashMap&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import java.util.*;</span></span>
<span class="line"><span>public class 学习{</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>       </span></span>
<span class="line"><span>      HashMap&lt;String,Integer&gt; m = new HashMap&lt;&gt;();</span></span>
<span class="line"><span>      m.put(&quot;a&quot;,1);</span></span>
<span class="line"><span>      m.put(&quot;b&quot;,2);</span></span>
<span class="line"><span>      System.out.println(m);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="map" tabindex="-1">Map <a class="header-anchor" href="#map" aria-label="Permalink to &quot;Map&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Map&lt;String,String&gt; map=new HashMap&lt;&gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>map.put(&quot;2001&quot;, &quot;张三&quot;);</span></span>
<span class="line"><span>map.put(&quot;2002&quot;, &quot;张三&quot;);</span></span>
<span class="line"><span>map.put(&quot;2003&quot;, &quot;李四&quot;);</span></span>
<span class="line"><span>map.put(&quot;2003&quot;, &quot;王五&quot;);//键重复，会覆盖上一个，留下最新的</span></span>
<span class="line"><span></span></span>
<span class="line"><span>System.out.println(map);//{2003=王五, 2002=张三, 2001=张三}</span></span></code></pre></div><h3 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class 学习{</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>       </span></span>
<span class="line"><span>       Runnable r=()-&gt;{</span></span>
<span class="line"><span>        while(true){</span></span>
<span class="line"><span>            System.out.print(&quot;A&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>       };</span></span>
<span class="line"><span>       Thread t = new Thread(r);</span></span>
<span class="line"><span>       t.start();</span></span>
<span class="line"><span>       while(true){</span></span>
<span class="line"><span>            System.out.print(&quot;B&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="读取输入" tabindex="-1">读取输入 <a class="header-anchor" href="#读取输入" aria-label="Permalink to &quot;读取输入&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import java.util.*;</span></span>
<span class="line"><span>public class 学习{</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>       </span></span>
<span class="line"><span>        Scanner in = new Scanner(System.in, &quot;GBK&quot;);</span></span>
<span class="line"><span>        while(true){</span></span>
<span class="line"><span>            String a = in.nextLine();</span></span>
<span class="line"><span>            System.out.println(a);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><a href="#python运行时">Python运行时</a></li></ul><h1 id="函数计算" tabindex="-1">函数计算 <a class="header-anchor" href="#函数计算" aria-label="Permalink to &quot;函数计算&quot;">​</a></h1><h2 id="触发器" tabindex="-1">触发器 <a class="header-anchor" href="#触发器" aria-label="Permalink to &quot;触发器&quot;">​</a></h2><p>函数计算是事件驱动的云服务，因此要执行一个函数，就必须要有一个事件发生，这个事件叫做“触发器”。</p><ul><li>云产品事件：例如存储桶中新增了一个文件。</li><li>HTTP事件 ：使用浏览器、API、SDK发送HTTP请求时触发。</li></ul><p>一个触发器加上一个请求处理程序就组成了一个可以提供服务的函数。</p><h2 id="函数处理程序" tabindex="-1">函数处理程序 <a class="header-anchor" href="#函数处理程序" aria-label="Permalink to &quot;函数处理程序&quot;">​</a></h2><p>一个触发器对应一个请求处理程序handler。handler包括一个文件名和方法名。</p><p>对于Python而言，请求处理程序格式为<code>文件名.方法名</code>，例如文件名是main.py，方法名为handler，那么请求处理程序为main.handler。</p><p>对于Node.js而言，请求处理程序为<code>文件名.方法名</code>，例如文件名是index.js，方法名为handler，那么请求处理程序为 index.handler。</p><h2 id="event" tabindex="-1">event <a class="header-anchor" href="#event" aria-label="Permalink to &quot;event&quot;">​</a></h2><p>event 为调用函数时传入的参数。即响应报文的body，用JSON格式表示。例如：</p><p><img src="/blog/assets/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.Cpl54LGd.png" alt="响应报文"></p><p>通过json模块的loads()方法可以将JSON对象转化成Python对象：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>eventObj = json.loads(event)</span></span></code></pre></div><h2 id="node-js运行时" tabindex="-1">Node.js运行时 <a class="header-anchor" href="#node-js运行时" aria-label="Permalink to &quot;Node.js运行时&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// index.mjs</span></span>
<span class="line"><span>export const handler = async (event, context) =&gt; {</span></span>
<span class="line"><span>    const eventObj = JSON.parse(event)</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 请求体</span></span>
<span class="line"><span>    const body = eventObj.body</span></span>
<span class="line"><span>    return body</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>关键信息说明如下：</p><ul><li>handler ： 方法名称。例如，为FC函数配置的请求处理程序为index.handler，那么函数计算的入口就是index.mjs中的handler函数。</li><li>event ：请求信息，包含了请求头、请求体等关键信息，格式为JSON文本。</li><li>context ：函数的执行环境信息。例如运行时、内存大小等。</li><li>return ： 作为响应报文的响应体返回给客户端。</li></ul><h2 id="python运行时" tabindex="-1">Python运行时 <a class="header-anchor" href="#python运行时" aria-label="Permalink to &quot;Python运行时&quot;">​</a></h2><p>使用HTTP请求处理程序前，请确保已经为函数配置<strong>HTTP触发器</strong>。</p><p>一个简单的HTTP处理函数示例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>def handler(event, context):</span></span>
<span class="line"><span>    return &#39;hello world&#39;</span></span></code></pre></div><h1 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h1><h2 id="linux简介" tabindex="-1">Linux简介 <a class="header-anchor" href="#linux简介" aria-label="Permalink to &quot;Linux简介&quot;">​</a></h2><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><h2 id="shell简介" tabindex="-1">Shell简介 <a class="header-anchor" href="#shell简介" aria-label="Permalink to &quot;Shell简介&quot;">​</a></h2><p>在没有图形界面的时代，Shell是用户与操作系统交互的唯一方式。</p><p>用户输入命令，shell将命令传递给操作系统，操作系统执行后返回给shell，显示在终端上，这就是shell执行的一般流程。</p><p>终端只是一个图形界面，shell才是“真正的灵魂”。</p><p>所以，bash是shell，而不是终端，当你安装了bash之后，你可以在任意终端使用bash。</p><p>比如Windows terminal 是Win11自带的终端软件，它里面可以调用的shell包括：powershell、bash（如果已安装）、cmd等。</p><p>Windows10上安装的powershell既可以认为是终端，也可以认为是shell，只是因为它们取了相同的名字。不过我们可以在vscode的集成终端环境中使用powershell，此时PowerShell就是shell。</p><p>最流行的shell是bourne shell，简称bash，它预装在许多流行的Linux发行版上。当然，还有更现代的zsh、颇受用户喜爱的fish等Shell。</p><p>这里更推荐学习Bash，因为一通百通，学会了bash，其它的shell就很容易了。后面的教程都默认使用Bash。</p><h2 id="在windows上获取bash" tabindex="-1">在Windows上获取bash <a class="header-anchor" href="#在windows上获取bash" aria-label="Permalink to &quot;在Windows上获取bash&quot;">​</a></h2><p>bash是大多数Linux默认的shell，但是我们经常使用的是Windows。</p><p>如果不想安装完整的Linux桌面操作系统，而只是想在Windows上获取一个Bash环境，有几种解决方案。</p><ul><li>Cygwin</li></ul><p>Cygwin在Windows下提供了具备Linux观感的类Linux环境，提供了大量的POSIX ApI功能的DLL。</p><p>但是请注意，cygwin不是在Windows上运行原生Linux程序的方法，如果要这么做，必须从源代码构建。</p><ul><li>wsl</li></ul><p>wsl是微软推出的在Windows上运行的Linux子系统，可以直接到应用商店搜索Ubuntu下载安装。</p><ul><li>git bash</li></ul><p>大多数情况下，我们只是想使用shell命令，而并不需要Linux环境，此时可以使用git bash。</p><p>安装git 默认安装git bash ，它包括了很多与shell命令同名的exe文件，可以直接使用。实际上这些命令足够我们学习完整的shell了。</p><h2 id="终端提示符" tabindex="-1">终端提示符 <a class="header-anchor" href="#终端提示符" aria-label="Permalink to &quot;终端提示符&quot;">​</a></h2><p>打开终端后，每次在输入命令前会看到有一段文本，这段文本叫终端提示符：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[  username@hostname~  ]$</span></span></code></pre></div><p>这里的username表示用户名称， hostname表示主机名，~表示当前工作目录是用户的家目录。</p><p>中括号后面会接一个美元符号<code>$</code>或井号#。美元符号<code>$</code>表示一般用户，井号地代表管理员。</p><p>Linux有两种用户，一般用户和管理员用户，大部分文件系统管理相关的命令只需要一般用户即可。</p><p>我们后面的代码示例会省略中括号的内，只显示提示符<code>$</code>，表示后面的内容是你需要输入到终端的。注意，只需要输入$后面的文本，而不能重复输入<code>$</code>。一般紧接着会我们会写出终端返回的结果。例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$  which ls    # which ls是需要输入的命令</span></span>
<span class="line"><span>/usr/bin/ls   # 终端显示的结果</span></span></code></pre></div><p>和大多数编程语言不一样，Linux在命令行和脚本中使用井号#表示将该行后面的内容注释掉。例如上文示例。</p><h2 id="bash常用快捷键" tabindex="-1">Bash常用快捷键 <a class="header-anchor" href="#bash常用快捷键" aria-label="Permalink to &quot;Bash常用快捷键&quot;">​</a></h2><p>Bash常用快捷键如下：</p><table tabindex="0"><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctr+C</td><td>停止正在运行的任务</td></tr><tr><td>Ctrl+D</td><td>退出当前Shell</td></tr><tr><td>Ctrl+U</td><td>清空当前命令行内容</td></tr><tr><td>Ctrl+A</td><td>移到行首</td></tr><tr><td>Ctrl+E</td><td>移到行尾</td></tr><tr><td>Ctrl+K</td><td>从光标出删除到末尾</td></tr></tbody></table><h2 id="tab补全" tabindex="-1">Tab补全 <a class="header-anchor" href="#tab补全" aria-label="Permalink to &quot;Tab补全&quot;">​</a></h2><p>使用命令行最多的按键或许就是Tab键了，所以单独使用一小节讲解。Tab键会根据你已经输入的少数几个字符自动猜测后面的内容并进行补全。常见的情况有以下几种。</p><ul><li><p>命令补全： 例如先输入ec两个字符，按Tab键，Bash会补全成echo。不过Linux命令一般都比较简短，一般都是直接写完整的命令。</p></li><li><p>文件名称补全： 这是最实用的功能，一般来说文件名都比较长，如果每次都要输入完整的文件名不仅费时而且极容易出错。此时，只需要输入文件名的前一个或少数几个字符，再按下Tab键就可以自动补全文件名，如果匹配的文件名超过1个，那么终端就会输出匹配的文件名供我们再次输入以缩小范围。</p></li></ul><h2 id="环境变量" tabindex="-1">环境变量 <a class="header-anchor" href="#环境变量" aria-label="Permalink to &quot;环境变量&quot;">​</a></h2><h3 id="bash的内置环境变量" tabindex="-1">Bash的内置环境变量 <a class="header-anchor" href="#bash的内置环境变量" aria-label="Permalink to &quot;Bash的内置环境变量&quot;">​</a></h3><p>以下是直接可以使用的环境变量，注意区分大小写。</p><ul><li>HOME ： 当前用户家目录</li><li>USER：用户名</li><li>CDPATH： 以冒号分隔的目录列表，作为cd命令的搜索路径</li><li>PS1 ： shell命令行的主提示符</li><li>PS2： shell命令行的次提示符</li><li>PATH： shell查找命令时检索的目录列表，以冒号分隔</li><li>BASH ： bash shell 当前实例的完整路径名</li><li>BASH_VERSION：bash版本</li><li>LANG ：当前环境的语言</li><li>HISTFILE：历史文件的位置，通常位于<code>$HONE/.bash_history</code></li><li>HISTFILESIZE：可以存储的历史命令条数，默认为1000，这个值对于大多数情况够用。</li><li>HOSTNAME： 当前主机名称</li><li>OSTYPE：操作系统类型。</li><li>LINES ：终端山可见的行数</li><li>PS0：执行命令之前显示的内容</li><li>PWD：当前工作目录</li></ul><h3 id="修改path环境变量" tabindex="-1">修改PATH环境变量 <a class="header-anchor" href="#修改path环境变量" aria-label="Permalink to &quot;修改PATH环境变量&quot;">​</a></h3><p>一个非常常见的场景是将一些路径添加到PATH环境变量的路径列表中，也就是修改PATH环境变量的值。</p><p>例如，将家目录的bin目录添加到PATH环境变量：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$PATH=&quot;${PATH}:/${HOME}/bin&quot;</span></span></code></pre></div><h3 id="新增和修改自定义环境变量" tabindex="-1">新增和修改自定义环境变量 <a class="header-anchor" href="#新增和修改自定义环境变量" aria-label="Permalink to &quot;新增和修改自定义环境变量&quot;">​</a></h3><p>export命令可以将指定的变量设置为环境变量。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ ENV_EXANPLE=ENV_EXAMLLE_VALUE</span></span>
<span class="line"><span>$ export ENV_EXANPLE</span></span></code></pre></div><p>也可以写在一起：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export ENV_EXANPLE=ENV_EXAMLLE_VALUE</span></span></code></pre></div><p>读取环境变量和普通变量的方式一样，使用美元符<code>$</code>。</p><p>不过，此时环境变量还没有永久生效，当重启后，自定义环境变量就就会被清除，要让自定义环境变量永久生效，一个常用的方式是将该行命令添加到<code>$HOME/.bashrc</code>。然后执行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>source $HOME/.bashrc</span></span></code></pre></div><p>这会立即生效，而无需重启或注销。</p><h3 id="普通变量和环境变量的区别" tabindex="-1">普通变量和环境变量的区别 <a class="header-anchor" href="#普通变量和环境变量的区别" aria-label="Permalink to &quot;普通变量和环境变量的区别&quot;">​</a></h3><p>普通变量和自定义环境变量本质上都是变量，声明和使用的方式一模一样，这两者的区别主要在于生命周期的不同。</p><ul><li>普通变量是临时的，只在此次使用shell时有用，下次使用shell（注销或重启后）就不存在了。</li><li>环境变量包括内置的和自定义的，是永久可以使用的。</li></ul><p>是否要将普通变量永久保存，也就是变为环境变量，取决于自己的实际需求。一般而言，需要重读多次使用的变量应该提升为环境变量，少数几次使用的则使用普通变量即可。</p><h1 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h1><h2 id="镜像和容器的概念区别" tabindex="-1">镜像和容器的概念区别 <a class="header-anchor" href="#镜像和容器的概念区别" aria-label="Permalink to &quot;镜像和容器的概念区别&quot;">​</a></h2><p>一个镜像只是一个压缩文件，这是一种模板，可以使用镜像实例化多个容器。一个容器表示具体的一个实例，有自己的生命周期，包括启动、停止、删除。</p><p>镜像好比操作系统安装文件，容器好比通过此文件安装到机器上并运行起来的操作系统。</p><h2 id="docker主要命令汇总" tabindex="-1">docker主要命令汇总 <a class="header-anchor" href="#docker主要命令汇总" aria-label="Permalink to &quot;docker主要命令汇总&quot;">​</a></h2><ul><li>docker create imageName：从镜像创建一个容器</li><li>docker start imageName ：从镜像启动一个容器，或重启一个运行的容器</li><li>docker run imageName ： 从镜像启动一个容器</li><li>docker pause container ：挂起，也叫暂停</li><li>docker stop containerName：停止容器</li><li>docker kill containerName：停止容器</li><li>docker restart containerName ：重启</li><li>docker rm containerName：删除</li><li>docker ps : 查看容器信息</li><li>docker image ls ：查看本地镜像列表</li></ul><h2 id="docker-run命令" tabindex="-1">docker run命令 <a class="header-anchor" href="#docker-run命令" aria-label="Permalink to &quot;docker run命令&quot;">​</a></h2><p>docker run 用来启动一个容器，优先从本地寻找镜像，如果本地找不到，则从远程仓库拉取。</p><ul><li><code>-d</code> 后台启动，并返回容器ID。</li><li><code>-i</code>： 交互模式运行容器</li><li><code>-P</code> ： 随机端口映射，容器内部端口映射到主机是随机端口</li><li><code>-p</code> ： 指定端口映射，格式为 <code>-p 主机端口:容器端口</code>，如果端口一样，可以只写一个</li><li><code>-t</code>： 为容器重新分配一个伪输入终端，通常与-i搭配：-it</li><li><code>--name</code> ： 指定容器名称</li><li><code>-v</code> 指定一个目录映射到本地某个文件夹</li></ul><h2 id="docker-build命令" tabindex="-1">docker build命令 <a class="header-anchor" href="#docker-build命令" aria-label="Permalink to &quot;docker build命令&quot;">​</a></h2><p>根据Dockerfile配置文件，创建一个镜像。</p><p>默认配置文件为项目目录下的Dockerfile文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t 镜像名称:tag  .</span></span></code></pre></div><p>最后的点号(.)表示将本目录下的所有文件打包成一个镜像，一定不能忽略。</p><h2 id="目录映射" tabindex="-1">目录映射 <a class="header-anchor" href="#目录映射" aria-label="Permalink to &quot;目录映射&quot;">​</a></h2><p>使用 <code>-v</code> 选项，可以将容器内的目录映射到本地主机，这样，两个目录下的内容始终是同步的。语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run -it -v 宿主机目录:容器目录</span></span></code></pre></div><h2 id="编写dockerfile文件" tabindex="-1">编写Dockerfile文件 <a class="header-anchor" href="#编写dockerfile文件" aria-label="Permalink to &quot;编写Dockerfile文件&quot;">​</a></h2><p>Dockerfile是构建镜像的配置文件，Docker依据Dockerfile文件逐行执行其中的命令，从而构建我们所需的镜像。</p><h3 id="from-获取基础镜像" tabindex="-1">FROM ： 获取基础镜像 <a class="header-anchor" href="#from-获取基础镜像" aria-label="Permalink to &quot;FROM ： 获取基础镜像&quot;">​</a></h3><p>FROM的作用是获取基础镜像，必须写且必须写在第一行。</p><p>FROM的格式为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FROM image:tag</span></span></code></pre></div><p>image是镜像名称，tag是版本标签，一般为数字或latest，如果不写默认为最新版。</p><h3 id="copy-复制本地文件到镜像" tabindex="-1">COPY：复制本地文件到镜像 <a class="header-anchor" href="#copy-复制本地文件到镜像" aria-label="Permalink to &quot;COPY：复制本地文件到镜像&quot;">​</a></h3><p>COPY 的作用是将本地文件复制到镜像内的虚拟目录。COPY的语法格式为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>COPY src1 src2 ...  dest</span></span></code></pre></div><p>src可以是文件或目录。dest是镜像的目标目录。不过，尽量不要将src写成文件夹，因为会复制整个目录的内容,包括文件系统元数据。</p><p>文件名支持使用通配符。</p><p>COPY命令的示例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>COPY  *.html  *.js  *.css  /opt</span></span></code></pre></div><p>复制文件还有一个命令是ADD。ADD和COPY都是复制，但由于COPY命令更透明，一般优先使用COPY。</p><h3 id="run-执行命令" tabindex="-1">RUN：执行命令 <a class="header-anchor" href="#run-执行命令" aria-label="Permalink to &quot;RUN：执行命令&quot;">​</a></h3><p>RUN的作用是在构建时执行一条或多条命令，例如通过yum或apt下载软件包。</p><p>需要特别指出的是，Dockerfile的每一行命令被执行后都会新增一层镜像。因此，最佳的做法是将RUN执行的多条命令合并在一行写，用&amp;&amp;连接，这样有助于减小最终镜像的体积。</p><p>RUN命令示例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RUN echo 1 &amp;&amp; echo 2</span></span></code></pre></div><h3 id="workdir-设置初始目录" tabindex="-1">WORKDIR ：设置初始目录 <a class="header-anchor" href="#workdir-设置初始目录" aria-label="Permalink to &quot;WORKDIR ：设置初始目录&quot;">​</a></h3><p>WORKDIR的作用是设置容器启动后的初始目录，类似于cd。此后的命令都将以此为工作目录。</p><h3 id="env-设置环境变量" tabindex="-1">ENV：设置环境变量 <a class="header-anchor" href="#env-设置环境变量" aria-label="Permalink to &quot;ENV：设置环境变量&quot;">​</a></h3><p>ENV的作用是设置环境变量，可以一次设置一个：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ENV key1=value1 key2=value2</span></span></code></pre></div><h3 id="cmd-容器启动后的初识命令" tabindex="-1">CMD ：容器启动后的初识命令 <a class="header-anchor" href="#cmd-容器启动后的初识命令" aria-label="Permalink to &quot;CMD ：容器启动后的初识命令&quot;">​</a></h3><p>从镜像开启容器实例后运行的初始命令，初始命令只能有一个。</p><p>CMD命令包括各选项参数用引号包裹，各个部分逗号隔开。例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CMD echo &quot;hello&quot;</span></span></code></pre></div><h1 id="ffmpeg" tabindex="-1">FFmpeg <a class="header-anchor" href="#ffmpeg" aria-label="Permalink to &quot;FFmpeg&quot;">​</a></h1><h2 id="基础使用" tabindex="-1">基础使用 <a class="header-anchor" href="#基础使用" aria-label="Permalink to &quot;基础使用&quot;">​</a></h2><h3 id="音视频基础知识" tabindex="-1">音视频基础知识 <a class="header-anchor" href="#音视频基础知识" aria-label="Permalink to &quot;音视频基础知识&quot;">​</a></h3><p>-r 1 每1秒1帧（1张图片） -r 25 1秒25张图</p><p>%05d.jpg 00001~99999.jpg</p><p>-preset 编码速度，越快，画质越低</p><p>-tune film为偏静态的视频，animation偏动态的视频。</p><p>影响画质的三大参数：编码格式、分辨率、码率。 码率的意思是每秒钟的比特数量，分辨率要和码率匹配。 对于h264 1080p来说，中码率6M，高码率8M，再大对画质提升不明显，过低会导致画质模糊。</p><p>帧率是影响流畅度的，跟画质无关。一般的视频为25或30帧，60帧的视频就已经非常流畅了，高于80帧则提升意义不大。</p><p>webp，网络传输的图片格式，由谷歌推出，优点是同等画质下，webp比jpg、png的体积更小。 webp还支持动图，最大分辨率可达到16383x16383，而gif只达到1024x1024。</p><h3 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h3><p>ffmpeg是一个免费轻巧的视频编辑命令行神器，可以使用一条命令转换格式、合并视频、剪辑片段、裁切画面、提取音频、添加字幕等。</p><p>去官网下载ffmpeg Windows程序，会在安装目录的bin下看到三个可执行文件：ffmpeg.exe、ffplay.exe、ffprobe.exe，将该目录添加到Path环境变量，就可以在命令行中使用命令了。使用<code>ffmpeg -version</code>检查是否安装设置成功。使用<code>ffmpeg -h</code>查看帮助。</p><h3 id="音视频基本概念" tabindex="-1">音视频基本概念 <a class="header-anchor" href="#音视频基本概念" aria-label="Permalink to &quot;音视频基本概念&quot;">​</a></h3><ul><li><p>编码器encoder、解码器decoder</p></li><li><p>比特率（帧率）bitrates</p></li><li><p>采样率</p></li><li><p>-vcodec ：指定视频编码方式，为copy表示不重新编码。</p></li><li><p>-acodec ：指定音频编码方式，为copy表示不重新编码。</p></li><li><p>-codec copy ： 音视频都不重新编码</p></li></ul><h2 id="能力集列表" tabindex="-1">能力集列表 <a class="header-anchor" href="#能力集列表" aria-label="Permalink to &quot;能力集列表&quot;">​</a></h2><h3 id="ffmpeg命令汇总" tabindex="-1">ffmpeg命令汇总 <a class="header-anchor" href="#ffmpeg命令汇总" aria-label="Permalink to &quot;ffmpeg命令汇总&quot;">​</a></h3><p>（1）通用参数：</p><ul><li>-fortmats ： 列出支持的文件格式</li><li>-codecs： 列出支持的编解码器</li><li>-f： 指定封装格式</li><li>-i filename： 输入文件名</li><li>-y： 覆盖已有文件</li><li>-t： 指定时长，以秒为单位，精确到毫秒</li><li>-map：指定映射关系。例如 <code>-map 1:0 -map 1:1</code> 表示将input1的第一个流和input2的第2个流输出。</li></ul><p>（2）视频参数</p><ul><li>-r ： 指定帧速率</li><li>-s size ：指定分辨率</li><li>-aspect aspect：指定长宽比。例如 4:3、16:9。</li><li>-croptop/cropbottom/cropleft/cropright size：设置顶部/底部/左边/右边切除尺寸，例如<code>-croptop 20px</code>。</li><li>-padtop/padbottom/padleft/padright size ： 设置顶部/底部/左边/右边补齐尺寸，例如<code>-padtop 20px</code>。</li><li>-padcolor color：补齐带颜色，范围000000-FFFFFF。例如<code>-pad #ff0000</code></li><li>-vn：取消视频</li><li>-an：取消音频输出</li></ul><h3 id="格式转换" tabindex="-1">格式转换 <a class="header-anchor" href="#格式转换" aria-label="Permalink to &quot;格式转换&quot;">​</a></h3><p>格式转换是最常使用的需求，如下示例将1.mp4转换成2.avi ：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -i  1.mp4  2.avi</span></span></code></pre></div><p>如果指定编码可以更快的完成格式转换：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -i 1.mp4 -c copy 2.avi</span></span></code></pre></div><p>说明，所有相关的操作中，加上 <code>-codec copy</code> 不会重新编解码所以会加快执行速度。</p><h3 id="截取视频片段" tabindex="-1">截取视频片段 <a class="header-anchor" href="#截取视频片段" aria-label="Permalink to &quot;截取视频片段&quot;">​</a></h3><p>截取视频片段主要涉及三个选项：</p><ul><li>-ss ：设置起始时间，格式为 <code>时:分:秒.毫秒 或秒数</code>，默认为开始00:00:00.000</li><li>-to ：设置结束时间，格式为<code>时:分:秒.毫秒 或秒数</code>，默认为视频结束。</li><li>-t ： 设置持续时间，单位为秒，精确到毫秒。</li></ul><p>注意：-to 和-t 不能同时使用。</p><p>例如，指定起始和终止时间：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpege</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.mp4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -ss</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 00:01:02.056</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 00:02:02.056</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -codec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2.mp4</span></span></code></pre></div><p>指定起始时间和持续时间段：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpege</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.mp4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   -ss</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 01:02:03.568</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -t</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  80.098</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   -codec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2.mp4</span></span></code></pre></div><h3 id="去掉音频或去掉视频" tabindex="-1">去掉音频或去掉视频 <a class="header-anchor" href="#去掉音频或去掉视频" aria-label="Permalink to &quot;去掉音频或去掉视频&quot;">​</a></h3><p><code>-an</code>选项表示取消音频输出：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  input.mp4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -an</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -vcodec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  output.mp4</span></span></code></pre></div><p><code>-vn</code> 选项表示去掉音频。 使用-vn选项取消视频输出，就可以提取音频了：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.mp4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -vn</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -acodec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   2.mp3</span></span></code></pre></div><h3 id="合并视频" tabindex="-1">合并视频 <a class="header-anchor" href="#合并视频" aria-label="Permalink to &quot;合并视频&quot;">​</a></h3><p>合并视频分两步。首先准备1个文本文件如1.txt存放要合并的文件名，内容示例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>file &#39;1.mp4&#39;</span></span>
<span class="line"><span>file &#39;2.mp4&#39;</span></span>
<span class="line"><span>file &#39;3.mp4&#39;</span></span></code></pre></div><p>然后执行如下命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg  -f  concat  -i 1.txt  -c copy output.mp4</span></span></code></pre></div><p>output.mp4就是合并后的文件。</p><h3 id="裁剪画面尺寸" tabindex="-1">裁剪画面尺寸 <a class="header-anchor" href="#裁剪画面尺寸" aria-label="Permalink to &quot;裁剪画面尺寸&quot;">​</a></h3><p>裁剪视频画面的语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1t.mp4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   -vf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  crop=w:h:x:y</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  2.mp4</span></span></code></pre></div><p>crop的参数，分表代表宽，高，起始x，起始y。 起点是视频的左上角。</p><p>示例如下；</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.mp4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -vf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   crop=2560:1440:0:0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   2.mp4</span></span></code></pre></div><h3 id="合并多个音频" tabindex="-1">合并多个音频 <a class="header-anchor" href="#合并多个音频" aria-label="Permalink to &quot;合并多个音频&quot;">​</a></h3><p>合并音频示例如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> input1.mp3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> input2.mp3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -filter_complex</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  amix=inputs=2:duration=shortest</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  output.wav</span></span></code></pre></div><p>duration=shortest表示按照长度较短的音频文件的长度作为输出的长度。</p><h3 id="调整音量" tabindex="-1">调整音量 <a class="header-anchor" href="#调整音量" aria-label="Permalink to &quot;调整音量&quot;">​</a></h3><p>将音量减半然后输出：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.wav</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -af</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;volume=0.5&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2.wav</span></span></code></pre></div><h3 id="音频淡入淡出" tabindex="-1">音频淡入淡出 <a class="header-anchor" href="#音频淡入淡出" aria-label="Permalink to &quot;音频淡入淡出&quot;">​</a></h3><p>音频淡入示例如下，<code>afade=t=in:ss:0:d=5</code>表示前5秒淡入音频：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.wav</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -filter_complex</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  afade=t=in:ss:0:d=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  2.wav</span></span></code></pre></div><p>音频淡出示例如下，<code>afade=t:out:st=200:d=5</code>表示从200秒开始，做5秒的淡出效果：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  input.wav</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -filter_complex</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  afade=t=out:st=200:d=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  output.wav</span></span></code></pre></div><h3 id="声音变速不变调" tabindex="-1">声音变速不变调 <a class="header-anchor" href="#声音变速不变调" aria-label="Permalink to &quot;声音变速不变调&quot;">​</a></h3><p>如下示例中，atempo=0.5表示按照0.5的速度输出，结果是长度将变为2倍。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ffmpeg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.mp3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -filter_complex</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   atempo=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   2.wav</span></span></code></pre></div><h3 id="ffplay的用法" tabindex="-1">ffplay的用法 <a class="header-anchor" href="#ffplay的用法" aria-label="Permalink to &quot;ffplay的用法&quot;">​</a></h3><p>播放</p><ul><li>播放视频：ffplay input.mp4。 按下s进入帧模式，按一次s就往前播放一帧。</li><li>播放音频：ffplay input.mp3 。</li><li>指定播放音量: ffplay -volumn 60 -i input.mp4</li><li>全屏播放：ffplay -i input.mp4 -fs</li></ul><p>设置播放窗口</p><ul><li>-window_title ：指定标题</li><li>-noborder：窗口无边框</li><li>-alwaysontop：窗口置顶</li><li><code>-left/top &lt;size&gt;</code>：播放窗口的位置</li><li><code>-x/y &lt;size&gt;</code>：设置播放窗口的宽度/高度</li></ul><h2 id="水印" tabindex="-1">水印 <a class="header-anchor" href="#水印" aria-label="Permalink to &quot;水印&quot;">​</a></h2><h3 id="文字水印" tabindex="-1">文字水印 <a class="header-anchor" href="#文字水印" aria-label="Permalink to &quot;文字水印&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -i  input.mp4 -vf &quot;drawtext=text=&#39;示例文本&#39;:fontsize=100:x=w/2:y=h/2:fontcolor=white@0.5:shadowy=2&quot;  output.mp4</span></span></code></pre></div><p>用冒号把参数都隔开。</p><ul><li>-vf： 表示设置视频滤镜（vf即video filter得缩写）</li><li>text： 文字内容</li><li>fontfile： 字体位置(C\:/windows/fonts/simhei.ttf)，汉字可以使用系统字体</li><li>fontcolor=white@0.5 ： 文字颜色，0.5表示不透明度</li><li>box=1： 添加白色背景的文本框，默认值0</li><li>boxcolor=black@0.5 ： 文字框背景颜色为黑色，0.5是不透明度</li><li>x、y：横纵坐标，以左上角为顶点，可使用t、w、h作为参数</li><li>enable=&#39;between(t,10,20)&#39; ： 表示第10秒到第20秒内显示</li></ul><p>如果要设置时间水印，设置text 的值：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>text=&#39;%{localtime\:%Y-%M-%d %H:%m:%S}</span></span></code></pre></div><h3 id="图片水印" tabindex="-1">图片水印 <a class="header-anchor" href="#图片水印" aria-label="Permalink to &quot;图片水印&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -i inputfile -vf  &quot;movie=marklogo.png,scale= 100:100[watermask]; [in] [watermask] overlay=x=50:y=50 [out]&quot; -y outfile</span></span></code></pre></div><ul><li>movie：添加滤镜，值为图片的路径</li><li>scale：水印图片大小，水印长度＊水印的高度</li><li>overlay：表示滤镜位置，从左上角开始计算</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -i input.mp4 -vf &quot;movie=input2.mp4,scale=200x200[inner];[in][inner]overlay=x=10:y=10[out]&quot; output.mp4</span></span></code></pre></div><p>movie=input2.mp4[inner] 用于设置过滤器，并命名为inner，可以随意命名。</p><p>movie的值可以是图片，也可以是视频。</p><p>scale用于设置画中画的宽高。</p><p>[in][inner]overlay=x=10:y=10[out] 将输入视频和名为inner的视频进行叠加，位置为（10,10）。in表示输入视频，out表示输出视频。</p><p>对于位置，如果要根据画面的宽高设置，可以使用如下内置变量：</p><ul><li>main_w : 表示输入视频的画面宽度</li><li>main_h : 表示输入视频的画面高度</li><li>overlay_w : 表示叠加视频的宽度</li><li>overlay_h : 表示叠加视频的高度</li></ul><p>文字跑马灯</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -i input.mp4 -vf &quot;movie=input2.mp4,scale=200x200[vedio_inner];[in][vedio_inner]overlay=x=mod(50*t,main_w):y=abs(sin(t))*main_h*0.7[out]&quot; output.mp4</span></span></code></pre></div><p>将 x 的值设置为 mod(50*t,main_w) 实现的是 每秒 向右移动 50 像素的执行效果。</p><p>设置 y 的值为 abs(sin(t))<em>main_h</em>0.7 , 这是在 y 方向以正弦函数进行运动。</p><h2 id="字幕" tabindex="-1">字幕 <a class="header-anchor" href="#字幕" aria-label="Permalink to &quot;字幕&quot;">​</a></h2><h3 id="字幕-1" tabindex="-1">字幕 <a class="header-anchor" href="#字幕-1" aria-label="Permalink to &quot;字幕&quot;">​</a></h3><p>载入ass字幕播放：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffplay -vf  subtitles=1.ass  1.mp4</span></span></code></pre></div><p>载入srt字幕播放：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -i input.mp4  -vf  &quot; subtitles=1.srt:force_style=&#39;Fontsize=20,PrimaryColour=&amp;HFFFFFF&amp;,marginV=50&#39; &quot; 1.mp4</span></span></code></pre></div><ul><li>subtites： 指定字幕文件</li><li>FontName：字体名称</li><li>FontSize：字体大小</li><li>Alignment：以数值表示的对齐方式。常见的中下为2、正中为10</li><li>PrimaryColour=&amp;HFFFFFF&amp;：字幕颜色，主要两边加&amp;</li><li>OutlineColor：边框颜色，&amp;后面的两位为透明度</li><li>MarginV：字幕距离底部的距离</li></ul><p>提取字幕文件（视频有字幕的前提下）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -i  1.mp4   -vf  subtitles=1.srt</span></span></code></pre></div><p>force_style常用参数如下：</p><h2 id="复杂滤镜" tabindex="-1">复杂滤镜 <a class="header-anchor" href="#复杂滤镜" aria-label="Permalink to &quot;复杂滤镜&quot;">​</a></h2><h3 id="常见的复杂滤镜" tabindex="-1">常见的复杂滤镜 <a class="header-anchor" href="#常见的复杂滤镜" aria-label="Permalink to &quot;常见的复杂滤镜&quot;">​</a></h3><ul><li>trim： 时间切片</li><li>drawtext：文字</li><li>subtitles： 字幕</li><li>crop： 画面裁切</li><li>scale： 画面缩放</li><li>concat： 前后拼接</li><li>rotate： 旋转画面</li><li>overlay ： 图片或视频水印- movie： 加载第三方视频</li></ul><h3 id="复杂滤镜的语法" tabindex="-1">复杂滤镜的语法 <a class="header-anchor" href="#复杂滤镜的语法" aria-label="Permalink to &quot;复杂滤镜的语法&quot;">​</a></h3><ul><li>分号： 操作大步骤</li><li>等号： 属性和值</li><li>冒号： 细分属性和值</li></ul><p>对于分号分隔的步骤，给一个自定义名称，指代中间步骤</p><p>[1:v]scale=176:144[logo] ; [0:v][logo]overlay=x=0:y=0</p><p>分成3个拷贝，分别操作 [0:v]split=3[tmp1][tmp2][tmp3];</p><p>[0:v] 第一个文件的视频流 [0✌️0] 第一个文件的第一个视频流</p><p>在滤镜的每一步之后，通常会指定一个步骤名称，便于map选取。</p><p>ffmpeg -i video.mkv -i image.png -filter_complex &#39;[0:v][1:v]overlay[out]&#39; -map &#39;[out]&#39; out.mkv</p><h3 id="subtitles字幕滤镜" tabindex="-1">subtitles字幕滤镜 <a class="header-anchor" href="#subtitles字幕滤镜" aria-label="Permalink to &quot;subtitles字幕滤镜&quot;">​</a></h3><ul><li>filename</li><li>force_style</li></ul><p>movie贴图滤镜</p><p>amovie 音频滤镜</p><h3 id="drawtext-文字滤镜" tabindex="-1">drawtext 文字滤镜 <a class="header-anchor" href="#drawtext-文字滤镜" aria-label="Permalink to &quot;drawtext 文字滤镜&quot;">​</a></h3><p>参数：</p><p>基本参数：</p><p>text: 必须。要绘制的文本内容。可以包含特殊字符和转义序列，如换行符 \n。</p><p>fontfile: 字体文件的路径。如果要使用非系统默认字体，需要指定此选项。</p><p>font: 字体名称。使用系统内建字体时，直接指定字体名称。可以包含样式信息，如 Arial Bold。</p><p>fontsize: 字体大小（单位：像素）。</p><p>fontcolor: 字体颜色。可以使用 0xRRGGBB、rgb(R,G,B)、rgba(R,G,B,A)、hexcolor、[0-100%]gray 或颜色名称（如 red）。</p><p>shadowcolor: 文本阴影的颜色。设置方式同 fontcolor。</p><p>shadowx, shadowy: 文本阴影相对于文本的横向和纵向偏移量（单位：像素）。</p><p>x, y: 文本在视频帧上的起始位置。可以使用绝对像素值，也可以使用相对表达式（如 w/2 表示视频宽度的一半）。</p><p>文本样式：</p><p>text_shaping: 开启（1）或关闭（0）文本形状优化，适用于阿拉伯语、希伯来语等从右向左书写系统的语言。</p><p>bordercolor, borderw: 边框颜色和宽度（单位：像素）。为文本添加边框。</p><p>boxcolor, box: 绘制背景矩形的颜色和是否开启（1）背景矩形。当开启时，可以配合 boxborderw（边框宽度）和 boxpadding（内部填充）使用。</p><p>alpha: 文本的透明度（0.0 - 1.0）。</p><p>shadowopacity: 文本阴影的透明度（0.0 - 1.0）。</p><p>动态效果：</p><p>timecode: 使用时间码作为文本内容。可以指定格式，如 <code>%{pts}</code> 或<code> %{localtime}</code>。</p><p>rate: 文本更新速率（帧率）。默认为视频帧率。</p><p>fixed_linesize: 固定行高，使多行文本保持一致的高度。</p><p>reload: 是否实时重载文本文件（当 textfile 参数用于指定文本文件时）。</p><p>高级选项：</p><p>expansion: 控制字符串的扩展方式，如 none、strftime（时间戳格式化）或 normal（默认，支持简单变量替换）。</p><p>textfile: 从文件中读取文本内容。支持按行读取，每行对应视频帧中的一个文本实例。</p><p>eof_action: 当文本文件读取到末尾时的行为，如 endall（停止播放）、repeat（从头开始循环读取）或 pause（暂停播放）。</p><p>text_length: 文本的最大长度。超过此长度的文本将被截断。</p><p>tabsize: 制表符宽度（单位：像素）。</p><p>wrapwidth: 自动换行的宽度限制（单位：像素）。超出此宽度的文本将被折行。</p><p>line_spacing: 行间距（单位：像素）。</p><p>kerning, letterspacing: 字间距调整（单位：像素）。</p><p>fontconfig_match: 使用 fontconfig 库进行字体匹配。对于复杂的字体配置，可以提高匹配准确度。</p><p>ass: 将 drawtext 参数解析为 ASS 字幕格式，支持更丰富的文本样式和动画效果。</p><p>表达式与函数：</p><p>许多参数（如 x, y, fontsize 等）支持使用数学表达式，可以包含以下函数：</p><p>rand(min,max): 返回指定范围内的随机数。</p><p>gte(a,b): 检查 a 是否大于等于 b，返回 1（真）或 0（假）。</p><p>lte(a,b): 检查 a 是否小于等于 b，返回 1（真）或 0（假）。</p><p>eq(a,b): 检查 a 是否等于 b，返回 1（真）或 0（假）。</p><p>if cond val_true val_false: 根据条件 cond 返回 val_true 或 val_false。</p><p>between(val,min,max): 检查 val 是否在 min 和 max 之间（包含边界），返回 1（真）或 0（假）。</p><p>isnan(val): 检查 val 是否为 NaN（Not-a-Number），返回 1（真）或 0（假）。</p><p>isinf(val): 检查 val 是否为无穷大或无穷小，返回 1（真）或 0（假）。</p><p>isnan_or_inf(val): 检查 val 是否为 NaN 或无穷大/小，返回 1（真）或 0（假）。</p><p>max(a,b,...), min(a,b,...): 返回一组数值中的最大值或最小值。</p><p>hypot(a,b): 计算直角三角形两条边长 a 和 b 的斜边长度。</p><p>round(val): 将 val 四舍五入到最接近的整数。</p><p>trunc(val): 截断 val 到整数部分，去掉小数点后的部分。</p><p>ceil(val): 向上取整，将 val 转换为大于或等于它的最小整数。</p><p>floor(val): 向下取整，将 val 转换为小于或等于它的最大整数。</p><p>rint(val): 朝最接近的整数取整，遵循 IEEE 754 规范。</p><p>sqrt(val): 计算 val 的平方根。</p><p>log(val[,base]): 计算 val 的自然对数（默认）或以 base 为底的对数。</p><p>exp(val): 计算 e（自然对数的底数）的 val 次幂。</p><p>overlay贴图滤镜 x y 可使用main_w、main_h、overlay_w、overlay_h</p><p>concat拼接</p><p>ffmpeg -i 1.mp4 -i 2.mp4 -i 3.mp4 -filter_complex &#39;[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] concat=n=3:v=1:a=1 [v] [a]&#39; -map &#39;[v]&#39; -map &#39;[a]’ output.mp4</p><p>[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] 分别表示第一个输入文件的视频、音频、第二个输入文件的视频、音频、第三个输入文件的视频、音频。</p><p>concat=n=3:v=1:a=1 表示有三个输入文件，输出一条视频流和一条音频流。[v] [a] 就是得到的视频流和音频流的名字。</p><p>movie=part1.mp4, scale=512:288 [v1] ; amovie=part1.mp4 [a1] ; movie=part2.mp4, scale=512:288 [v2] ; amovie=part2.mp4 [a2] ; [v1] [v2] concat [outv] ; [a1] [a2] concat=v=0:a=1 [outa]</p><p>part1.mp4缩放，步骤v1； part1.mp4 提取音频，步骤a1； part2.mp4缩放，步骤v2； part2.mp4提取音频，步骤a2； v2贴到v1上面，步骤outv； a2衔接到a1后面，输出0条视频流，1条音频流，步骤outa。</p><p>scale w 宽度 h 高度 iw、ih、</p><h3 id="crop" tabindex="-1">crop <a class="header-anchor" href="#crop" aria-label="Permalink to &quot;crop&quot;">​</a></h3><p>w h x y crop=w=100:h=100:x=12:y=34 也可以直接写 w:h❌y crop=100💯12:34 使用in_w、in_h、out_w、out_h内置变量</p><p>crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2 +((in_h-out_h)/2)*sin(n/7)</p><h3 id="select" tabindex="-1">select <a class="header-anchor" href="#select" aria-label="Permalink to &quot;select&quot;">​</a></h3><p>select=between(t,10,20)</p><p>ffmpeg -i input.mp4 -vf &quot;select=between(t,10,20)&quot; output.mp4 -y</p><h2 id="录屏" tabindex="-1">录屏 <a class="header-anchor" href="#录屏" aria-label="Permalink to &quot;录屏&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg  -f gdigrab -video_size 1920x1080 -i desktop -c:v h264  -b:v 10M -preset slower  -qscale 0.01 output.mp4 -y</span></span></code></pre></div><p>-f gdigrab</p><ul><li>framerate 帧率</li><li>-offset_x</li><li>-offset_y</li><li>-video_size</li><li>-i desktop</li><li>-i title=Calculator ：步骤标题为Calculator 的窗口 -preset slower 质量，slower表示质量较好 -qscale 0.01 压缩</li></ul><p>列出可用的音视频设备：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -list_devices true -f dshow -i dummy</span></span></code></pre></div><p>摄像头： ov9734_azurewave_camera 麦克风： Microphone (2- High Definition Audio Device) 扬声器： virtual-audio-capturer 桌面： desktop</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ffmpeg -f dshow -i video=“UScreenCapture”：audio=“Stereo Mix （Realtek High Definition Audio）” “C：\videos\out.mp4”</span></span></code></pre></div><p>如果要停止录制，请在 FFmpeg 命令提示符窗口中输入 q。</p><p>录音：</p><p>ffmpeg -f dshow -i audio=&quot;Microphone (2- High Definition Audio Device)&quot; output.wav</p><p>同时录屏与录音：</p><p>ffmpeg -f gdigrab -framerate 30 -i desktop -f dshow -i audio=&quot;Microphone (2- High Definition Audio Device)&quot; output.mp4</p><p>ffmpeg -f gdigrab -framerate 30 -i desktop -f dshow -i audio=&quot;Microphone (2- High Definition Audio Device)&quot; -i audio=&quot;virtual-audio-capturer&quot; output.mp4 -y</p><p>ffmpeg -f dshow -i audio=&quot;Microphone (2- High Definition Audio Device)&quot; -f dshow -i audio=&quot;virtual audio capturer&quot; -filter_complex amix=inputs=2:duration=first:dropout_transition=2 -f dshow -i video=&quot;screen-capture-recorder&quot; -y av-out.flv</p><h1 id="git" tabindex="-1">Git <a class="header-anchor" href="#git" aria-label="Permalink to &quot;Git&quot;">​</a></h1><h2 id="安装git" tabindex="-1">安装Git <a class="header-anchor" href="#安装git" aria-label="Permalink to &quot;安装Git&quot;">​</a></h2><p>要使用Git有两种方式：使用命令行和使用图形界面。笔者更推荐使用命令行工具，原因如下：</p><ul><li>命令行的命令是不变的、通用的，而图形界面有很多，或许我们碰到了一个更好的图形界面又要去再次学习，这是浪费精力的。</li><li>学习命令行能够让我们“知其所以然”，了解版本控制的核心原理。这条原则对其它的软件也同样适用。</li><li>命令行效率更高。很多人可能觉得图形界面的效率更高，其实不然，与其满屏幕的移动鼠标、寻找按钮，不如一行命令或一个脚本来得轻快。当然，这条原则对其它软件可能不适用。</li></ul><p>既然决定使用Git命令行，现在就需要安装Git了。</p><p>访问 <code>https://git-scm.com/ </code> ，在页面右下角会有一个醒目的 <code>Download for Windows</code> 按钮，点击下载安装包，然后一步步使用默认设置安装即可。</p><p><img src="https://s21.ax1x.com/2024/06/29/pkceOsO.png" alt="pkceOsO.png"></p><p>可以选择安装完整版或便携版，如果安装便携版，需要解压之后将git.exe所在的目录添加到PATH环境变量，不过由于我们之后会频繁的用到Git命令，所以更推荐安装完整版。</p><p>安装好Git之后，打开终端工具，输入如下几个命令检测是否安装成功：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git --help    # 查看帮助</span></span>
<span class="line"><span>git --version   # 查看git版本号</span></span></code></pre></div><p>如果没有错误信息，则表示安装成功。</p><h2 id="配置ssh登录" tabindex="-1">配置SSH登录 <a class="header-anchor" href="#配置ssh登录" aria-label="Permalink to &quot;配置SSH登录&quot;">​</a></h2><p>我们使用Git命令不可避免的要跟Github打交道。要将本地文件上传到Github的仓库，就需要身份鉴权，基于安全的考量，已经不推荐用户名密码的方式，而推荐SSH非对称秘钥的方式。</p><p>首先进入Bash环境，运行如下命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ssh-keygen -t rsa -C &quot;提示信息&quot;</span></span></code></pre></div><p>ssh-keygen常用选项如下：</p><ul><li><code>-f filename</code> ： 要保存的文件名，包含路径</li><li><code>-t</code> ： 秘钥类型，一般为rsa</li><li><code>-b</code> ： 指定秘钥长度，一般为2048或4096</li></ul><p>这里的提示信息可以随意写，一般为自己的邮箱。</p><p>运行上述命令后，终端会问你几个问题以进一步完成秘钥文件的生成，其它的可以直接回车以同意默认设置，最重要的是秘钥文件名，默认是<code>C:\Users\用户名/.ssh/id_rsa</code>，秘钥文件一般放在家目录，名称可以随便取。如果已经存在同名的秘钥文件记得要修改以免覆盖其它秘钥文件。我们这里使用默认设置。</p><p>然后就会在家目录生成两个文件： <code>id_rsa</code> 和 <code>id_rsa.pub</code>。</p><p>带有pub的是公钥文件，可以分发在网络上。另一个是私钥文件，一定不能泄露。</p><p>使用VSCode或记事本打开id_rsa.pub文件，内容只有一行，全选复制。</p><p>打开浏览器，输入 <code>https://github.com/settings/keys </code> ，点击右边的 <code>New SSH Key</code>，在Title文本框输入一些信息，在Key文本框粘贴我们刚刚复制好的公钥文本，点击 <code>Add SSH Key</code> ，至此ssh秘钥配置完成。</p><p>回到本地bash环境，运行如下命令，如果输出内部包含Successfully表示配置成功。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ssh -T git@github.com</span></span></code></pre></div><p>当然，第一次配置可能不会成功，遇到问题首先多尝试几次，然后将输出内容粘贴到搜索引擎以寻求其它实践者的经验。</p><p>另外，由于Github本身的不稳定性，有些时候可能需要一点科学方法才能连上。</p><h2 id="配置用户名和邮箱" tabindex="-1">配置用户名和邮箱 <a class="header-anchor" href="#配置用户名和邮箱" aria-label="Permalink to &quot;配置用户名和邮箱&quot;">​</a></h2><p>在以后提交到仓库的时候需要指定用户名和邮箱，这里提前进行全局设置，以后默认使用该身份。使用如下命令设置用户名和邮箱：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git config  --global  user.name &quot;姓名&quot;</span></span>
<span class="line"><span>git config  --global  user.email &quot;邮箱&quot;</span></span></code></pre></div><h2 id="git-bash" tabindex="-1">Git Bash <a class="header-anchor" href="#git-bash" aria-label="Permalink to &quot;Git Bash&quot;">​</a></h2><p>安装Git后默认会同时安装Git Bash，该工具提供了非常多开箱急用的Linux原生命令，例如cd、touch、vim、sed、grep等。如果要学习Linux Shell，就可以使用该工具。</p><p>进入Bash环境的方式有两种。第一种是在桌面或任意文件夹内右击，选择<code>Git Bash Here</code> ，这会以该文件夹为工作目录进入Bash环境。第二种是在任意终端输入<code>bash</code> 即可进入bash环境，工作目录保持不变。</p><p>在bash环境下，文件路径会使用Linux风格的 <code>/</code>，例如Windows风格的 <code>D:\test</code> 在bash环境下就是 <code>/d/test </code>。使用 <code>cd</code>切换工作目录时应该注意习惯的转换。</p><p>bash也支持家目录，使用 <code>cd ~</code>会回到用户的个人目录，其实是进入了Windows系统的 <code>C:\Users\用户名\</code> 文件夹。</p><h2 id="git的原理和-git-文件夹" tabindex="-1">Git的原理和 .git 文件夹 <a class="header-anchor" href="#git的原理和-git-文件夹" aria-label="Permalink to &quot;Git的原理和 .git 文件夹&quot;">​</a></h2><ul><li>工作区： 在这里开始编辑。</li><li>暂存区： 在修改文件后，通过git add 将修改添加到暂存区。暂存区的本质其实是要提交到仓库的文件列表。</li><li>存储库： 使用git commit -m &#39;提交说明&#39;， 从暂存区提交到仓库</li></ul><p>Git的本质直观表现上就是.git文件夹。</p><p>在克隆Github仓库的时候，默认会在本地新生成一个文件夹，文件夹名称就是仓库名。除了将仓库内的所有文件都拷贝到这个文件夹内以外，还有一个至关重要的动作，就是在新文件夹内包含一个隐藏文件夹——.git。</p><p>.git文件夹可以说就是Git的精华所在，该文件夹完整准确的记录了本地仓库所有的操作，包括修改、删除、新增等等。同时，还记录了分支名、远程仓库地址等等，所以，我们无需手动添加远程仓库地址，直接使用git push即可将本地的更改推送到Github。</p><h2 id="git-clone" tabindex="-1">git clone <a class="header-anchor" href="#git-clone" aria-label="Permalink to &quot;git clone&quot;">​</a></h2><p>git clone的作用是将仓库下载到本地，语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git clone https://github.com/用户/仓库.git</span></span></code></pre></div><h2 id="使用git-clone-而不是-git-init" tabindex="-1">使用git clone 而不是 git init <a class="header-anchor" href="#使用git-clone-而不是-git-init" aria-label="Permalink to &quot;使用git clone 而不是 git init&quot;">​</a></h2><p>由于大多数情况下我们是要将本地仓库推送到远程Github仓库，所以推荐先在Github初始化好仓库，然后拷贝仓库地址，使用git clone。因为这样在本地的.git文件夹内就已经包含了远程地址，之后在本地完成编辑和提交后直接使用git push就可以推送到克隆的那个仓库。</p><p>如果使用git init，就要事先使用git remote添加远程仓库，而且很容易造成本地仓库和远程仓库的冲突。</p><p>因此，推荐使用git clone而不是git init。</p><h2 id="git-add" tabindex="-1">git add <a class="header-anchor" href="#git-add" aria-label="Permalink to &quot;git add&quot;">​</a></h2><p>git add的作用是在编辑之后，将更改统一提交到暂存区：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span></code></pre></div><p>需要说明的是，在2.x版本之后，<code>git add .</code>和<code>git add -A</code>的作用是完全一样的。</p><h2 id="git-branch分支管理" tabindex="-1">git branch分支管理 <a class="header-anchor" href="#git-branch分支管理" aria-label="Permalink to &quot;git branch分支管理&quot;">​</a></h2><table tabindex="0"><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>git branch</code></td><td>查看本地分支，带<code>*</code>为当前本地分支</td></tr><tr><td><code>git branch -r</code></td><td>查看远程的分支，带<code>*</code>为当前远程分支</td></tr><tr><td><code>git branch xxx</code></td><td>新建一个名为xxx的分支</td></tr><tr><td><code> git checkout xxx</code></td><td>切换当前分支为xxx分支</td></tr><tr><td><code>git branch -m xxxx</code></td><td>将当前分支重命名为xxxx</td></tr><tr><td><code>git branch -b yyy</code></td><td>新建yyy分支并切换到新分支</td></tr><tr><td><code>git branch -d xxx</code></td><td>删除xxx本地分支</td></tr><tr><td><code>git branch -D xxx</code></td><td>强制删除xxx本地分支</td></tr></tbody></table><h2 id="远程仓库管理" tabindex="-1">远程仓库管理 <a class="header-anchor" href="#远程仓库管理" aria-label="Permalink to &quot;远程仓库管理&quot;">​</a></h2><table tabindex="0"><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>git remote</code></td><td>显示远程仓库</td></tr><tr><td><code>git remote -v</code></td><td>显示远程仓库的详细信息</td></tr><tr><td><code>git remote add origin 仓库url</code></td><td>新建远程仓库，origin只是命名习惯，可以任意取名，下同</td></tr><tr><td><code>git remote rm origin</code></td><td>删除远程仓库</td></tr><tr><td><code>git remote rename origin 新名称</code></td><td>重命名远程仓库</td></tr><tr><td><code>git push origin 本地分支:远程分支</code></td><td>将本地仓库的分支上传到远程仓库的分支</td></tr><tr><td><code>git push origin master</code></td><td>一般情况下，本地和远程仓库的分支名均为master，那么可以这样简写</td></tr><tr><td><code>git push --force origin 本地分支:远程分支</code></td><td>忽略其它的提交，强制推送，<code>--force</code>等同于<code>-f</code>，注意<code>--force</code>选项谨慎使用。</td></tr><tr><td><code>git pull</code></td><td>将本地的仓库与远程仓库对齐</td></tr></tbody></table><h2 id="git-commit" tabindex="-1">git commit <a class="header-anchor" href="#git-commit" aria-label="Permalink to &quot;git commit&quot;">​</a></h2><p>git commit 的作用是将暂存区的内容提交到本地仓库，语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git commit -m &#39;提交说明&#39;</span></span></code></pre></div><p>注意，这个提交说明一定要写，否则git不让提交。</p><h2 id="git-push" tabindex="-1">git push <a class="header-anchor" href="#git-push" aria-label="Permalink to &quot;git push&quot;">​</a></h2><p>git push的作用是将本地仓库推送到远程仓库，如果之前是用git clone下载下来的仓库，那么在.git文件夹会自动记录远程仓库的地址，那么可以直接运行如下命令推送到远程仓库：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git push</span></span></code></pre></div><p>如果之前是用git init 初始化的本地仓库，那么就需要使用git remote add 先添加远程仓库，一般名称为origin，然后运行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git  push  origin  master:master</span></span></code></pre></div><h2 id="个人项目git常用的命令" tabindex="-1">个人项目Git常用的命令 <a class="header-anchor" href="#个人项目git常用的命令" aria-label="Permalink to &quot;个人项目Git常用的命令&quot;">​</a></h2><p>对于个人项目，例如GitHub Pages静态博客页面，往往只需要先将仓库下载下来，然后修改，然后提交推送到Github，这时候不需要用到分支、标签等特性，常用的也就如下几个命令：</p><table tabindex="0"><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code> git clone 仓库url</code></td><td>克隆仓库到本地</td></tr><tr><td><code>git add . </code></td><td>将所有改动提交到暂存区</td></tr><tr><td><code>git commit -m &#39;提交说明&#39;</code></td><td>将暂存区提交到本地仓库</td></tr><tr><td><code>git push</code></td><td>将本地仓库同步到Github</td></tr></tbody></table><h2 id="查看提交历史" tabindex="-1">查看提交历史 <a class="header-anchor" href="#查看提交历史" aria-label="Permalink to &quot;查看提交历史&quot;">​</a></h2><p>查看提交历史包括两个命令：git log、 git reflog，这两个命令的区别是后者还记录了回退操作。</p><p>使用git reflog 输出关键信息，而且还包括退的记录，推荐使用。</p><p>要查看提交的历史，使用git log，这会从近到远依次列出每一次的提交。</p><p>还支持根据提交信息中的关键字来过滤提交历史。你可以使用--grep选项并指定要搜索的关键字。以下是使用该选项的示例命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git log --grep= &#39;关键字&#39;</span></span></code></pre></div><p>关键字支持通配符。</p><p>不过，git log输出的内容较多，第一次不会显示完整，往往需要按住空格以输出更多内容，按q退出输出。推荐使用git reflog。</p><h2 id="回退" tabindex="-1">回退 <a class="header-anchor" href="#回退" aria-label="Permalink to &quot;回退&quot;">​</a></h2><p>首先，使用git reflog列出提交记录，找到要回退的那条记录的commitID。</p><p>然后，使用git checkout命令回退到那次提交对应的状态：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>get checkout commitID</span></span></code></pre></div><h2 id="标签" tabindex="-1">标签 <a class="header-anchor" href="#标签" aria-label="Permalink to &quot;标签&quot;">​</a></h2><p>Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。</p><p>在 Git 中列出已有的标签非常简单，只需要输入 git tag。</p><p>你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git tag -l &quot;1.8.5*&quot;</span></span></code></pre></div><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的。推荐使用附注标签。</p><p>给某次提交打标签，并附上该标签的说明：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git tag -a v1.0 9fceb02 -m &quot;Release 1.0&quot;</span></span></code></pre></div><p>-a选项后接标签名称，其后接commitID，-m选项为该标签的附件说明。</p><h1 id="linux的进程和服务" tabindex="-1">Linux的进程和服务 <a class="header-anchor" href="#linux的进程和服务" aria-label="Permalink to &quot;Linux的进程和服务&quot;">​</a></h1><h2 id="服务" tabindex="-1">服务 <a class="header-anchor" href="#服务" aria-label="Permalink to &quot;服务&quot;">​</a></h2><h3 id="进程和服务的区别" tabindex="-1">进程和服务的区别 <a class="header-anchor" href="#进程和服务的区别" aria-label="Permalink to &quot;进程和服务的区别&quot;">​</a></h3><p>进程是程序正在运行的实例，是运行着的程序，每个进程都占用系统资源，包括内存、I/O 等。每个进程必须有唯一的进程ID，且在操作系统的进程管理器中也有对应的进程控制块（PCB）实体。</p><p>服务是在操作系统上运行的一种保持长期存在的非交互性进程，它主要负责提供特定的系统或网络服务，以便满足来自客户端的请求或负责某个定时任务的执行，使操作系统保持运行。</p><p>可以简单的理解为，进程一般是是暂时的、一次性的、前台执行的、用户直接交互的；而服务一般是持续性的、后台执行的、非交互性的。</p><h3 id="初始化系统的分类" tabindex="-1">初始化系统的分类 <a class="header-anchor" href="#初始化系统的分类" aria-label="Permalink to &quot;初始化系统的分类&quot;">​</a></h3><p>Linux所提供的持续性服务由守护进程实现，Linux将管理每一个守护进程的方法作为一个服务，并且使用了某一种初始化系统，也叫init系统，主流的init系统分为两种：</p><ul><li>Sysinit 源于20世纪80年代创建的传统init系统，目前，大多数老版本UNIX和Linux采用此init系统。</li><li>systemd 大多数Linux发行版的最新版本都采用了systemd作为 init系统，例如centos7.x及以后，Ubuntu15及以后。</li></ul><p>所以，应该将重点放在systemd上。</p><h3 id="systemd的单元、服务单元、目标单元" tabindex="-1">systemd的单元、服务单元、目标单元 <a class="header-anchor" href="#systemd的单元、服务单元、目标单元" aria-label="Permalink to &quot;systemd的单元、服务单元、目标单元&quot;">​</a></h3><p>systemd的主要任务是启动停止服务。Linux将管理的事项抽象成一个个单元（Units）。单元是一个由名称、类型和配置文件组成的组，专注于某一项服务。</p><p>在处理服务时，systemd分为服务单元和目标单元。</p><p>每个服务单元以.service结尾，每个目标单元以.target结尾。</p><p>列出所有的单元：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list-units</span></span></code></pre></div><p>列出所有的服务单元：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list-units</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  .service</span></span></code></pre></div><p>列出所有的目标单元：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list-units</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  .starget</span></span></code></pre></div><h3 id="systemd单元的配置文件" tabindex="-1">systemd单元的配置文件 <a class="header-anchor" href="#systemd单元的配置文件" aria-label="Permalink to &quot;systemd单元的配置文件&quot;">​</a></h3><p>每个单元对应若干配置文件。Linux单元配置文件位于/lib/systemd/system和/etc/systemd/system中。</p><p>列出所有的服务单元配置文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list-units-files</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --type=service</span></span></code></pre></div><p>列出所有的目标单元配置文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list-units-files</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --type=target</span></span></code></pre></div><p>显示sshd服务的单元配置文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /lib/systemd/system/sshd.service</span></span></code></pre></div><p>服务单元的配置文件主要包括：</p><ul><li>Description 描述</li><li>Documention 手册页</li><li>After 应该在哪些服务启动之后启动本服务</li><li>EnvironmentFile 服务配置文件</li><li>ExecStart 启动服务的命令</li><li>ExecReload 重载服务的命令</li><li>WantedBy 服务所属的目标单元</li></ul><h3 id="启停服务" tabindex="-1">启停服务 <a class="header-anchor" href="#启停服务" aria-label="Permalink to &quot;启停服务&quot;">​</a></h3><p>启动服务：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sshd.service</span></span></code></pre></div><p>停止服务：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sshd.service</span></span></code></pre></div><p>重启服务：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> restart</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sshd.service</span></span></code></pre></div><p>查看服务状态：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> status</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sshd.service</span></span></code></pre></div><h2 id="图形界面" tabindex="-1">图形界面 <a class="header-anchor" href="#图形界面" aria-label="Permalink to &quot;图形界面&quot;">​</a></h2><h3 id="x-window-system" tabindex="-1">X Window System <a class="header-anchor" href="#x-window-system" aria-label="Permalink to &quot;X Window System&quot;">​</a></h3><p>从英文字母看，X在W（Window）后面，所有称为X，有下一代窗口之意。在Unix-like上的图形用户接口（GUI）被称为X或X11。X11只是一个软件而不是操作系统。</p><p>X Window分为X Server和X Client两个组件。X Server管理硬件，X Client管理应用程序。</p><p>由于每个X Clinet是独立的，并不知道其它的X Clinet，这样就会造成GUI界面的显示冲突，所以使用X Window Manager进行管理。X Window Manger，也叫窗口管理器，是一个特殊的X Client，负责管理所有的应用程序GUI。著名的X Window Manager有GNOME、KDE。</p><p>随着技术的发展，X Window窗口管理系统正逐步被淘汰，而被新一代图形界面管理系统——Wayland取代。</p><p>X Window System使用C/S架构,服务端和客户端可以基于网络通信。</p><p>客户端(也就是各种软件)将绘图请求发给服务端,服务端操纵显卡或视频终端把位图图像绘制出来,并处理键盘鼠标的事件,发送给客户端.注意,和人交互的是服务端。</p><ul><li>服务端监听到显示器、鼠标、键盘事件，将事件信息（例如用户在哪个位置点了一下）发送给客户端，请求指示“此时应该怎么显示？”</li><li>客户端接收到该事件信息，计算出显示逻辑（例如在某个地方显示一个图形），将绘制指令发送给客户端。注意，客户端没有绘制能力，它只发送绘制指令。</li><li>服务端接收到绘制指令，然后调用图形API“画”出来（图形、文字等）。</li><li>窗口管理器协调各个客户端的堆叠等状态。</li></ul><p>为什么需要窗口管理器？因为多个客户端是层叠的，谁在前面谁在后面客户端自己是不知道的，只能在窗口管理器中汇总才能知道。</p><p>通俗点解释。</p><ul><li>服务端说： 用户在坐标(50,50)处点了一下，这种情况该怎么显示？</li><li>客户端说：这种情况应该在坐标（100，100）处画一个笑脸图形。</li><li>服务端说：收到！我马上派遣调用图形API在（100，100）出画一个笑脸图形。</li></ul><p>但这种情况只能同时显示一个gui程序。为了管理众多的窗口怎么在屏幕上显示,需要窗口管理器(Window manager).窗口管理器可以实现一个屏幕上显示多个X程序,实现调整程序大小,标题栏,最大化,最小化,关闭按钮,虚拟桌面这些功能.没有WM,一次只能运行一个GUI程序,而且分辨率锁死,显然很不符合使用习惯.</p><p>窗口管理器的例子：</p><ul><li>服务端对客户端A说： 我监听到用户在坐标(50,50)处点了一下，这种情况该怎么显示？</li><li>客户端A对窗口管理器说：我要在（50，50）处画一个笑脸。</li><li>服务端对客户端A说： 我监听到用户在坐标(80,150)处点了一下，这种情况该怎么显示？</li><li>客户端B对窗口管理器说：我要在（80，150）处写一段文本。</li><li>服务端对客户端C说：我监听到用户点击了全屏按钮，这种情况该怎么显示？</li><li>客户端C对窗口管理器说：用户让我全屏显示窗口，并且要在其它客户端的前面。</li><li>窗口管理器：你们的指令都收到了，我来汇总出一个总的绘制指令xxxxxxxx。</li><li>窗口管理器对服务端说：我的总绘制指令是xxxxxxx，你负责给我显示出来。</li><li>服务端：收到！我马上派遣驱动程序显示出来。</li></ul><h3 id="wayland" tabindex="-1">Wayland <a class="header-anchor" href="#wayland" aria-label="Permalink to &quot;Wayland&quot;">​</a></h3><p>Wayland将X中的Server和窗口管理器整合到一起作为服务端，称为合成器（Compositor），架构上只分了客户端和合成器两大部件。</p><ul><li>客户端（Wayland Client），直接计算各自界面的渲染缓冲数据，然后自行绘制，并通知server更新了哪个区域。</li><li>合成器（Wayland Compositor），汇总所有客户端的更新通知，实现各界面窗口“合成”，最后交给显示驱动绘图，呈现最终效果。</li></ul><p>client和server端都会发生绘制。client绘制本地的窗口内容，server端主要用于合成时渲染。两边都可独立选择用软件或者硬件渲染。</p><p>为什么需要通知server再次合成？因为多个客户端窗口一般是层叠的，谁在前面谁在后面客户端自己是不知道的，只有集中在server中处理层叠关系。</p><p>通俗解释：</p><ul><li>合成器对客户端A说： 我监听到用户在坐标(50,50)处点了一下</li><li>客户端A在（50，50）处直接调用图形API画了一个笑脸，然后对Server说 ：我现在通知你，左上角xx区域已经更新了。</li><li>合成器对客户端B说： 我监听到用户在坐标(80,150)处点了一下。</li><li>客户端B直接调用图形API在（80，150）处写一段文本，然后对Server说：我现在通知你你，区域yyyy已经被更新了。</li><li>合成器对客户端C说：我监听到用户点击了全屏按钮。</li><li>客户端C直接调用API重新绘制了全屏下的图形，然后对Server说：全屏区域已经更新了。</li><li>合成器说：你们的通知都收到了，我会汇总你们的更新，看看谁应该在前面显示谁应该被遮挡，然后派遣图形驱动重新合成一个最终的效果呈现给用户。</li></ul><p>总之，x Window的特点是，client是无法调用图形API，只能将指令发送给server，让server去调用图形API绘制。也就是说，x server成为了client和图形API的“传话筒”，但是为什么不让client与图形API直接通信呢？于是Wayland应运而生。Wayland先进的地方在于，每个client都可以自行调用图形API绘制自己的窗口，server汇总信息，调用图形API汇总最终的合成界面。</p><p>这里的图形API指的是OpenGL、Direct X、metal、vulkan，下面还有图形驱动程序，再下面就是显卡。Vulkan是一个高性能的图形API，Wayland插上Vulkan的翅膀一定会带来更大的性能提升。</p><h1 id="powershell" tabindex="-1">PowerShell <a class="header-anchor" href="#powershell" aria-label="Permalink to &quot;PowerShell&quot;">​</a></h1><h2 id="别名" tabindex="-1">别名 <a class="header-anchor" href="#别名" aria-label="Permalink to &quot;别名&quot;">​</a></h2><ul><li>Get-Alias 获取当前会话中的所有别名</li><li>New-Alias 创建新别名</li><li>Set-Alias 创建或更改别名</li><li>Remove-Alias 删除别名</li><li>Export-Alias 将一个或多个别名导出到文件</li><li>Import-Alias 将别名文件导入 PowerShell</li></ul><h2 id="获取内置别名-get-alias" tabindex="-1">获取内置别名：Get-Alias <a class="header-anchor" href="#获取内置别名-get-alias" aria-label="Permalink to &quot;获取内置别名：Get-Alias&quot;">​</a></h2><p>获取以p开头的别名：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-Alias</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span></code></pre></div><h2 id="创建别名" tabindex="-1">创建别名 <a class="header-anchor" href="#创建别名" aria-label="Permalink to &quot;创建别名&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>New-Alias -Name gas -Value Get-AuthenticodeSignature</span></span>
<span class="line"><span>Set-Alias</span></span></code></pre></div><h2 id="内置的常用别名" tabindex="-1">内置的常用别名 <a class="header-anchor" href="#内置的常用别名" aria-label="Permalink to &quot;内置的常用别名&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Get-Content</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Set-Location</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Copy-Item</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">del</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Remove-Item</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Get-ChildItem</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Write-Output</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Get-Content</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Get-Location</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Get-ChildItem</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Move-Item</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Remove-Item</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Set-Content</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Write-Output</span></span></code></pre></div><h2 id="具有参数的命令的备用名称" tabindex="-1">具有参数的命令的备用名称 <a class="header-anchor" href="#具有参数的命令的备用名称" aria-label="Permalink to &quot;具有参数的命令的备用名称&quot;">​</a></h2><p>可以将别名分配给 cmdlet、脚本、函数或可执行文件。 不能为命令及其参数分配别名。 例如，可以将别名分配给 Get-Eventlog cmdlet，但不能将别名分配给 Get-Eventlog -LogName System 命令。</p><p>这种情况的解决办法是：可以创建包含命令的函数。 若要创建函数，请键入单词“function”，后跟函数的名称。 键入命令，并将其括在大括号 ({}) 中。</p><p>##创建文件或文件夹 使用如下命令创建文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">New-Item</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.txt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ItemType</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">New-Item</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  2.txt</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 简写形式</span></span></code></pre></div><p>使用如下命令创建文件夹：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">New-Item</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  folder</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ItemType</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Directory</span></span></code></pre></div><p>使用-Force选项覆盖已存在的文件或文件夹。</p><h2 id="读取文本文件内容" tabindex="-1">读取文本文件内容 <a class="header-anchor" href="#读取文本文件内容" aria-label="Permalink to &quot;读取文本文件内容&quot;">​</a></h2><p>Get-Content 将从文件读取的数据视为数组，其中每行文件内容为一个元素。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr = Get-Content  .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.md  -encoding utf8</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 逐行输出文件的每行内容</span></span></code></pre></div><p>使用utf8是为了避免中文文件的乱码。</p><p>可以通过检查返回的内容的长度来确认此点：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Get-Content </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-Path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">oot.ini</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).Length</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">6</span></span></code></pre></div><p>如下命令将剪贴板读取到数组中：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr = Get-clipboard </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[0]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 第一行内容</span></span></code></pre></div><h1 id="多命令组合" tabindex="-1">多命令组合 <a class="header-anchor" href="#多命令组合" aria-label="Permalink to &quot;多命令组合&quot;">​</a></h1><h2 id="管道-1" tabindex="-1">管道 <a class="header-anchor" href="#管道-1" aria-label="Permalink to &quot;管道&quot;">​</a></h2><p>使用管道运算符将两个命令连接起来，管道符是一条竖线。注意，竖线两边必须有至少一个空格。管道的格式如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">命令1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  命令2</span></span></code></pre></div><h2 id="子命令" tabindex="-1">子命令 <a class="header-anchor" href="#子命令" aria-label="Permalink to &quot;子命令&quot;">​</a></h2><p>可以将命令的输出值赋给另一个变量而不是打印出来。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$files = ls</span></span></code></pre></div><p>如果存在空格，只需要用圆括号括起来即可：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $files = (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#得到后缀为txt的文件列表</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echo (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).length </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#输出后缀为txt的文件数量</span></span></code></pre></div><h2 id="单行多命令-1" tabindex="-1">单行多命令 <a class="header-anchor" href="#单行多命令-1" aria-label="Permalink to &quot;单行多命令&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cd </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Copy-Item命令的作用是复制文件或文件夹，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Copy-Item</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Destination</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2.txt</span></span></code></pre></div><p>如果文件已存在，则会失败，使用-Force选项覆盖：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Copy-Item</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Destination</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2.txt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Force</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">``</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">以下命令以递归方式将文件夹</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">emp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">est1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 复制到新文件夹</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">emp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">eleteMe：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">```</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Copy-Item</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">emp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">est1 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-Recurse</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">emp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">eleteMe</span></span></code></pre></div><p>下面的命令将 C:\data 中任意位置包含的所有 .txt 文件都复制到 C:\temp\text：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Copy-Item</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Filter</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> c:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ata</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Recurse</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Destination</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">emp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ext</span></span></code></pre></div><h2 id="工作目录" tabindex="-1">工作目录 <a class="header-anchor" href="#工作目录" aria-label="Permalink to &quot;工作目录&quot;">​</a></h2><p>打印工作目录</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-Location</span></span></code></pre></div><p>切换工作目录</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set-Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $HOME</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">esktop</span></span></code></pre></div><h2 id="相对路径和绝对路径" tabindex="-1">相对路径和绝对路径 <a class="header-anchor" href="#相对路径和绝对路径" aria-label="Permalink to &quot;相对路径和绝对路径&quot;">​</a></h2><p>相对有两个符号：</p><ul><li><code>.</code> 一个点号，当前目录</li><li><code>..</code> 两个点号，上级目录</li></ul><p>回到上一级：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set-Location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ..</span></span></code></pre></div><p>很多时候需要获取剪贴板的内容，PowerShell提供了内置的命令Get-Clipboard。</p><p>复制一段文本，运行如下命令在控制台输出剪贴板内容：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-Clipboard</span></span></code></pre></div><p>如下命令将剪贴板读取到数组中：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr = Get-clipboard </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[0]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 第一行内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[-1]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 最后一行内容</span></span></code></pre></div><p>使用h（Get-History的别名）获取历史记录。</p><h2 id="f7显示历史记录" tabindex="-1">F7显示历史记录 <a class="header-anchor" href="#f7显示历史记录" aria-label="Permalink to &quot;F7显示历史记录&quot;">​</a></h2><p>键入一个或多个字符，然后按 F8。 再次按 F8 会查找下一个实例。 <code>#text</code> Tab - 在历史记录中搜索 <code>text</code> 并返回最近的匹配项。 如果重复按 Tab，将循环访问历史记录中的匹配项。</p><p>使用Get-ChildItem列出目录下的文件列表，类似与Linux的ls命令。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-ChildItem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   C:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\ </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-ChildItem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">-Force</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #  显示隐藏项</span></span></code></pre></div><h2 id="使用通配符" tabindex="-1">使用通配符 <a class="header-anchor" href="#使用通配符" aria-label="Permalink to &quot;使用通配符&quot;">​</a></h2><p>可以使用通配符以便缩小文件列表范围。通配符主要有三种：</p><ul><li>表示任意数量的字符 ? 表示任意单个字符</li></ul><p>例如，若要在 当前文件夹中查找带有后缀 .md 并且基名称中正好有五个字符的所有文件，请输入以下命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-ChildItem</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ?????.md</span></span></code></pre></div><p>若要在 当前目录中查找以字母 x 开头的所有文件，请键入：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-ChildItem</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span></span></code></pre></div><p>若要在 当前目录中查找所有md文件，请键入：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-ChildItem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.md</span></span></code></pre></div><p>若要查找名称以“x”或“z”开头的所有文件，请键入：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get-ChildItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [xz]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span></span></code></pre></div><h2 id="删除文件和文件夹" tabindex="-1">删除文件和文件夹 <a class="header-anchor" href="#删除文件和文件夹" aria-label="Permalink to &quot;删除文件和文件夹&quot;">​</a></h2><p>使用如下命令删除文件和文件夹：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Remove-Item</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Remove-Item</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> folder</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Recurse</span></span></code></pre></div><p>在删除文件时默认需要二次确认是否删除，使用 -Recurse不询问。</p><p>在powershell中，一切皆对象。对象由三种类型的数据组成：对象类型、其方法和属性。</p><p>例如定义了一个字符串：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$str = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello,world&quot;</span></span></code></pre></div><p>使用如下命令查看该字符串对象的成员：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get-member</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  $str</span></span></code></pre></div><p>这会输出字符串对象的所有属性和方法。</p><p>Linux输出的结果是纯文本，而Powershell输出的结果为对象或包含对象的集合。</p><p>使用where-object命令从字段中筛选匹配的值，该命令的别名是where和?。</p><p>例如，get-alias的输出结果如下，有两个字段：CommandType和Name</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CommandType</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     Name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-----------</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ----</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Alias</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">           %</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ForEach-Object</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Alias</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">           ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  Where-Object</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">......</span></span></code></pre></div><p>要筛选出包含where的别名，可以使用：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>get-alias | where-object {$_.name -contains &quot;where&quot;}</span></span></code></pre></div><p>where-object会依次迭代集合中的每个对象，<code>$_</code>表示当前对象。</p><p>还可以省略$_ 和 花括号，如下是简写模式：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get-alias</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> where-object</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> name</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -contains</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;where&quot;</span></span></code></pre></div><p>还可以使用？作为别名，如下是最精简的方式：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get-alias</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> name</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -contains</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;where&quot;</span></span></code></pre></div><h2 id="out-host" tabindex="-1">out-host <a class="header-anchor" href="#out-host" aria-label="Permalink to &quot;out-host&quot;">​</a></h2><p>out-host是管道命令，接受管道前一部分传递过来的命令，然后将数据发送到主机窗口。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out-host</span></span></code></pre></div><p>注意，out-host只能作为管道命令，不能写在一行命令的开头。</p><h2 id="out-file" tabindex="-1">out-file <a class="header-anchor" href="#out-file" aria-label="Permalink to &quot;out-file&quot;">​</a></h2><p>out-file是管道命令，接收管道前一部分传递过来的命令，然后将数据保存到文件，如果本来应该显示在终端，则此时不会显示。例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out-file</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span></span></code></pre></div><p>由于中文可能会显示为乱码，很多时候需要使用特定的编码保存，如下示例使用utf8保存：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out-file</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1.txt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -encoding</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> utf8</span></span></code></pre></div><h2 id="创建数组" tabindex="-1">创建数组 <a class="header-anchor" href="#创建数组" aria-label="Permalink to &quot;创建数组&quot;">​</a></h2><p>有多种方式创建数组，如下示例所示：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$nums1 = 1,2,3     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 用逗号分割元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$nums2 = 1..3    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  创建1~3的数组，元素是1 2 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$nums3 = </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1,2,3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 推荐使用@()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$strs1=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;hello&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;world&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 元素为字符串的数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;hello&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;world&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">,1,2,3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 元素的类型不需要相同</span></span></code></pre></div><h2 id="读取文本文件到数组中" tabindex="-1">读取文本文件到数组中 <a class="header-anchor" href="#读取文本文件到数组中" aria-label="Permalink to &quot;读取文本文件到数组中&quot;">​</a></h2><p>上面几个例子是从无到有创建包含简单元素的数据，实际上，一个更常见的场景是从文本文件读入内容，即get-content命令。</p><p>get-content命令会读入文本内容，并返回一个数组，每一行就是一个元素。例如一个文本文件test.txt：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">world</span></span></code></pre></div><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $lines = (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get-content</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test.txt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $lines</span></span></code></pre></div><h2 id="访问数组元素" tabindex="-1">访问数组元素 <a class="header-anchor" href="#访问数组元素" aria-label="Permalink to &quot;访问数组元素&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr = </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1,2,3,4,5,6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 打印数组，分行输出 1 2 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[0]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 索引位置0也就是第1个元素 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[-1]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 最后一个元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[-2]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 倒数第二个元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[1..4]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  第2到第5个元素  2 3 4 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[1,4]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  第2个和第5个元素  2 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$a[-3..-1]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 最后3个元素  4 5 6 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$a[-1..-3]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  最后3个元素  6 5 4  ，注意与上一行的区别</span></span></code></pre></div><h2 id="修改数组" tabindex="-1">修改数组 <a class="header-anchor" href="#修改数组" aria-label="Permalink to &quot;修改数组&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr = </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1,2,3,4,5,6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr.SetValue(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">22,1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#   将索引位置1的值改为22</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr[1]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 22</span></span></code></pre></div><p>可以使用 += 运算符将元素添加到数组：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$a = </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1..4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$a += 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$a  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 1 2 3 4 5</span></span></code></pre></div><h2 id="数组的长度" tabindex="-1">数组的长度 <a class="header-anchor" href="#数组的长度" aria-label="Permalink to &quot;数组的长度&quot;">​</a></h2><p>使用数组的length和count属性得到数组的长度。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr = 1..9</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr.length   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  9</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr.count </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#   9</span></span></code></pre></div><h3 id="合并两个数组" tabindex="-1">合并两个数组 <a class="header-anchor" href="#合并两个数组" aria-label="Permalink to &quot;合并两个数组&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr1 = 1,2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr2 = 3,4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr = $arr1 + $arr2</span></span></code></pre></div><h2 id="迭代数组" tabindex="-1">迭代数组 <a class="header-anchor" href="#迭代数组" aria-label="Permalink to &quot;迭代数组&quot;">​</a></h2><p>使用foreach()函数迭代数组。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr = 1..9</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foreach ($element in $arr) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  $element    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 依次输出1-9</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="筛选数组" tabindex="-1">筛选数组 <a class="header-anchor" href="#筛选数组" aria-label="Permalink to &quot;筛选数组&quot;">​</a></h2><p>使用where{} 筛选数组，通过传递一个表达式，筛选出值为true或可以视为true的元素。</p><p>一般而言，如果表达式得到的结果是0，则视为false。</p><p>例如，筛选所有奇数元素：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0..9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.Where</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $_</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> }</span></span></code></pre></div><p>这里<code>$_</code>指代每次遍历的元素。</p><p>再比如，筛选出非空元素：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;hi&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;there&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.Where(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$_</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.Length}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="比较运算符" tabindex="-1">比较运算符 <a class="header-anchor" href="#比较运算符" aria-label="Permalink to &quot;比较运算符&quot;">​</a></h2><p>在命令行或脚本中经常会用到比较操作，比较操作主要分为数值的比较和文本的比较，返回True或False。</p><p>与bash shell使用中括号的语法不同，powershell直接书写比较参数和比较符号，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 2 -eq 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">True</span></span></code></pre></div><p>常见的比较运算符如下表所示：</p><table tabindex="0"><thead><tr><th>比较运算符</th><th>含义</th></tr></thead><tbody><tr><td>-eq</td><td>等于</td></tr><tr><td>-ne</td><td>不等于</td></tr><tr><td>-lt</td><td>小于</td></tr><tr><td>-le</td><td>小于等于</td></tr><tr><td>-gt</td><td>大于</td></tr><tr><td>-ge</td><td>大于等于</td></tr><tr><td>-like</td><td>相似（通配符比较）</td></tr><tr><td><code>-notlike</code></td><td>不相似，使用通配符</td></tr><tr><td><code>-contains</code></td><td><code>包含 </code></td></tr><tr><td><code>-notcontains</code></td><td>不包含</td></tr></tbody></table><p>注意，文本的比较默认不区分大小写。要区分大小写，需要加上c符号例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$str1 = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$str2 = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;HELLO&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$str1 -eq  $str2  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># True 默认不区分大小写  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$str1 -ceq  $str2  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># False  区分大小写</span></span></code></pre></div><h2 id="在powershell启动时运行的脚本" tabindex="-1">在PowerShell启动时运行的脚本 <a class="header-anchor" href="#在powershell启动时运行的脚本" aria-label="Permalink to &quot;在PowerShell启动时运行的脚本&quot;">​</a></h2><p>在Linux中，~/.bash_profile 和.bashrc 文件的作用是启动bash时预先执行一些命令。在Powershell中也可以实现这个功能。</p><p>首先打印$profile 变量获取启动脚本的路径：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$profile</span></span></code></pre></div><p>默认的输出结果是：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">C:\Users\你的用户名\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span></span></code></pre></div><p>按照这个路径新建.ps1脚本文件，如果目录或文件不存在就新建。</p><p>然后在该文件中输入启动时运行的命令即可。</p><p>字典是一种键值对的映射，有些说法也叫哈希表。</p><p>使用@符号加花括号创建一个字典：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$dic=@{name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">39</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $data</span></span></code></pre></div><p>如下示例访问字典的元素：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$dic[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 括号加引号访问键的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$dic.name  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 直接使用点号访问键的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$dic.keys    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 返回所有键</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$dic.values   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 返回所有值</span></span></code></pre></div><p>如下示例对字典进行增删改查：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$data.add(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;c&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">,1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 添加键c，值为1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$data[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]=4   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 添加键d，值为4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$data.containskey(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查找哈希表的键是否存在</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$data.remove(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#根据键删除元素</span></span></code></pre></div><p>cmdlet是PowerShell中特有的一个概念，可以简单的类比为bash shell中的命令，我们也可以使用命令这个称呼表示cmdlet。我们所说的命令，有时候指一行中的第一个单词，此时后面的部分称为选项和参数；有时候就指包括选项和参数的那一行命令。</p><p>与bash shell采用短单词的习惯不一样，cmdlet采取动-宾结构，例如get-childitem，优点是语义明确，缺点是冗长，对于习惯了Linux命令的用户和社区来说需要适应。</p><p>cmdlet的动词大致包括：</p><ul><li>get 读取</li><li>set 设置，写入，更改</li><li>add 添加，追加</li><li>clear 删除，清除</li><li>invoke 执行</li><li>where 查询</li><li>new 新建</li><li>copy/move 复制移动</li><li>out 重定向，通常位于管道符的后面</li><li>write 写入，输出</li><li>start/stop 开启/停止，例如开启/停止某个服务</li><li>remove 删除</li><li>import/export 导入导出</li><li>convert 格式转换</li></ul><p>PowerShell内置了对CSV文件的读取和写入。</p><h2 id="csv" tabindex="-1">CSV <a class="header-anchor" href="#csv" aria-label="Permalink to &quot;CSV&quot;">​</a></h2><p>例如有一个1.csv文件，内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>名称,数量</span></span>
<span class="line"><span>苹果,5</span></span>
<span class="line"><span>橘子,10</span></span>
<span class="line"><span>梨子,8</span></span></code></pre></div><p>如下命令读取CSV内容：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import-csv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1.csv</span></span></code></pre></div><p>这将按对象格式打印出CSV内容，PowerShell会自动识别首行作为字段名：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>名称 数量</span></span>
<span class="line"><span>---- ----</span></span>
<span class="line"><span>苹果 5</span></span>
<span class="line"><span>橘子 10</span></span>
<span class="line"><span>梨子 8</span></span></code></pre></div><p>如下示例打印每一行并且打印每个字段：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$rows = import-csv  1.csv</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$rows.length  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 3  有几条记录（排除第一行）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foreach （$row in $rows）{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $row   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 打印每一行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里的rows是一个数组，CSV中的每一行记录对应数组的一个元素。</p><h2 id="json" tabindex="-1">JSON <a class="header-anchor" href="#json" aria-label="Permalink to &quot;JSON&quot;">​</a></h2><p>PowerShell也内置对JSON文件的读取和写入。</p><p>使用如下命令从CSV转为JSON：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import-CSV</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   1.csv</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -delimiter</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;,&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  ConvertTo-Json</span></span></code></pre></div><h2 id="变量的声明和打印" tabindex="-1">变量的声明和打印 <a class="header-anchor" href="#变量的声明和打印" aria-label="Permalink to &quot;变量的声明和打印&quot;">​</a></h2><p>变量以美元符号$开头，后接一个等号，然后是变量值：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $a=1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $b = 2   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 空格可有可无，没有像bash shell那样严格</span></span></code></pre></div><p>打印变量使用 <code>$变量名</code>即可，也可以与bash shell一样使用echo，不过为了习惯统一，推荐使用echo。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $a=1  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $a</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echo $a</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span></span></code></pre></div><p>PowerShell能根据值自动确定变量的类型。</p><p>不过变量不存在而打印，powershell会报错：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; $foo</span></span>
<span class="line"><span>The varible &#39;$foo&#39; connot bebe retried because it has not been set.</span></span></code></pre></div><h2 id="字符串-1" tabindex="-1">字符串 <a class="header-anchor" href="#字符串-1" aria-label="Permalink to &quot;字符串&quot;">​</a></h2><p>使用单引号或双引号可以设置字符串的值：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $a = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  #单引号</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echo $a</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $b = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;world&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 双引号</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echo $b</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">world</span></span></code></pre></div><h2 id="变量内插" tabindex="-1">变量内插 <a class="header-anchor" href="#变量内插" aria-label="Permalink to &quot;变量内插&quot;">​</a></h2><p>但是这两种引号有很大的区别。如果引号中没有对其它变量的引用，那么两种引号均可，如果有，那么在双引号中使用变量会被解析成值，这就是变量内插，而在单引号则不会。这个规则与bash shell是一致的。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $name = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;welcome,${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">welcome,张三</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 双引号，存在变量的解析</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;welcome,${name}&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">welcome,$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{name}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 单引号，原样输出</span></span></code></pre></div><h2 id="布尔值" tabindex="-1">布尔值 <a class="header-anchor" href="#布尔值" aria-label="Permalink to &quot;布尔值&quot;">​</a></h2><ul><li><code>$true</code> 真</li><li><code>$false</code> 假</li></ul><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $isOk = $true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $isNotOk = $false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echo $isNotOk</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">True</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echo $isOk</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">False</span></span></code></pre></div><h2 id="数值" tabindex="-1">数值 <a class="header-anchor" href="#数值" aria-label="Permalink to &quot;数值&quot;">​</a></h2><h3 id="整数" tabindex="-1">整数 <a class="header-anchor" href="#整数" aria-label="Permalink to &quot;整数&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; $num = 2</span></span>
<span class="line"><span>&gt; echo $num1</span></span></code></pre></div><h3 id="浮点数-1" tabindex="-1">浮点数 <a class="header-anchor" href="#浮点数-1" aria-label="Permalink to &quot;浮点数&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; $num= 0.8</span></span>
<span class="line"><span>&gt; echo $num</span></span>
<span class="line"><span>0.8</span></span></code></pre></div><p>PowerShell中的函数可以整体执行几行命令，如下是一个简单的函数示例：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">esktop</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此后，执行如下命令就可以快速进入桌面目录：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cdd</span></span></code></pre></div><h2 id="没有参数的函数" tabindex="-1">没有参数的函数 <a class="header-anchor" href="#没有参数的函数" aria-label="Permalink to &quot;没有参数的函数&quot;">​</a></h2><p>定义语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 函数名</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">函数体</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> }</span></span></code></pre></div><p>执行语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">函数名</span></span></code></pre></div><h2 id="有参数的函数" tabindex="-1">有参数的函数 <a class="header-anchor" href="#有参数的函数" aria-label="Permalink to &quot;有参数的函数&quot;">​</a></h2><p>定义一个有参数的函数的语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 函数名</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([类型]$参数1,[类型]$参数2) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    函数体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>定义参数的类型不是必须的，如果不定义，那么不管传入的参数是什么类型，都始终将其视作字符串。</p><p>一个简单的带参数的函数示例如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($name,$age) {  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;姓名：</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">，年龄：</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$age</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>传参：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Info -name 张三 -age 39</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">姓名：张三，年龄：39</span></span></code></pre></div><h2 id="参数的默认值" tabindex="-1">参数的默认值 <a class="header-anchor" href="#参数的默认值" aria-label="Permalink to &quot;参数的默认值&quot;">​</a></h2><p>在函数定义时可以给参数一个默认值，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($name,$age=38) {  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;姓名：</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">，年龄：</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$age</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Info</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 张三</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##姓名：张三，年龄：38（age没有赋值，取默认）</span></span></code></pre></div><h2 id="for循环-2" tabindex="-1">for循环 <a class="header-anchor" href="#for循环-2" aria-label="Permalink to &quot;for循环&quot;">​</a></h2><p>示例语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($i=0; $i </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-lt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; $i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $i</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="foreach语句" tabindex="-1">foreach语句 <a class="header-anchor" href="#foreach语句" aria-label="Permalink to &quot;foreach语句&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$strs = </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;hello&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;world&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foreach($str in $strs){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $str</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="foreach-方法" tabindex="-1">foreach()方法 <a class="header-anchor" href="#foreach-方法" aria-label="Permalink to &quot;foreach()方法&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$strs = @(&#39;hello&#39;,&#39;world&#39;)</span></span>
<span class="line"><span>$strs.foreach({echo $_})</span></span></code></pre></div><p>这里比较重要的知识点是<code>$_</code>，代表每次跌倒时的值。</p><p>if语句以if关键字开头，后跟一对圆括号，其中写有条件。后跟一对花括号，其中写有满足条件时要执行的语句。如果语句比较简单，也可以省略花括号。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">if(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">条件</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 执行语句</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>if-else的格式</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">if(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">条件</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 执行语句</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}else{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 不满足条件时的执行语句</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>if-elseif-else格式：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">if(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">条件1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 执行语句</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}elseif(条件2){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 不满足条件1但满足条件2执行的语句</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}else{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #所有条件都不满足执行的语句</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">switch(表达式</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  值1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  值2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  值3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 没找到匹配时执行</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> }</span></span></code></pre></div><h2 id="内置变量" tabindex="-1">内置变量 <a class="header-anchor" href="#内置变量" aria-label="Permalink to &quot;内置变量&quot;">​</a></h2><ul><li><code>$null</code> 代表空值，将<code>$null</code>赋值给变量表示只创建该变量，但是不赋值。</li><li><code>$LASTEXITCODE</code> 调用外部程序时，运行结束后会返回一个退出码，0表示成功，非0表示发生错误。</li><li><code>$?</code>，最近一个命令的执行状态，为0为成功执行。</li><li><code>$_</code> 在管道对象中包含当前对象，在迭代时表示每次的迭代值。</li><li><code>$Home</code> 此变量用于表示用户主目录的完整路径</li><li><code>$IsLinux</code> 如果当前会话在Linux操作系统上运行，则此变量值为<code>True</code>，否则为<code>False</code>。</li><li><code>$IsWindows</code> 如果当前会话在Windows操作系统上运行，则此变量值为True，否则为False。</li><li><code>$PID</code> 此变量显示进程的PID，该进程正在托管当前PowerShell的会话。</li><li><code>$PSHome</code> 此变量表示Windows PowerShell安装目录的完整路径。</li><li><code>$PSVersionTable</code> 此变量用于表示只读哈希表，该哈希表显示有关当前会话中运行的PowerShell版本的详细信息。</li><li><code>$PROFILE</code> powershell配置文件的路径</li></ul><h2 id="内置环境变量" tabindex="-1">内置环境变量 <a class="header-anchor" href="#内置环境变量" aria-label="Permalink to &quot;内置环境变量&quot;">​</a></h2><p>使用<code>Get-ChildItem Env:</code>列出所有环境变量和它们的值。</p><p>一些内置的环境变量：</p><ul><li><code>$env：path</code>，常用，执行脚本和二进制命令时按顺序搜索的目录。</li><li><code>$env:temp</code>或<code>$env：tmp</code> 临时文件路径</li><li><code>$env:USERPROFILE</code> 指定当前用户的个人文件夹的路径</li></ul><p>使用如下语法读取或修改：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$env:变量名</span></span></code></pre></div><p>这里的env和变量名都不区分大小写。</p><h2 id="读取和修改path环境变量" tabindex="-1">读取和修改PATH环境变量 <a class="header-anchor" href="#读取和修改path环境变量" aria-label="Permalink to &quot;读取和修改PATH环境变量&quot;">​</a></h2><p><code>$env:PATH</code> 环境变量包含操作系统搜索可执行文件的文件夹位置列表。 在 Windows 上，文件夹位置列表由分号 (😉 字符分隔。</p><p>修改path环境变量：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$env:path = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$env</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:path;D:\Program Files\MyApp\bin&quot;</span></span></code></pre></div><p>或者使用简洁语法：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$env:path += </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;;D:\Program Files\MyApp\bin&quot;</span></span></code></pre></div><p>这里有两点需要注意：</p><ol><li>应该用管理员权限打开powershell</li><li>修改完要注销或重启才能生效</li></ol><h2 id="新增和修改自定义环境变量-1" tabindex="-1">新增和修改自定义环境变量 <a class="header-anchor" href="#新增和修改自定义环境变量-1" aria-label="Permalink to &quot;新增和修改自定义环境变量&quot;">​</a></h2><p>首先获取powershell的配置文件路径，没有就新建一个：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $profile</span></span></code></pre></div><p>在此文件中加入变量的声明，注销或重启即可。</p><h2 id="普通变量和环境变量的区别-1" tabindex="-1">普通变量和环境变量的区别 <a class="header-anchor" href="#普通变量和环境变量的区别-1" aria-label="Permalink to &quot;普通变量和环境变量的区别&quot;">​</a></h2><p>普通变量和自定义环境变量本质上都是变量，声明和使用的方式一模一样，这两者的区别主要在于生命周期的不同。</p><ul><li>普通变量是临时的，只在此次使用shell时有用，下次使用shell（注销或重启后）就不存在了。</li><li>环境变量包括内置的和自定义的，是永久可以使用的。</li></ul><p>是否要将普通变量永久保存，也就是变为环境变量，取决于自己的实际需求。一般而言，需要重读多次使用的变量应该提升为环境变量，少数几次使用的则使用普通变量即可。</p><p>从存储库（<code>https://www.powershellgallery.com/</code>）下载一个或多个模块，并将其安装到本地PowerShell中。</p><p>例如下载PSReadline模块：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Install-Module</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PSReadLine</span></span></code></pre></div><h2 id="psreadline" tabindex="-1">PSReadLine <a class="header-anchor" href="#psreadline" aria-label="Permalink to &quot;PSReadLine&quot;">​</a></h2><p>PSReadLine模块为powershell提供了历史记录的预测支持。使用方向键右，可以自动使用当前预测的历史命令。例如：</p><p><img src="https://img-blog.csdnimg.cn/20200711171032190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpZ21hcmlzaW5n,size_16,color_FFFFFF,t_70" alt="psreadline历史预测"></p><h2 id="以管理员身份运行" tabindex="-1">以管理员身份运行 <a class="header-anchor" href="#以管理员身份运行" aria-label="Permalink to &quot;以管理员身份运行&quot;">​</a></h2><p>在powershell点击右键，单击“以管理员身份打开”</p><h2 id="获取帮助" tabindex="-1">获取帮助 <a class="header-anchor" href="#获取帮助" aria-label="Permalink to &quot;获取帮助&quot;">​</a></h2><p>最好的学习方式是查看帮助，使用get-help命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get-help</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  命令名称</span></span></code></pre></div><h2 id="不区分大小写" tabindex="-1">不区分大小写 <a class="header-anchor" href="#不区分大小写" aria-label="Permalink to &quot;不区分大小写&quot;">​</a></h2><p>与bash shell不同，powershell命令名称和参数名称不区分大小写。</p><h2 id="提示符约定" tabindex="-1">提示符约定 <a class="header-anchor" href="#提示符约定" aria-label="Permalink to &quot;提示符约定&quot;">​</a></h2><p>为方便讲解，约定使用右尖括号（&gt;）作为命令输入提示符，该符号不需要输入，只需要复制该符号后面的命令导powershell命令行即可。</p><h2 id="注释" tabindex="-1">注释 <a class="header-anchor" href="#注释" aria-label="Permalink to &quot;注释&quot;">​</a></h2><p>与bash shell一样，powershell使用井号（#）注释，该符号后面的内容不会被执行。</p><h2 id="配置文件" tabindex="-1">配置文件 <a class="header-anchor" href="#配置文件" aria-label="Permalink to &quot;配置文件&quot;">​</a></h2><p>配置文件的路径保存在内置变量<code>$profile</code>中，默认为位置： <code>$HOME\Documents\WindowsPowerShell\Profile.ps1</code> ，没有就新建一个，这里可以写入启动powershell后预先执行的命令。</p><p>基于安全的考虑，PowerShell默认是不能执行脚本的，需要更改执行策略。</p><p>先以管理员方式运行PowerShell，输入如下命令行得到当前执行策略：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get-ExecutionPolicy</span></span></code></pre></div><p>输出为：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Restricted</span></span></code></pre></div><p>这表示执行脚本是受限的。</p><p>现在，使用如下命令修改执行策略:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set-executtionpolicy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> remotesigned</span></span></code></pre></div><p>此时终端会要求你输入一个字母确认你是否要更改执行策略，这里输入<code>Y</code>即可。</p><p>再次运行如下命令，可以发现执行策略依据更改完成：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get-executtionpolicy</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">输出：RemoteSigned</span></span></code></pre></div><p>在管理员权限下，PowerShell可以设置的执行策略有如下四种：</p><ul><li>restriced ： 受限，默认策略，不能执行脚本</li><li>allsigned ：只允许执行加密签名的脚本</li><li><strong>remotesigned</strong>：推荐，远程签名，允许执行自己编写的或下载的脚本</li><li>unrestricted ： 允许任何脚本</li></ul><p>select-string的功能类似于Linux的grep，用于在一个或多个文件中根据字符串查找匹配的行，并将改行的内容输出。</p><p>select-string的别名是sls。</p><ul><li>-Pattern 要查找的字符串，支持正则表达式。</li><li>-CaseSensitives，如果加上则区分大小写。默认不区分大小写。</li><li>-Path ：要查找的文件路径。</li></ul><p>例如，在文件file.txt中查找包含ex（不区分大小写）的行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sls</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Pattern</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ex</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><p>select-string还支持管道。例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ex</span></span></code></pre></div><h1 id="sed命令" tabindex="-1">sed命令 <a class="header-anchor" href="#sed命令" aria-label="Permalink to &quot;sed命令&quot;">​</a></h1><h2 id="sed命令语法" tabindex="-1">sed命令语法 <a class="header-anchor" href="#sed命令语法" aria-label="Permalink to &quot;sed命令语法&quot;">​</a></h2><p>sed命令语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   选项</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &#39;命令部分&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  文件</span></span></code></pre></div><p>常见的选项如下：</p><ul><li><p>-n : 只打印被sed处理的行，默认是处理后的结果，经常与p搭配。</p></li><li><p>-i : 默认情况下，会将待处理的文件内容拷贝到缓存中，处理之后输出到屏幕上，此时无论是删除，还是查找替换，都对源文件的内容没有任何影响。-i 选项直接修改原文件，而不在屏幕上输出。这种无损操作可以提前测试查找替换的结果，避免产生不可逆的修改。 sed最重要的是命令部分，命令部分又分为三个小部分：找到匹配的行、具体操作、可选的新增内容</p></li></ul><h2 id="找到匹配的行" tabindex="-1">找到匹配的行 <a class="header-anchor" href="#找到匹配的行" aria-label="Permalink to &quot;找到匹配的行&quot;">​</a></h2><p>要确定哪些行被找到，有两种方式:</p><ul><li><p>直接指定行，使用n1,n2表示第n1行到第n2行，不指定就是所有行被找到。</p></li><li><p>基于内容的查找，使用 /text/ 去查找text文本，支持正则表达式。通过这两种方式找到的行，进入下一步等待操作。</p></li></ul><p>上一部通过直接指定或查找的方式找到了待操作的行，这一步就要指定基于行的具体的操作，具体操作分为两大类：基于整行的操作、基于字符的操作。</p><p>基于整行的操作又分为打印、删除、追加、替换、插入。</p><h2 id="基于整行的打印" tabindex="-1">基于整行的打印 <a class="header-anchor" href="#基于整行的打印" aria-label="Permalink to &quot;基于整行的打印&quot;">​</a></h2><p>打印操作符是p，为了只打印需要的行，需要加上-n选项，否则会重复输出需要的行。</p><p>例如，打印前5行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1,5p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><p>打印所有行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 打印所有行</span></span></code></pre></div><p>打印包含“word”文本的行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /word/p</span></span></code></pre></div><p>打印前5行中包含“word”文本的行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1,5/word/p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><h2 id="基于整行的删除" tabindex="-1">基于整行的删除 <a class="header-anchor" href="#基于整行的删除" aria-label="Permalink to &quot;基于整行的删除&quot;">​</a></h2><p>删除的操作符是d，在匹配到行之后，使用如下操作删除：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  1,3d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  file.txt</span></span></code></pre></div><p>这行命令删除了前3行。</p><p>或者使用：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  /text/d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  file.txt</span></span></code></pre></div><p>这行命令将包含有“text”文本的行删除。</p><h2 id="基于整行的追加、插入和替换" tabindex="-1">基于整行的追加、插入和替换 <a class="header-anchor" href="#基于整行的追加、插入和替换" aria-label="Permalink to &quot;基于整行的追加、插入和替换&quot;">​</a></h2><p>基于整行的追加、插入、替换的指令分别是a、i、c。例如：</p><p>要在第一行前面加入新文本内容，运行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;1i new text&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><p>要在最后一行后面追加新内容，运行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  new text&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><p>这里$表示最后一行。</p><p>而要将第3行整行换成新内容，运行：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;3c   new text &quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  file.txt</span></span></code></pre></div><p>注意，由于后面的文本中出现了空格，故而上面这三个操作都是需要添加引号的，否则会被识别为命令行参数。</p><p>前面提到的替换操作是整行替换，sed还可以基于字符替换。</p><h2 id="基于字符的查找替换" tabindex="-1">基于字符的查找替换 <a class="header-anchor" href="#基于字符的查找替换" aria-label="Permalink to &quot;基于字符的查找替换&quot;">​</a></h2><p>基于字符的查找替换是sed最常见的操作。在找到行之后，使用<code>s/旧文本/新文本/g</code> 以执行基于字符的替换操作。这里的<code>g</code>表示行内全局替换，否则只替换找到的每行的第一个。例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> s/old/new/g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><p>上面这行命令将所有old文本替换成new文本。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1,5s/old/new/gi</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span></span></code></pre></div><p>上面这行命令将前5行的old文本替换成new文本，且忽略大小写。</p><p>值得提醒的的是，一般情况下使用 <code>s/旧文本/新文本/g</code> 进行替换，但这里的<code>/</code>可以换成其它字符，如果遇到文本中本来就包含<code>/</code>的情况，可以使用转义符号<code>\</code>转义，不过更加建议更换成其它字符，比如<code>*</code>。</p><p>例如，更换apt包管理器的软件仓库地址，以提升下载速度，而仓库地址包含<code>/</code>字符，此时，就可以使用：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  s</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">http://archive.ubuntu.com/ubuntu/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">https://mirrors.aliyun.com/ubuntu/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   /etc/apt/sources.list</span></span></code></pre></div><p>这里我们使用了<code>*</code>进行分隔。注意加<code>-i</code> 将修改应用到源文件。</p><h2 id="sed配合管道、重定向" tabindex="-1">sed配合管道、重定向 <a class="header-anchor" href="#sed配合管道、重定向" aria-label="Permalink to &quot;sed配合管道、重定向&quot;">​</a></h2><p>sed可以配合管道使用：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1,5p</span></span></code></pre></div><p>上面这行命令先显示文件的行号，然后打印前5行。</p><p>重定向的意思是把本来要输出到屏幕上的内容复制到新文件中，例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1,5p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new.txt</span></span></code></pre></div><p>上面这行命令将文件的前5行复制到new.txt中。</p><p>再比如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /文本/p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 文件</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new.txt</span></span></code></pre></div><p>这行命令将文件中包含word文本的那些行复制到new.txt中。</p><h1 id="下篇-服务器篇" tabindex="-1">下篇：服务器篇 <a class="header-anchor" href="#下篇-服务器篇" aria-label="Permalink to &quot;下篇：服务器篇&quot;">​</a></h1><h1 id="tcp-ip" tabindex="-1">TCP IP <a class="header-anchor" href="#tcp-ip" aria-label="Permalink to &quot;TCP IP&quot;">​</a></h1><ul><li><a href="#osi七层模型">OSI七层模型</a></li><li><a href="#tcpip">TCP/IP</a></li><li><a href="#传输层tcp与udp">传输层：TCP与UDP</a><ul><li><a href="#端口">端口</a></li><li><a href="#tcp-三次握手">TCP 三次握手</a></li><li><a href="#tcp的四次挥手">TCP的四次挥手</a></li></ul></li><li><a href="#http协议">HTTP协议</a><ul><li><a href="#请求报文与响应报文">请求报文与响应报文</a></li><li><a href="#简介">简介</a></li><li><a href="#报文结构">报文结构</a></li><li><a href="#状态码">状态码</a></li><li><a href="#url的结构">URL的结构</a></li><li><a href="#方案">方案</a></li><li><a href="#查询">查询</a></li><li><a href="#cookie">Cookie</a></li><li><a href="#basic认证">BASIC认证</a></li><li><a href="#digest认证">digest认证</a></li><li><a href="#https3">https/3</a></li><li><a href="#方法">方法</a></li><li><a href="#响应码">响应码</a></li></ul></li><li><a href="#dhcp">DHCP</a></li><li><a href="#dns">DNS</a></li><li><a href="#远程文件服务器ftp">远程文件服务器：ftp</a><ul><li><a href="#客户端连接">客户端连接</a></li><li><a href="#服务器配置">服务器配置</a></li></ul></li><li><a href="#网络文件系统nfs">网络文件系统：NFS</a></li><li><a href="#网络层ip层">网络层（IP层）</a><ul><li><a href="#五类ip地址">五类IP地址</a></li><li><a href="#路由">路由</a></li><li><a href="#nat网络地址转换">NAT（网络地址转换）</a></li></ul></li><li><a href="#远程连接服务器ssh">远程连接服务器：SSH</a></li><li><a href="#oauth">OAuth</a><ul><li><a href="#github-授权">Github 授权</a></li><li><a href="#access-token">Access Token</a></li><li><a href="#微信授权">微信授权</a></li><li><a href="#github授权登陆流程">Github授权登陆流程</a></li><li><a href="#微信授权登陆流程">微信授权登陆流程</a></li></ul></li><li><a href="#加密协议">加密协议</a><ul><li><a href="#加密算法的分类">加密算法的分类</a></li><li><a href="#非对称秘钥的文件位置和内容">非对称秘钥的文件位置和内容</a></li><li><a href="#非对称加密传递信息">非对称加密传递信息</a></li><li><a href="#数字证书和数字签名">数字证书和数字签名</a></li><li><a href="#ssh">ssh</a></li><li><a href="#ssh-keygen">ssh-keygen</a></li><li><a href="#ssh-copy-id">ssh-copy-id</a></li></ul></li></ul><h2 id="osi七层模型" tabindex="-1">OSI七层模型 <a class="header-anchor" href="#osi七层模型" aria-label="Permalink to &quot;OSI七层模型&quot;">​</a></h2><p>将网络分为几个层次，每个层次都有特定独立的功能，每层独立实现、互不干扰。这就是TCP/IP的基础——OSI七层网络协议。</p><ul><li>第一层 物理层</li></ul><p>由于网络传输介质只能传送0与1这种比特位，因此物理层必须定义所使用的传输设备的电压与信号灯，同时还必须了解数据帧转换成比特流的编码方式，最后连接实际传输介质并发送/接收比特信号。</p><ul><li>第二层 数据链路层</li></ul><p>这一层是比较特殊的一个层，因为其下层都是实体的定义，而其上层则是软件封装的定义。因此第二层又分为两个子层进行数据的转换操作。在偏硬件部分，主要负责的MAC（Media Access Control），我们称这个数据包裹为MAC数据帧（frame），MAC是网络接口设备所能处理的主要数据包裹，这也是最终被物理层编码成比特流的数据。MAC必须要经过通信协议来取得网络介质的使用权，目前最常使用的则是IEEE 802.3的以太网络协议。 至于偏向软件的部分则是由逻辑链路层（Logical Link Control，LLC）所控制，主要在多任务处理来自上层的数据包数据（packet）并转成MAC的格式，负责的工作包括信息交换、流量控制、失误问题的处理等。</p><ul><li>第三层 网络层</li></ul><p>这一层就是IP（Internet Protocol）层，即路由协议层。同时也定义出计算机之间的连接建立、终止与维持、数据包的传输路径选择等。</p><ul><li>第四层 传输层</li></ul><p>这一个分层定义了发送端与接收端的连接技术（如TCP、UDP技术），同时包括该技术的数据包格式、数据包的发送、流程的控制、传输过程的侦测检查与重新传送等，以确保各个资料数据包可以正确无误的到底目的端。</p><ul><li>第五层 会话层</li></ul><p>在这个层次当中主要定义了两个地址之间的连接信道的连接与中断，此外，也可建立应用程序之间的会话、提供其他加强型服务如网络管理、建立与断开、会话控制等。如果说传输层是在判断数据包是否可以正确的到达目标，那么会话层则是在确定网络服务建立连接的确认。</p><ul><li>第六层 表示层</li></ul><p>我们通过应用程序生成出来的数据格式不一定符合网络传输的标准编码格式，所以，在这个层次当中，主要的操作是：将来自本地端应用程序的数据格式转换（或者重新编码）为网络的标准格式，然后再交给下面的传输层等的协议来进行处理。所以，在这个层次上面主要定义的是网络服务（或程序）之间的数据格式的转换，包括数据的加解密也是在这个层次上处理。</p><ul><li>第七层 应用层</li></ul><p>应用层本身不属于应用程序所有，而是在定义应用程序如何进入该层的沟通接口，以将数据接收或发送给应用程序，并最终展示给用户。</p><h2 id="tcp-ip-1" tabindex="-1">TCP/IP <a class="header-anchor" href="#tcp-ip-1" aria-label="Permalink to &quot;TCP/IP&quot;">​</a></h2><p>不过，事实上，OSI七层协议只是一个参考的模型，目前并没有什么知名的操作系统严格按照OSI七层协议实现。不过，OSI七层模型可以认为是TCP/IP的简化模型，将原来的七层简化为四层，实际的互联网程序代码都是基于TCP/IP模型。OSI七层协议与TCP/IP协议的对应关系如下：</p><ul><li>将最底下两层（物理层和链路层）简化为一层——网络接口层</li><li>OSI的网络层还是对应TCP/IP的网络层</li><li>OSI的传输层还是对应TCP/IP的传输层</li><li>将最上三层（会话层、表示层、应用层）简化为一层——应用层</li></ul><p>TCP/IP每层的相关通信协议与标准如下：</p><ul><li>网络接口层：WAN、LAN、ARP</li><li>网络层：IP、ICMP</li><li>传输层：TCP、UDP</li><li>应用层：HTTP(s)、FTP、SMTP、POP3、NFS、SSH</li></ul><p>拿一个访问网页的例子来演示TCP/IP协议的工作：</p><ul><li>应用程序阶段：打开浏览器，在地址栏输入网址，按下回车。此时网址信息与相关数据会被浏览器打包成一个数据包，向下传给应用层。</li><li>应用层：由应用层提供的HTTP通信协议，将来自浏览器的数据封装起来，并给予一个应用层报头，再向传输层丢去。</li><li>传输层：由于HTTP为可靠连接，因此将该数据包丢入TCP封装内，并给予一个TCP封装的报头，向网络层丢去。</li><li>网络层：将TCP数据封装到IP数据包内，再给予一个IP报头（主要就是来源于目标的IP），向网络接口层丢去。</li><li>网络接口层：如果使用以太网络事，此时IP会依据CSMA/CD的标准，封装到MAC数据帧中，并给予MAC帧头，再转成比特流后，利用传输介质发送到远程主机上。</li><li>等到目的主机收到数据包后，再以相反的方向拆解开头，每次交给对应的层次进行分析，最后WWW服务器软件获知你想要的数据，再取得正确的资料后，又遵循上述流程，一层一层的封装起来，最后传送到你的浏览器上。</li></ul><h2 id="传输层-tcp与udp" tabindex="-1">传输层：TCP与UDP <a class="header-anchor" href="#传输层-tcp与udp" aria-label="Permalink to &quot;传输层：TCP与UDP&quot;">​</a></h2><h3 id="端口" tabindex="-1">端口 <a class="header-anchor" href="#端口" aria-label="Permalink to &quot;端口&quot;">​</a></h3><p>我们都知道IP数据包的传送的起点和终点是IP地址，那么达到后具体应该连接到哪里去呢？一台主机可以部署多个服务，那么是连接到WWW服务器，还是FTP服务呢？这就需要通过端口区分不同的服务，一个特定的服务由两部分组成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>地址:端口</span></span></code></pre></div><p>地址可以是IP地址，也可以是主机名称。</p><p>端口的取值范围为0-65535，不过，0-1023已经分给了常用的应用程序，因此一般的取值范围是1024~65535。</p><p>常见的服务与端口的对应如下：</p><table tabindex="0"><thead><tr><th>服务</th><th>端口</th></tr></thead><tbody><tr><td>20</td><td>FTP</td></tr><tr><td>22</td><td>SSH 安全远程连接服务</td></tr><tr><td>25</td><td>SMTP 简单邮件传递协议</td></tr><tr><td>80</td><td>HTTP，超文本传输协议服务</td></tr><tr><td>110</td><td>POP3 邮件接收协议</td></tr><tr><td>443</td><td>HTTPS 安全加密的HTTP服务</td></tr><tr><td>3306</td><td>MySQL 默认端口号</td></tr></tbody></table><h3 id="tcp-三次握手" tabindex="-1">TCP 三次握手 <a class="header-anchor" href="#tcp-三次握手" aria-label="Permalink to &quot;TCP 三次握手&quot;">​</a></h3><p><img src="https://pics4.baidu.com/feed/1ad5ad6eddc451da91dfe64756fd5b6bd016327a.jpeg@f_auto?token=6a788b3425a128f386466dad924ccf99" alt="TCP的三次握手"></p><p>在TCP的连接模式中，在建立连接之前都必须通过三个确认的动作，所以这种连接方式也被称为三次握手，大致分为四个阶段。</p><ul><li><p>第一阶段，数据包发起 当可以的想要对服务器端连接时，就必须要送出一个要求连接的数据包，此时客户端必须随机取用一个大于1024的空闲的端口来作为程序沟通的接口。然后再TCP的报头当中，必须要带有SYN的主动连接（SYN=1），并且记下发出连接数据包给服务器端的序号（Sequence number = 10001）。</p></li><li><p>第二阶段，数据包接收与确认数据包发送 当服务器接收到这个数据包，并且确定要接收这个数据包后，就会开始制作一个同时带有SYN=1，ACK=1 的数据包，其中那个Acknowledge的号码是要给Client端确认用的，所以该数字会比A步骤里面的Sequence号码多一号（ack=10001+1=10002），那服务器也必须确认客户端确实可以接收我们的数据包才行，所以也会发送出一个Sequence（seq=20001）给客户端，并且开始等待客户端与服务器端的回应。</p></li><li><p>第三阶段，回送确认数据包 当客户端收到来自服务器端的ACK数字（10002）后，就能确认之前那个请求连接的数据包被正确接收了，接下来如果客户端也同意与服务器建立连接时，就会再次发送一个确认数据包（ACK=1）给服务器，即Acknowledge = 20001+1 = 20002.</p></li><li><p>第四阶段 取得最后确认 若一切都顺利，在服务器端收到带有ACK=1 且ack = 20002序号的数据包后，就能够建立起这次的连接了。</p></li></ul><p>举个通俗得了例子，好比两个人A和B在谈论事情之前打招呼：</p><ul><li>A说： B你听得到吗？</li><li>B说：我听得到，A你听得到吗？</li><li>A说：我也听得到</li></ul><p>可能有的人会有疑问，为什么B要再次询问一遍呢？B收到消息后直接建立连接不行吗？假设A说中文但听不懂英文，B说英文也可以听懂中文，这时候直接建立后A是听不懂的，必须要保证双方都能听懂对方说的话才行。</p><p>那为什么不来回更多次呢？理论上也是可以的，不过，为了节省资源，只需要双方都说一次，然后确认对方听懂了就够了。</p><p>总之，三次握手就是要确认两件事：</p><ul><li>服务端能有效识别客户端的信息</li><li>客户端能有效识别服务端的信息</li></ul><h3 id="tcp的四次挥手" tabindex="-1">TCP的四次挥手 <a class="header-anchor" href="#tcp的四次挥手" aria-label="Permalink to &quot;TCP的四次挥手&quot;">​</a></h3><p><img src="https://pics1.baidu.com/feed/c8177f3e6709c93d3b2db2957e3df1d1d0005486.jpeg@f_auto?token=d1003b5bd35811075409c512e0503094" alt="TCP的四次挥手"></p><p>TCP的四次挥手是为了结束已建立的连接，确保双方都能正确地关闭连接并释放资源。下面是四次挥手的过程：</p><ul><li><p>第一次挥手：客户端发送一个带有FIN（结束）标志的数据包，表示自己已经没有数据要发送了，请求关闭连接。</p></li><li><p>第二次挥手：服务器接收到客户端的结束请求后，会发送一个带有ACK（确认）标志的数据包作为响应，表示已收到客户端的结束请求。</p></li><li><p>第三次挥手：服务器发送一个带有FIN标志的数据包，表示自己也没有数据要发送了，请求关闭连接。</p></li><li><p>第四次挥手：客户端接收到服务器的结束请求后，会发送一个带有ACK标志的数据包作为确认，表示已收到服务器的结束请求。</p></li></ul><p>在关闭连接时，需要确保双方都完成了数据的传输和接收，以防止数据丢失或错误。如果只有三次挥手，可能会导致一些问题。</p><p>假设只有三次挥手，当客户端发送结束请求后，服务器收到后会发送确认，表示已收到客户端的结束请求。但是在此过程中，服务器可能还有未发送完的数据，如果直接关闭连接，那么这些数据就会丢失。因此，引入第三次挥手，服务器在发送结束请求前，先发送所有未发送完的数据，并等待客户端的确认。客户端接收到服务器的结束请求后，会确认并处理完未接收的数据，然后发送确认，表示自己已准备好关闭连接。</p><p>通过四次挥手，可以确保双方都能正确地结束连接，并处理未发送和未接收的数据，保证数据的完整性和可靠性。因此，关闭连接需要四次挥手。</p><h2 id="http协议" tabindex="-1">HTTP协议 <a class="header-anchor" href="#http协议" aria-label="Permalink to &quot;HTTP协议&quot;">​</a></h2><h3 id="请求报文与响应报文" tabindex="-1">请求报文与响应报文 <a class="header-anchor" href="#请求报文与响应报文" aria-label="Permalink to &quot;请求报文与响应报文&quot;">​</a></h3><p>客户端发送请求报文，服务器返回响应报文，报文有一定的格式约定，将格式约定好以便于发送和解析，这既是协议。</p><p>要查看报文实例，最好的方法是使用浏览器。</p><p>使用Edge浏览器，打开百度首页，按F12进入开发者工具，切换到网络选项卡，这时候应该有很多网络传输记录。</p><p>在右边的表头选项卡，我们能看到“常规”、“响应标头”、“请求标头”。这就是报文的内容。</p><p>我们解释几个典型的参数。</p><ul><li>请求URL：这就是我们常说的链接，只有通过链接才能拿到资源如HTML页面、文件、图片、视频。</li><li>请求方法：一般为GET，表示向服务器拿资源。开发中会用到POST表示携带正文向服务器发送。</li><li>状态代码：表示是成功还是错误，如果是200 OK表示成功返回了正确的资源。如果是4或5开头的代码，表示有错误。</li><li>远程地址：服务器的IP地址，这个地址是DNS系统通过解析之后得到的机器能够理解的地址。</li><li>请求标头：请求报文的头部，是对请求报文的概括和描述，如协议版本、能接受的编码等。</li><li>响应标头：响应报文的头部，是对响应报文的概括和描述，如字节大小等。</li></ul><h3 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h3><p>一般而言，网络传输的两端分为客户端和服务器。请求数据的叫做客户端，浏览器就是典型的客户端。接收请求，处理请求，将数据返回的机器叫做服务器。</p><p>客户端请求资源，就要用到资源定位符URI，URI是一个明确的地址，通过这个地址就能去到响应的服务器请求资源。</p><p>至于这中间是怎么从我们面前的浏览器到达世界另一个地方的服务器的过程比较复杂，包括数据的编码、打包、IP地址查询、路由、DNS轮询、握手、解包等，我们只需要知道有网络基础设施无时无刻都在为我们服务即可。</p><p>例如，我们访问百度。在浏览器地址栏输入<code>https://www.baidu.com</code>，这就是全球唯一的地址，通过这个地址就可以到达百度的服务器，然后服务器立即响应将HTML页面发回本地，我们就看到了百度的首页。</p><h3 id="报文结构" tabindex="-1">报文结构 <a class="header-anchor" href="#报文结构" aria-label="Permalink to &quot;报文结构&quot;">​</a></h3><p>请求和响应信息统称报文，结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>首部</span></span>
<span class="line"><span>&lt;空行&gt;</span></span>
<span class="line"><span>body</span></span></code></pre></div><p>首部每一行是一个键值对。</p><h3 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to &quot;状态码&quot;">​</a></h3><ul><li>1字头 正在处理的信息</li><li>2字头 成功时的响应，常用的是200 OK</li><li>3字头 服务器给客户端的命令，例如重东西或缓存</li><li>4字头 当客户端发送的请求中存在异常内容时发送的响应码</li><li>5字头 当服务器内部发生错误时发送给客户端的状态码</li></ul><h3 id="url的结构" tabindex="-1">URL的结构 <a class="header-anchor" href="#url的结构" aria-label="Permalink to &quot;URL的结构&quot;">​</a></h3><p>常见URL路径的结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>协议://主机名/路径</span></span></code></pre></div><p>而完整的URL路径的结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>协议:// 用户:密码@主机名:端口/路径?查询#片段</span></span></code></pre></div><h3 id="方案" tabindex="-1">方案 <a class="header-anchor" href="#方案" aria-label="Permalink to &quot;方案&quot;">​</a></h3><p>主要包括：</p><ul><li>http</li><li>https</li><li>mailto</li><li>file</li><li>ftp</li></ul><h3 id="查询" tabindex="-1">查询 <a class="header-anchor" href="#查询" aria-label="Permalink to &quot;查询&quot;">​</a></h3><p>用户要搜索的关键词，语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>key1=value1&amp;key2=value2</span></span></code></pre></div><h3 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h3><p>Cookie是将网站信息保存在浏览器的一种结构，由服务器指示客户端（浏览器）保存数据。</p><p>例如服务器发送的报文：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Set-Cookie: key1=value1</span></span>
<span class="line"><span>Set-Cookie: key2=value2</span></span></code></pre></div><p>客户端就会存储起来，下次请求时可以带上：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cookie: key1=value1</span></span>
<span class="line"><span>Cookie: key2=value2</span></span></code></pre></div><h3 id="basic认证" tabindex="-1">BASIC认证 <a class="header-anchor" href="#basic认证" aria-label="Permalink to &quot;BASIC认证&quot;">​</a></h3><p>如今大多数服务器需要登录，但通常的方式是只需要第一次登录，然后在一定的时间内免登陆。 basic认证是最简单的认证方式，通过base64编码，因为base64可逆，所以服务器可以还原出来原来的用户名和密码。将还原出来的用户名和密码与数据库中进行对比。如下是对用户名和密码进行编码后的示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>base64(用户名+&quot;:&quot;+密码)</span></span></code></pre></div><p>示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>base64(&#39;zhangsan&#39;+&#39;:&#39;+&#39;123456&#39;)  // emhhbmdzYW46MTIzNDU2</span></span>
<span class="line"><span>authorization: &quot;Basic emhhbmdzYW46MTIzNDU2&quot;</span></span></code></pre></div><h3 id="digest认证" tabindex="-1">digest认证 <a class="header-anchor" href="#digest认证" aria-label="Permalink to &quot;digest认证&quot;">​</a></h3><p>使用哈希函数。</p><h3 id="https-3" tabindex="-1">https/3 <a class="header-anchor" href="#https-3" aria-label="Permalink to &quot;https/3&quot;">​</a></h3><p>udp和tcp的区别：</p><ul><li>可靠的，需要进行三次我手</li><li>不可靠的，只负责发出去，不管有没有收到。</li></ul><p>http/2在与http同一层的tcp套接字上进行了实现，但google为了进一步提高通信速度，在udp套接字上提供了quic协议。</p><h3 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h3><p>HTTP协议有两种最常用的方法：</p><ul><li>get 通过url和query向服务器获取数据</li><li>post 在body中添加数据发给服务器，请求数据</li><li>put 新增文件</li><li>delete 删除文件</li></ul><h3 id="响应码" tabindex="-1">响应码 <a class="header-anchor" href="#响应码" aria-label="Permalink to &quot;响应码&quot;">​</a></h3><p>HTTP有4种常用的响应码，如下：</p><ul><li>200 | 客户端成功请求，服务器成功响应</li><li>3xx | 服务器指示客户端需要完成的工作，例如重定向</li><li>404 | 客户端出了错误，例如请求不存在的文件</li><li>5xx | 服 务器出了错误</li></ul><h2 id="dhcp" tabindex="-1">DHCP <a class="header-anchor" href="#dhcp" aria-label="Permalink to &quot;DHCP&quot;">​</a></h2><p>DHCP，Dynamic Host Configuration Protocol ，动态主机配置协议。DHCP服务器的主要工作，就是自动将正确的网络参数分配给网络中的每台主机，让客户端主机可以在联网的时候立即自动配置好网络的参数值，这些参数包括：IP、子网掩码、网段、网关、DNS地址等。现实生活中，我们的笔记本连上网络后，是不是很少去手动设置这些参数，而是直接就可以上网了，这就是因为DHCP服务器已经为我们配置好了。</p><p>DHCP为客户端提供的信息至少包括以下内容：</p><ul><li>IP地址</li><li>子网掩码</li><li>租赁时间：客户端并不是一直拥有该IP地址，当时间到期后必须再次请求。默认情况下，DHCP服务器会记住客户端并分配相同的地址。</li><li>域名服务器（DNS）地址：通常DHCP服务器会给一到三个DNS地址供客户端使用。</li><li>默认网关。为了让一个网络请求离开本地网络，必须知道网络上的哪个节点提供了到本地的网络之外地址的路由，这个节点就是网关。</li></ul><h2 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h2><p>实际上，要使一台主机连接到另一台主机的服务，必须知道IP地址和端口。端口的问题好说，如果是用浏览器上网，那么基本就是80端口，那么IP地址呢？为什么我们并不知道百度的IP地址却可以访问百度？这就用到了一种网络基础设施服务——DNS。</p><p>DNS，Domain Name System，域名系统，通过将由英文字母和数字组成的主机名转化成IP地址，使得数据包可以到达目的地。这个DNS也是网络中的一台主机，只是专门为我们提供DNS服务，DNS的地址是由DHCP服务器配置的。</p><p>例如，访问baidu.com，我们电脑的缓存中没有查到baidu.com对应的IP地址，此时就将baidu.com发送给DNS主机，DNS主机分析该路径的组成，再通过与全球其它的DNS服务器递归的查找和询问，最终得到了baidu.com的IP地址是xx.xx.xx.xx，再返回给我们的电脑，电脑拿到这个确定的IP地址后，就能够到达百度的服务器了。</p><p>这种询问过程的举例如下，例如访问baidu.com：</p><ul><li>我们的电脑将baidu.com发送给DNS服务器8.8.8.8</li><li>DNS服务器先去询问全球域名根服务器（/），得到管理com的服务器的IP地址</li><li>DNS服务器再去询问管理com的服务器，得到baidu.com的服务器的IP地址</li><li>DNS拿到具体的IP地址后，返回给我们的电脑。</li></ul><p>要知道具体是哪个IP地址，可以使用ping命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ ping baidu.com</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Pinging baidu.com [39.156.66.10] with 32 bytes of data:</span></span>
<span class="line"><span>Reply from 39.156.66.10: bytes=32 time=25ms TTL=48</span></span>
<span class="line"><span>Reply from 39.156.66.10: bytes=32 time=24ms TTL=48</span></span>
<span class="line"><span>Reply from 39.156.66.10: bytes=32 time=24ms TTL=48</span></span>
<span class="line"><span>Reply from 39.156.66.10: bytes=32 time=27ms TTL=48</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Ping statistics for 39.156.66.10:</span></span>
<span class="line"><span>    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</span></span>
<span class="line"><span>Approximate round trip times in milli-seconds:</span></span>
<span class="line"><span>    Minimum = 24ms, Maximum = 27ms, Average = 25ms</span></span></code></pre></div><p>也可以使用nslookup命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nslookup</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> baidu.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Server:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  public1.114dns.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Address:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  114.114.114.114</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Non-authoritative</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> answer:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    baidu.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Addresses:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  110.242.68.66</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          39.156.66.10</span></span></code></pre></div><h2 id="远程文件服务器-ftp" tabindex="-1">远程文件服务器：ftp <a class="header-anchor" href="#远程文件服务器-ftp" aria-label="Permalink to &quot;远程文件服务器：ftp&quot;">​</a></h2><h3 id="客户端连接" tabindex="-1">客户端连接 <a class="header-anchor" href="#客户端连接" aria-label="Permalink to &quot;客户端连接&quot;">​</a></h3><p>一般要提供如下参数：</p><ul><li>主机</li><li>端口，默认21</li><li>用户名和密码，如果允许匿名，则用户名为anonymous</li></ul><p>有三种方式连接到FTP服务器：</p><ul><li>命令行</li><li>客户端，例如FIlezilla</li><li>浏览器</li></ul><p>如果要使用浏览器连接ftp服务器，则在地址栏输入：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ftp://用户名:密码@主机地址</span></span></code></pre></div><h3 id="服务器配置" tabindex="-1">服务器配置 <a class="header-anchor" href="#服务器配置" aria-label="Permalink to &quot;服务器配置&quot;">​</a></h3><p>如果要自己搭建ftp服务器，则可以使用vsftpd这个软件。</p><h2 id="网络文件系统-nfs" tabindex="-1">网络文件系统：NFS <a class="header-anchor" href="#网络文件系统-nfs" aria-label="Permalink to &quot;网络文件系统：NFS&quot;">​</a></h2><p>NFS，Network File System，网络文件系统，作用是让不同的机器、不同的操作系统可以彼此共享文件。最主要的设置就是文件的权限。设置NFS服务器主要用到两个软件：rpcbind、nfs。</p><p>客户端如果要连接NFS服务器，只需要将NFS资源挂载到相关目录之下即可。</p><h2 id="网络层-ip层" tabindex="-1">网络层（IP层） <a class="header-anchor" href="#网络层-ip层" aria-label="Permalink to &quot;网络层（IP层）&quot;">​</a></h2><p>目前IP协议有两种版本：</p><ul><li>IPv4（因特网协议第四版）：由于地址仅有32位，预计2020年左右分配完毕。</li><li>IPv6（因特网协议第六版）：为了应对IPV4地址枯竭的问题，诞生了IPv6。ipv6的地址可以达到128位，这样的IP数据几乎是用不完的。不过，由于IPv6与IPv4协议互不兼容，需要从上而上大幅更换软硬件设施，因此推广问题值得关注。</li></ul><p>IP的组成是32位的数据，即由32个0与1组成的一连串数字。为了方便读写，将32位分为四小段，每段8位，又将每段换算为十进制，并且每段以小数点隔开，这就形成了我们日常见到的IP地址。例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>00000000.00000000.00000000.00000000   ==&gt;  0.0.0.0</span></span>
<span class="line"><span>11111111.11111111.11111111.11111111   ==&gt;  255.255.255.255</span></span></code></pre></div><p>这串数字中，又分为网络号码和主机号码。在同一个物理网段内，主机的IP具有相同的网络号码，并且具有唯一的主机号码。同时，同一个物理网段内，可以根据不同的IP设置，而设置成多个“IP网络”，也叫“子网段”。</p><p>另外，主机号码不能全部为0或1，全部为0表示整个网段的地址，全部为1表示广播地址。</p><h3 id="五类ip地址" tabindex="-1">五类IP地址 <a class="header-anchor" href="#五类ip地址" aria-label="Permalink to &quot;五类IP地址&quot;">​</a></h3><p>为了便于管理和方法，IP地址被分为了五类：</p><table tabindex="0"><thead><tr><th>类别</th><th style="text-align:center;">二进制网络号码开头</th><th>号段</th></tr></thead><tbody><tr><td>A类</td><td style="text-align:center;">0</td><td>0.xx.xx.xx ~ 127.xx.xx.xx</td></tr><tr><td>B类</td><td style="text-align:center;">10</td><td>128.xx.xx.xx ~ 191.xx.xx.xx</td></tr><tr><td>C类</td><td style="text-align:center;">110</td><td>192.xx.xx.xx ~ 223.xx.xx.xx</td></tr><tr><td>D类（组播使用）</td><td style="text-align:center;">1110</td><td>224.xx.xx.xx ~ 239.xx.xx.xx</td></tr><tr><td>E类（保留网段）</td><td style="text-align:center;">1111</td><td>240.xx.xx.xx ~ 255.xx.xx.xx</td></tr></tbody></table><p>能够用来一般系统上面的，只有A类、B类、C类地址，而普通人大概率只能申请到C类地址。</p><p>但是，上面的A、B、C类地址显示是不够用的，如果一个企业有10台主机，就要购买10个IP吗？为了解决这个问题，又提出了公有地址和私有地址。一个企业持有一个公有地址，下面可以规划若干了私有地址，这就解决了企业内部的IP地址问题。私有地址包括：</p><ul><li>A类私有地址： 10.0.0.0 ~ 10.255.255.255</li><li>B类私有地址 ： 172.16.0.0 ~ 172.31.255.255</li><li>C类私有地址 ： 192.168.0.0 ~ 192.168.255.255</li></ul><h3 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-label="Permalink to &quot;路由&quot;">​</a></h3><p>同一个网络段的主机可以直接通信，那么不同网络段呢？每一台主机都有一个路由表，每台主机传递数据时依据这个路由表决定“下一跳”。</p><h3 id="nat-网络地址转换" tabindex="-1">NAT（网络地址转换） <a class="header-anchor" href="#nat-网络地址转换" aria-label="Permalink to &quot;NAT（网络地址转换）&quot;">​</a></h3><p>如果私有IP要访问公网，需要通过NAT（网络地址转换）。一个公网IP加一个端口号映射到私有地址，这样私有地址的主机就可以访问公网了。</p><p>我们的手机可以访问公网，是因为连接到WiFi后，就会得到一个私有地址，持有公网IP的网络地址转换访问的公网。</p><h2 id="远程连接服务器-ssh" tabindex="-1">远程连接服务器：SSH <a class="header-anchor" href="#远程连接服务器-ssh" aria-label="Permalink to &quot;远程连接服务器：SSH&quot;">​</a></h2><p>远程连接服务器通过文字或图形的方式来远程登录系统，让你在远程的终端面前登录Linux主机以取得可操作得Shell，而登录后的感觉上就像坐在系统前面一样。</p><p>可以使用OpenSSH软件设置SSH服务。</p><p>客户端连接的语法如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [-p </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">端口号]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [账号@]主机地址 [命令]</span></span></code></pre></div><p>端口号一般默认为22，如果服务器设置了另外一个端口，使用新端口即可。</p><h2 id="oauth" tabindex="-1">OAuth <a class="header-anchor" href="#oauth" aria-label="Permalink to &quot;OAuth&quot;">​</a></h2><p>OAuth 是 Opne Authorizations的简写。</p><p>openid是微信用户在公众号appid下的唯一用户标识（appid不同，则获取到的openid就不同）</p><p><img src="https://bkimg.cdn.bcebos.com/pic/86d6277f9e2f0708ca1c2b2ceb24b899a901f285?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt="OAuth | 1200"></p><ul><li>AppID 应用ID</li><li>AppSecret 应用的密钥</li><li>Code 临时票据</li><li>返回access_token</li></ul><h3 id="github-授权" tabindex="-1">Github 授权 <a class="header-anchor" href="#github-授权" aria-label="Permalink to &quot;Github 授权&quot;">​</a></h3><p>打开<a href="https://github.com/settings/developers" target="_blank" rel="noreferrer">https://github.com/settings/developers</a> 注册一个OAuth应用。需要填写如下信息：</p><ul><li>Application Name：为应用取个名字。</li><li>homepageURL：主页地址</li><li>Authorization Callback URL为回调地址，当用户同意授权后，会回调该地址，并将授权码拼接到地址后面。</li></ul><p>注册完毕后会得到Client ID和Client Secret。</p><p>获取授权码请求路径 ：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  https://github.com/login/oauth/authorize?client_id=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">${clientId}&amp;redirect_uri</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">${redirect_uri}</span></span></code></pre></div><p>替换成应用的clientId和redirect_url。访问到授权服务器会重定向到redirect_url，并且在地址后面拼接授权码。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">POST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  https://github.com/login/oauth/access_token</span></span></code></pre></div><p>设置Accept: application/json。</p><p>带上body：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">	code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">授权码</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">	client_id:</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> your_client_id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">	client_secret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">your_secret_id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>得到Access Token，通过此令牌得到用户的信息：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Authorization: Bearer OAUTH-TOKEN</span></span>
<span class="line"><span>GET https://api.github.com/user</span></span></code></pre></div><h3 id="access-token" tabindex="-1">Access Token <a class="header-anchor" href="#access-token" aria-label="Permalink to &quot;Access Token&quot;">​</a></h3><p>最终的目的是获得一个Access Token，Access Token 唯一标识用户。</p><p>使用Refresh Token 获得一个新的Access Token。</p><p>三个地址：</p><ul><li>请求授权地址，例如 <code>授权服务器主机名/auth/login</code> 参数 client_id redict_id，请求后会打开授权页面</li><li>点击后，授权服务器返回的地址，即回调地址（携带Code）</li><li>请求回调地址，会得到Code</li><li>请求token地址，例如 <code>授权服务器主机名/auto/access_token</code> 参数Code + client_id + client_secret</li><li>获取Access_token</li><li>通过Access Token获取用户的OpenID</li></ul><h3 id="微信授权" tabindex="-1">微信授权 <a class="header-anchor" href="#微信授权" aria-label="Permalink to &quot;微信授权&quot;">​</a></h3><p>参考 ： <a href="https://blog.csdn.net/qq_36389060/article/details/124047449" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_36389060/article/details/124047449</a></p><p>获取 access_token 后可以进行哪些操作？</p><p>开发者可通过 OpenID 来获取用户基本信息</p><h3 id="github授权登陆流程" tabindex="-1">Github授权登陆流程 <a class="header-anchor" href="#github授权登陆流程" aria-label="Permalink to &quot;Github授权登陆流程&quot;">​</a></h3><table tabindex="0"><thead><tr><th>步骤</th><th>请求方式</th><th>请求URL</th><th>请求参数</th><th>返回内容</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td><code>https://github.com/login/oauth/authorize</code></td><td>client-id</td><td>redict-url</td></tr><tr><td>2</td><td>GET</td><td><code>redict_url</code></td><td>无</td><td>request-code</td></tr><tr><td>3</td><td>POST</td><td><code>https://github.com/login/oauth/access_token</code></td><td>client-id、client-secret、request-code</td><td>access-token</td></tr><tr><td>4</td><td>GET</td><td><code>https://api.github.com/user</code></td><td>请求头中添加access-token</td><td>github-id、github-url等GitHub用户信息</td></tr></tbody></table><h3 id="微信授权登陆流程" tabindex="-1">微信授权登陆流程 <a class="header-anchor" href="#微信授权登陆流程" aria-label="Permalink to &quot;微信授权登陆流程&quot;">​</a></h3><p>打开微信开发平台，地址：</p><table tabindex="0"><thead><tr><th>步骤</th><th>请求方式</th><th>请求URL</th><th>请求参数</th><th>返回内容</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td><code>https://open.weixin.qq.com/connect/qrconnect</code></td><td>client-id</td><td>redict-url</td></tr><tr><td>2</td><td>GET</td><td><code>redict_url</code></td><td>无</td><td>request-code</td></tr><tr><td>3</td><td>POST</td><td><code>https://api.weixin.qq.com/sns/oauth2/access_token</code></td><td>appid、secret、request-code</td><td>access-token、refresh-token</td></tr><tr><td>4</td><td>GET</td><td><code>https://api.weixin.qq.com/sns/userinfo</code></td><td>请求头中添加access-token</td><td>微信用户个人信息</td></tr><tr><td>5</td><td>GET</td><td><code>https://api.weixin.qq.com/sns/oauth2/refresh_token</code></td><td>appid、refresh-token</td><td>新的access-token</td></tr></tbody></table><h2 id="加密协议" tabindex="-1">加密协议 <a class="header-anchor" href="#加密协议" aria-label="Permalink to &quot;加密协议&quot;">​</a></h2><h3 id="加密算法的分类" tabindex="-1">加密算法的分类 <a class="header-anchor" href="#加密算法的分类" aria-label="Permalink to &quot;加密算法的分类&quot;">​</a></h3><ul><li>对称加密算法：在加密和解密时使用同一个密钥，这种算法不安全，几乎不再使用了。</li><li>非对称加密算法：通过密钥算法同时一对密钥：公钥和私钥，分别用于加密和解密。目前在各大安全协议中被使用。</li></ul><p>非对称加密算法主要包括：</p><ul><li>rsa：主流，ssh-keygen工具默认</li><li>dsa</li></ul><h3 id="非对称秘钥的文件位置和内容" tabindex="-1">非对称秘钥的文件位置和内容 <a class="header-anchor" href="#非对称秘钥的文件位置和内容" aria-label="Permalink to &quot;非对称秘钥的文件位置和内容&quot;">​</a></h3><p>公钥和私钥都是一个文本文件，里面存放着一定长度的字符串，默认放在~/.ssh目录。</p><p>公钥私钥是成对生成、成对存在的，其名字也应该对应。假设是用rsa算法生成的一对公私钥，那么其名称默认是：</p><ul><li>~/.ssh/id_rsa 私钥</li><li>~/.ssh/id_rsa.pub 公钥</li></ul><p>当然，名称也可以自己取一个有辨识度的名字。</p><p>公钥顾名思义就是可以公开的，A和B首先把自己的公钥发给对方，然后把对方的的公钥追加进自己的~/.ssh/known_hosts文件中，这个文件存放的是从网络上接收到的各个主机的公钥，每条信息占一行，每一行的格式如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>主机  加密算法   公钥字符串==</span></span></code></pre></div><h3 id="非对称加密传递信息" tabindex="-1">非对称加密传递信息 <a class="header-anchor" href="#非对称加密传递信息" aria-label="Permalink to &quot;非对称加密传递信息&quot;">​</a></h3><p>假设网络上的两台主机A和B需要传递信息。那么A和B首先生成自己的私钥和公钥。</p><p>现在A要跟B发送信息，A就使用B的公钥将原始信息加密，得到一条加密信息通过网络发送给B，由于原始信息是通过B的公钥加密的，那么加密信息只能通过B的私钥解密，A的公钥私钥、B的公钥、其它网络上任何人的公钥私钥都无法解密这条加密信息。B收到后通过自己的私钥成功界面，就看到了原始信息。在这个过程中，哪怕加密信息被别人截取到了，也无法解密。</p><p>总而言之，公钥是用来加密的，私钥是用来解密的。要给对方发送消息，就用对方的公钥加密，等信息到达对方主机后，对方就可以解密了。</p><p>非对称秘钥有几个特点：</p><ul><li>全局唯一：不同的人在同一时间，或同一个人在不同时间生成公钥私钥一定是不同的。也就是说，每个人的私钥一定是不同的，这确保了身份的准确性。</li><li>一对一：公钥和私钥是成对生成的，用公钥加密的信息只能通过对应的私钥解密，其它私钥绝对不可能解密。</li><li>确定性：用对应的私钥一定能解密，不用对应的私钥一定不能解密。</li></ul><h3 id="数字证书和数字签名" tabindex="-1">数字证书和数字签名 <a class="header-anchor" href="#数字证书和数字签名" aria-label="Permalink to &quot;数字证书和数字签名&quot;">​</a></h3><p>现在，又有一个问题，如何保证这条加密信息是由a发出来的？换句话说，C也可以生成一对公私钥，发送给B，然后对B说：“我是A，这是我的公钥”。</p><p>这种问题的漏洞在于，每个人都可以生成公钥私钥，但无法根据识别身份。这个时候，有一个第三方的权威机构，A向这家机构发动自己的公钥以及能够证明身份的信息（例如营业执照），完成自己在网络上的“实名认证”。这家权威机构在核实了A的信息和公钥之后，颁发给A一张数字证书，这家机构也叫数字证书颁发机构。有了权威机构的背书，任何人也无法冒充A了，因为现在人们获取公钥都直接从权威机构获取。</p><p>现在，A要向B发生信息，首先使用B的公钥加密原始信息，然后再用自己（A）的私钥再进行一道加密，这个过程就是数字签名。B收到加密信息后，首先向第三方权威机构获取A的公钥，然后使用A的公钥进行第一级解密，再用自己（B）的的私钥进行二级解密，就获取了原始信息。</p><p>数字证书颁发机构的作用就是完成公钥信息的“实名制”。</p><p>第一级加密和数字签名是对称的：</p><ul><li>第一级加密使用对方的公钥加密</li><li>第二级数字签名使用自己的私钥加密</li><li>收到信息后，首先向数字证书颁发机构获取发送方的公钥，完成数字签名信息的解密</li><li>然后使用自己的私钥解密出原始信息。</li></ul><p>总之，原始信息加密解密的方式是：接收的公钥加密，接收方的私钥解密。数字签名的加密解密方式是：发送方的私钥加密，发送到的公钥解密。</p><h3 id="ssh" tabindex="-1">ssh <a class="header-anchor" href="#ssh" aria-label="Permalink to &quot;ssh&quot;">​</a></h3><p>ssh命令用于登录远程主机</p><p>要登录远程主机，使用如下命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  远程用户名@远程主机</span></span></code></pre></div><p>此时会提示你输入密码。</p><p>输入<code>exit</code>退出登录。</p><p>如果是第一次登录该远程主机，则默认会将远程主机的公钥追加到文件~/.ssh/known_hosts 的末尾。</p><h3 id="ssh-keygen" tabindex="-1">ssh-keygen <a class="header-anchor" href="#ssh-keygen" aria-label="Permalink to &quot;ssh-keygen&quot;">​</a></h3><p>ssh-keygen可以用了生成一对公私钥，运行命令后，会提示你：</p><ul><li>输入私钥的文件名，默认为id_rsa。如果已经有一个私钥而想增加一个，可以自定义一个名称。公钥的名称为<code>私钥名称.pub</code>。</li><li>公钥的密码，默认不设密码</li></ul><h3 id="ssh-copy-id" tabindex="-1">ssh-copy-id <a class="header-anchor" href="#ssh-copy-id" aria-label="Permalink to &quot;ssh-copy-id&quot;">​</a></h3><p>使用ssh-copy-id将客户端的公钥复制到远程主机的同名家目录的.ssh目录的 <code>authorized_keys</code> 文件中。以后就可以直接连接而不用输入密码了。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh-copy-id</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 公钥路径</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 远程用户名@远程主机地址</span></span></code></pre></div></div></div></main><footer class="VPDocFooter" data-v-ddd4901f data-v-d088cbcb><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"awesome-browser_readme.md\":\"DfFfDqhP\",\"css_index.md\":\"DziDd04Z\",\"css_锚点定位_锚点定位.md\":\"Bjnib0iJ\",\"electron_index.md\":\"BIeRUx0y\",\"index.md\":\"DD2A1RaR\",\"javascript_index.md\":\"S_s3rlej\",\"linux_index.md\":\"pFrvyMHe\",\"node.js_index.md\":\"BZRUMCM8\",\"office.md\":\"OZXP5ntT\",\"python_index.md\":\"D4PDQKep\",\"react-native_index.md\":\"BW0K48W2\",\"react_index.md\":\"j6UwfBc6\",\"webrtc_index.md\":\"CUV8UKq6\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"我的个人博客网站\",\"description\":\"个人博客网站\",\"base\":\"/blog/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>