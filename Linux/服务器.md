
<p id="top"></p>

<a style="position: fixed;top:100px;left:-20px;" href="#top">回到顶部</a>

- [传输层：TCP与UDP](#传输层tcp与udp)
  - [端口](#端口)
  - [TCP 三次握手](#tcp-三次握手)
  - [TCP的四次挥手](#tcp的四次挥手)
- [HTTP协议](#http协议)
  - [请求报文与响应报文](#请求报文与响应报文)
  - [简介](#简介)
  - [报文结构](#报文结构)
  - [状态码](#状态码)
  - [URL的结构](#url的结构)
  - [方案](#方案)
  - [查询](#查询)
  - [Cookie](#cookie)
  - [BASIC认证](#basic认证)
  - [digest认证](#digest认证)
  - [https/3](#https3)
  - [方法](#方法)
  - [响应码](#响应码)
- [DHCP](#dhcp)
- [DNS](#dns)
- [远程文件服务器：ftp](#远程文件服务器ftp)
  - [客户端连接](#客户端连接)
  - [服务器配置](#服务器配置)
- [网络文件系统：NFS](#网络文件系统nfs)
- [网络层（IP层）](#网络层ip层)
  - [五类IP地址](#五类ip地址)
  - [路由](#路由)
  - [NAT（网络地址转换）](#nat网络地址转换)
- [远程连接服务器：SSH](#远程连接服务器ssh)
- [OAuth](#oauth)
  - [github 授权](#github-授权)
  - [Access Token](#access-token)
  - [微信授权](#微信授权)
  - [Github授权登陆流程](#github授权登陆流程)
  - [微信授权登陆流程](#微信授权登陆流程)
- [加密协议](#加密协议)
  - [加密算法的分类](#加密算法的分类)
  - [非对称秘钥的文件位置和内容](#非对称秘钥的文件位置和内容)
  - [非对称加密传递信息](#非对称加密传递信息)
  - [数字证书和数字签名](#数字证书和数字签名)
  - [ssh](#ssh)
  - [ssh-keygen](#ssh-keygen)
  - [ssh-copy-id](#ssh-copy-id)


## 传输层：TCP与UDP

### 端口

我们都知道IP数据包的传送的起点和终点是IP地址，那么达到后具体应该连接到哪里去呢？一台主机可以部署多个服务，那么是连接到WWW服务器，还是FTP服务呢？这就需要通过端口区分不同的服务，一个特定的服务由两部分组成：

```
地址:端口
```

地址可以是IP地址，也可以是主机名称。

端口的取值范围为0-65535，不过，0-1023已经分给了常用的应用程序，因此一般的取值范围是1024~65535。

常见的服务与端口的对应如下：
- 20 FTP
- 22 SSH  安全远程连接服务
- 25  SMTP  简单邮件传递协议
- 80  HTTP，超文本传输协议服务
- 110   POP3  邮件接收协议
- 443  HTTPS  安全加密的HTTP服务
- 3306  MySQL 默认端口号


### TCP 三次握手

![TCP的三次握手](https://pics4.baidu.com/feed/1ad5ad6eddc451da91dfe64756fd5b6bd016327a.jpeg@f_auto?token=6a788b3425a128f386466dad924ccf99)

在TCP的连接模式中，在建立连接之前都必须通过三个确认的动作，所以这种连接方式也被称为三次握手，大致分为四个阶段。

- 第一阶段，数据包发起   当可以的想要对服务器端连接时，就必须要送出一个要求连接的数据包，此时客户端必须随机取用一个大于1024的空闲的端口来作为程序沟通的接口。然后再TCP的报头当中，必须要带有SYN的主动连接（SYN=1），并且记下发出连接数据包给服务器端的序号（Sequence number = 10001）。

- 第二阶段，数据包接收与确认数据包发送  当服务器接收到这个数据包，并且确定要接收这个数据包后，就会开始制作一个同时带有SYN=1，ACK=1 的数据包，其中那个Acknowledge的号码是要给Client端确认用的，所以该数字会比A步骤里面的Sequence号码多一号（ack=10001+1=10002），那服务器也必须确认客户端确实可以接收我们的数据包才行，所以也会发送出一个Sequence（seq=20001）给客户端，并且开始等待客户端与服务器端的回应。

- 第三阶段，回送确认数据包  当客户端收到来自服务器端的ACK数字（10002）后，就能确认之前那个请求连接的数据包被正确接收了，接下来如果客户端也同意与服务器建立连接时，就会再次发送一个确认数据包（ACK=1）给服务器，即Acknowledge = 20001+1 = 20002.

- 第四阶段  取得最后确认  若一切都顺利，在服务器端收到带有ACK=1 且ack = 20002序号的数据包后，就能够建立起这次的连接了。

举个通俗得了例子，好比两个人A和B在谈论事情之前打招呼：
- A说： B你听得到吗？
- B说：我听得到，A你听得到吗？
- A说：我也听得到

可能有的人会有疑问，为什么B要再次询问一遍呢？B收到消息后直接建立连接不行吗？假设A说中文但听不懂英文，B说英文也可以听懂中文，这时候直接建立后A是听不懂的，必须要保证双方都能听懂对方说的话才行。

那为什么不来回更多次呢？理论上也是可以的，不过，为了节省资源，只需要双方都说一次，然后确认对方听懂了就够了。

总之，三次握手就是要确认两件事：
- 服务端能有效识别客户端的信息
- 客户端能有效识别服务端的信息

### TCP的四次挥手

![TCP的四次挥手](https://pics1.baidu.com/feed/c8177f3e6709c93d3b2db2957e3df1d1d0005486.jpeg@f_auto?token=d1003b5bd35811075409c512e0503094)


TCP的四次挥手是为了结束已建立的连接，确保双方都能正确地关闭连接并释放资源。下面是四次挥手的过程：

- 第一次挥手：客户端发送一个带有FIN（结束）标志的数据包，表示自己已经没有数据要发送了，请求关闭连接。

- 第二次挥手：服务器接收到客户端的结束请求后，会发送一个带有ACK（确认）标志的数据包作为响应，表示已收到客户端的结束请求。

- 第三次挥手：服务器发送一个带有FIN标志的数据包，表示自己也没有数据要发送了，请求关闭连接。

- 第四次挥手：客户端接收到服务器的结束请求后，会发送一个带有ACK标志的数据包作为确认，表示已收到服务器的结束请求。

在关闭连接时，需要确保双方都完成了数据的传输和接收，以防止数据丢失或错误。如果只有三次挥手，可能会导致一些问题。

假设只有三次挥手，当客户端发送结束请求后，服务器收到后会发送确认，表示已收到客户端的结束请求。但是在此过程中，服务器可能还有未发送完的数据，如果直接关闭连接，那么这些数据就会丢失。因此，引入第三次挥手，服务器在发送结束请求前，先发送所有未发送完的数据，并等待客户端的确认。客户端接收到服务器的结束请求后，会确认并处理完未接收的数据，然后发送确认，表示自己已准备好关闭连接。

通过四次挥手，可以确保双方都能正确地结束连接，并处理未发送和未接收的数据，保证数据的完整性和可靠性。因此，关闭连接需要四次挥手。


##  HTTP协议

###  请求报文与响应报文


客户端发送请求报文，服务器返回响应报文，报文有一定的格式约定，将格式约定好以便于发送和解析，这既是协议。

要查看报文实例，最好的方法是使用浏览器。

使用Edge浏览器，打开百度首页，按F12进入开发者工具，切换到网络选项卡，这时候应该有很多网络传输记录。

在右边的表头选项卡，我们能看到“常规”、“响应标头”、“请求标头”。这就是报文的内容。

我们解释几个典型的参数。

* 请求URL：这就是我们常说的链接，只有通过链接才能拿到资源如HTML页面、文件、图片、视频。
* 请求方法：一般为GET，表示向服务器拿资源。开发中会用到POST表示携带正文向服务器发送。
* 状态代码：表示是成功还是错误，如果是200 OK表示成功返回了正确的资源。如果是4或5开头的代码，表示有错误。
* 远程地址：服务器的IP地址，这个地址是DNS系统通过解析之后得到的机器能够理解的地址。
* 请求标头：请求报文的头部，是对请求报文的概括和描述，如协议版本、能接受的编码等。
* 响应标头：响应报文的头部，是对响应报文的概括和描述，如字节大小等。


### 简介


一般而言，网络传输的两端分为客户端和服务器。请求数据的叫做客户端，浏览器就是典型的客户端。接收请求，处理请求，将数据返回的机器叫做服务器。

客户端请求资源，就要用到资源定位符URI，URI是一个明确的地址，通过这个地址就能去到响应的服务器请求资源。

至于这中间是怎么从我们面前的浏览器到达世界另一个地方的服务器的过程比较复杂，包括数据的编码、打包、IP地址查询、路由、DNS轮询、握手、解包等，我们只需要知道有网络基础设施无时无刻都在为我们服务即可。

例如，我们访问百度。在浏览器地址栏输入`https://www.baidu.com`，这就是全球唯一的地址，通过这个地址就可以到达百度的服务器，然后服务器立即响应将HTML页面发回本地，我们就看到了百度的首页。



### 报文结构

请求和响应信息统称报文，结构：

```
首部

body
```


首部每一行是一个键值对。

### 状态码

- 1字头 正在处理的信息
- 2字头 成功时的响应，常用的是200 OK
- 3字头 服务器给客户端的命令，例如重东西或缓存
- 4字头 当客户端发送的请求中存在异常内容时发送的响应码
- 5字头 当服务器内部发生错误时发送给客户端的状态码


### URL的结构

常见URL路径的结构：

```
协议://主机名/路径
```

而完整的URL路径的结构：

```
协议:// 用户:密码@主机名:端口/路径?查询#片段
```

###  方案

主要包括：
- http
- https
- mailto
- file
- ftp


### 查询

用户要搜索的关键词，语法如下：

```
key1=value1&key2=value2
```


### Cookie

Cookie是将网站信息保存在浏览器的一种结构，由服务器指示客户端（浏览器）保存数据。

例如服务器发送的报文：

```
Set-Cookie: key1=value1
Set-Cookie: key2=value2
```


客户端就会存储起来，下次请求时可以带上：

```
Cookie: key1=value1
Cookie: key2=value2
```


###  BASIC认证

如今大多数服务器需要登录，但通常的方式是只需要第一次登录，然后在一定的时间内免登陆。
basic认证是最简单的认证方式，通过base64编码，因为base64可逆，所以服务器可以还原出来原来的用户名和密码。将还原出来的用户名和密码与数据库中进行对比。如下是对用户名和密码进行编码后的示例：


```
base64(用户名+":"+密码)
```


示例：
```

base64('zhangsan'+':'+'123456')  // emhhbmdzYW46MTIzNDU2
authorization: "Basic emhhbmdzYW46MTIzNDU2"
```

### digest认证

使用哈希函数。

### https/3

udp和tcp的区别：
- 可靠的，需要进行三次我手
- 不可靠的，只负责发出去，不管有没有收到。

http/2在与http同一层的tcp套接字上进行了实现，但google为了进一步提高通信速度，在udp套接字上提供了quic协议。





### 方法

HTTP协议有两种最常用的方法：

- get	 通过url和query向服务器获取数据
- post	 	在body中添加数据发给服务器，请求数据
- put 新增文件
- delete 删除文件

### 响应码

HTTP有4种常用的响应码，如下：

- 200	|	客户端成功请求，服务器成功响应
- 3xx	|	服务器指示客户端需要完成的工作，例如重定向
- 404	|	客户端出了错误，例如请求不存在的文件
- 5xx	|	服  务器出了错误


## DHCP

DHCP，Dynamic Host Configuration Protocol ，动态主机配置协议。DHCP服务器的主要工作，就是自动将正确的网络参数分配给网络中的每台主机，让客户端主机可以在联网的时候立即自动配置好网络的参数值，这些参数包括：IP、子网掩码、网段、网关、DNS地址等。现实生活中，我们的笔记本连上网络后，是不是很少去手动设置这些参数，而是直接就可以上网了，这就是因为DHCP服务器已经为我们配置好了。

DHCP为客户端提供的信息至少包括以下内容：
- IP地址
- 子网掩码
- 租赁时间：客户端并不是一直拥有该IP地址，当时间到期后必须再次请求。默认情况下，DHCP服务器会记住客户端并分配相同的地址。
- 域名服务器（DNS）地址：通常DHCP服务器会给一到三个DNS地址供客户端使用。
- 默认网关。为了让一个网络请求离开本地网络，必须知道网络上的哪个节点提供了到本地的网络之外地址的路由，这个节点就是网关。

## DNS

实际上，要使一台主机连接到另一台主机的服务，必须知道IP地址和端口。端口的问题好说，如果是用浏览器上网，那么基本就是80端口，那么IP地址呢？为什么我们并不知道百度的IP地址却可以访问百度？这就用到了一种网络基础设施服务——DNS。

DNS，Domain Name System，域名系统，通过将由英文字母和数字组成的主机名转化成IP地址，使得数据包可以到达目的地。这个DNS也是网络中的一台主机，只是专门为我们提供DNS服务，DNS的地址是由DHCP服务器配置的。

例如，访问baidu.com，我们电脑的缓存中没有查到baidu.com对应的IP地址，此时就将baidu.com发送给DNS主机，DNS主机分析该路径的组成，再通过与全球其它的DNS服务器递归的查找和询问，最终得到了baidu.com的IP地址是xx.xx.xx.xx，再返回给我们的电脑，电脑拿到这个确定的IP地址后，就能够到达百度的服务器了。

这种询问过程的举例如下，例如访问baidu.com：
- 我们的电脑将baidu.com发送给DNS服务器8.8.8.8
- DNS服务器先去询问全球域名根服务器（/），得到管理com的服务器的IP地址
- DNS服务器再去询问管理com的服务器，得到baidu.com的服务器的IP地址
- DNS拿到具体的IP地址后，返回给我们的电脑。

要知道具体是哪个IP地址，可以使用ping命令：

```
PS:> ping baidu.com

Pinging baidu.com [39.156.66.10] with 32 bytes of data:
Reply from 39.156.66.10: bytes=32 time=25ms TTL=48
Reply from 39.156.66.10: bytes=32 time=24ms TTL=48
Reply from 39.156.66.10: bytes=32 time=24ms TTL=48
Reply from 39.156.66.10: bytes=32 time=27ms TTL=48

Ping statistics for 39.156.66.10:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 24ms, Maximum = 27ms, Average = 25ms
```

也可以使用nslookup命令：

```
PS:> nslookup baidu.com
Server:  public1.114dns.com
Address:  114.114.114.114

Non-authoritative answer:
Name:    baidu.com
Addresses:  110.242.68.66
          39.156.66.10
```


##  远程文件服务器：ftp


### 客户端连接

一般要提供如下参数：
- 主机
- 端口，默认21
- 用户名和密码，如果允许匿名，则用户名为anonymous

有三种方式连接到FTP服务器：
- 命令行
- 客户端，例如FIlezilla
- 浏览器

如果要使用浏览器连接ftp服务器，则在地址栏输入：

```
ftp://用户名:密码@主机地址
```


### 服务器配置

如果要自己搭建ftp服务器，则可以使用vsftpd这个软件。


## 网络文件系统：NFS

NFS，Network File System，网络文件系统，作用是让不同的机器、不同的操作系统可以彼此共享文件。最主要的设置就是文件的权限。设置NFS服务器主要用到两个软件：rpcbind、nfs。

客户端如果要连接NFS服务器，只需要将NFS资源挂载到相关目录之下即可。


## 网络层（IP层）

目前IP协议有两种版本：
- IPv4（因特网协议第四版）：由于地址仅有32位，预计2020年左右分配完毕。
- IPv6（因特网协议第六版）：为了应对IPV4地址枯竭的问题，诞生了IPv6。ipv6的地址可以达到128位，这样的IP数据几乎是用不完的。不过，由于IPv6与IPv4协议互不兼容，需要从上而上大幅更换软硬件设施，因此推广问题值得关注。

IP的组成是32位的数据，即由32个0与1组成的一连串数字。为了方便读写，将32位分为四小段，每段8位，又将每段换算为十进制，并且每段以小数点隔开，这就形成了我们日常见到的IP地址。例如：

```
00000000.00000000.00000000.00000000   ==>  0.0.0.0
11111111.11111111.11111111.11111111   ==>  255.255.255.255
```

这串数字中，又分为网络号码和主机号码。在同一个物理网段内，主机的IP具有相同的网络号码，并且具有唯一的主机号码。同时，同一个物理网段内，可以根据不同的IP设置，而设置成多个“IP网络”，也叫“子网段”。

另外，主机号码不能全部为0或1，全部为0表示整个网段的地址，全部为1表示广播地址。

###  五类IP地址

为了便于管理和方法，IP地址被分为了五类：
- A类： 网络号码的开头是0,0.xx.xx.xx ~ 127.xx.xx.xx
- B类:  网络号码的开头是10  128.xx.xx.xx ~ 191.xx.xx.xx
- C类  网络号码的开头是110  192.xx.xx.xx ~ 223.xx.xx.xx
- D类  网络号码的开头是1110   224.xx.xx.xx  ~ 239.xx.xx.xx   组播使用
- E类  网络号码的开头是1111   240.xx.xx.xx ~ 255.xx.xx.xx   保留网段

能够用来一般系统上面的，只有A类、B类、C类地址，而普通人大概率只能申请到C类地址。

但是，上面的A、B、C类地址显示是不够用的，如果一个企业有10台主机，就要购买10个IP吗？为了解决这个问题，又提出了公有地址和私有地址。一个企业持有一个公有地址，下面可以规划若干了私有地址，这就解决了企业内部的IP地址问题。私有地址包括：

- A类私有地址： 10.0.0.0  ~  10.255.255.255
- B类私有地址 ： 172.16.0.0   ~  172.31.255.255
- C类私有地址 ： 192.168.0.0  ~  192.168.255.255

### 路由

同一个网络段的主机可以直接通信，那么不同网络段呢？每一台主机都有一个路由表，每台主机传递数据时依据这个路由表决定“下一跳”。

### NAT（网络地址转换）

如果私有IP要访问公网，需要通过NAT（网络地址转换）。一个公网IP加一个端口号映射到私有地址，这样私有地址的主机就可以访问公网了。

我们的手机可以访问公网，是因为连接到WiFi后，就会得到一个私有地址，持有公网IP的网络地址转换访问的公网。

## 远程连接服务器：SSH

远程连接服务器通过文字或图形的方式来远程登录系统，让你在远程的终端面前登录Linux主机以取得可操作得Shell，而登录后的感觉上就像坐在系统前面一样。

可以使用OpenSSH软件设置SSH服务。

客户端连接的语法如下：

```
ssh [-p 端口号] [账号@]主机地址 [命令]
```

端口号一般默认为22，如果服务器设置了另外一个端口，使用新端口即可。

##  OAuth

OAuth 是 Opne Authorizations的简写。

openid是微信用户在公众号appid下的唯一用户标识（appid不同，则获取到的openid就不同）

![OAuth | 1200](https://bkimg.cdn.bcebos.com/pic/86d6277f9e2f0708ca1c2b2ceb24b899a901f285?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto)

- AppID 应用ID
- AppSecret 应用的密钥
- Code 临时票据 
- 返回access_token


### github 授权


打开https://github.com/settings/developers 注册一个OAuth应用。需要填写如下信息：

- Application Name：为应用取个名字。
- homepageURL：主页地址
- Authorization Callback URL为回调地址，当用户同意授权后，会回调该地址，并将授权码拼接到地址后面。
- 
注册完毕后会得到Client ID和Client Secret。



获取授权码请求路径 ： 

```
GET  https://github.com/login/oauth/authorize?client_id=${clientId}&redirect_uri=${redirect_uri}
```

替换成应用的clientId和redirect_url。访问到授权服务器会重定向到redirect_url，并且在地址后面拼接授权码。

```
POST  https://github.com/login/oauth/access_token
```

设置Accept: application/json。

带上body：

```
{
	code: 授权码
	client_id: your_client_id,
	client_secret: your_secret_id,
}
```

得到Access Token，通过此令牌得到用户的信息：

```
Authorization: Bearer OAUTH-TOKEN
GET https://api.github.com/user
```

### Access Token

最终的目的是获得一个Access Token，Access Token 唯一标识用户。

使用Refresh Token 获得一个新的Access Token。


三个地址：

- 请求授权地址，例如 `授权服务器主机名/auth/login` 参数 client_id  redict_id，请求后会打开授权页面
- 点击后，授权服务器返回的地址，即回调地址（携带Code）
- 请求回调地址，会得到Code
- 请求token地址，例如 `授权服务器主机名/auto/access_token` 参数Code + client_id + client_secret 
- 获取Access_token
- 通过Access Token获取用户的OpenID

### 微信授权

参考 ： https://blog.csdn.net/qq_36389060/article/details/124047449

获取 access_token 后可以进行哪些操作？

开发者可通过 OpenID 来获取用户基本信息

### Github授权登陆流程

步骤| 请求方式 | 请求URL | 请求参数|返回内容
|---| ---| ---|---|---|
1|GET|`https://github.com/login/oauth/authorize`|client-id| redict-url|授权登陆GitHub的页面
2|GET|`redict_url`|无|request-code
3|POST|`https://github.com/login/oauth/access_token`|client-id、client-secret、request-code|access-token
4|GET|`https://api.github.com/user`|请求头中添加access-token|github-id、github-url等GitHub用户信息

### 微信授权登陆流程

打开微信开发平台，地址：


步骤| 请求方式 | 请求URL | 请求参数|返回内容
|---| ---| ---|---|---|
1 | GET | `https://open.weixin.qq.com/connect/qrconnect`       | client-id                 | redict-url                 | 授权登陆微信的页面 |
2   | GET  | `redict_url`                                         | 无                         | request-code               |           |
 3   | POST | `https://api.weixin.qq.com/sns/oauth2/access_token`  | appid、secret、request-code | access-token、refresh-token |           |
4   | GET  | `https://api.weixin.qq.com/sns/userinfo`             | 请求头中添加access-token        | 微信用户个人信息                   |           |
5   | GET  | `https://api.weixin.qq.com/sns/oauth2/refresh_token` | appid、refresh-token       | 新的access-token             |           |



##  加密协议


### 加密算法的分类

- 对称加密算法：在加密和解密时使用同一个密钥，这种算法不安全，几乎不再使用了。
- 非对称加密算法：通过密钥算法同时一对密钥：公钥和私钥，分别用于加密和解密。目前在各大安全协议中被使用。

非对称加密算法主要包括：
- rsa：主流，ssh-keygen工具默认
- dsa

### 非对称秘钥的文件位置和内容

公钥和私钥都是一个文本文件，里面存放着一定长度的字符串，默认放在~/.ssh目录。

公钥私钥是成对生成、成对存在的，其名字也应该对应。假设是用rsa算法生成的一对公私钥，那么其名称默认是：
- ~/.ssh/id_rsa  私钥
- ~/.ssh/id_rsa.pub   公钥

当然，名称也可以自己取一个有辨识度的名字。

公钥顾名思义就是可以公开的，A和B首先把自己的公钥发给对方，然后把对方的的公钥追加进自己的~/.ssh/known_hosts文件中，这个文件存放的是从网络上接收到的各个主机的公钥，每条信息占一行，每一行的格式如下：
```
主机  加密算法   公钥字符串==
```

### 非对称加密传递信息

假设网络上的两台主机A和B需要传递信息。那么A和B首先生成自己的私钥和公钥。

现在A要跟B发送信息，A就使用B的公钥将原始信息加密，得到一条加密信息通过网络发送给B，由于原始信息是通过B的公钥加密的，那么加密信息只能通过B的私钥解密，A的公钥私钥、B的公钥、其它网络上任何人的公钥私钥都无法解密这条加密信息。B收到后通过自己的私钥成功界面，就看到了原始信息。在这个过程中，哪怕加密信息被别人截取到了，也无法解密。

总而言之，公钥是用来加密的，私钥是用来解密的。要给对方发送消息，就用对方的公钥加密，等信息到达对方主机后，对方就可以解密了。

非对称秘钥有几个特点：
- 全局唯一：不同的人在同一时间，或同一个人在不同时间生成公钥私钥一定是不同的。也就是说，每个人的私钥一定是不同的，这确保了身份的准确性。
- 一对一：公钥和私钥是成对生成的，用公钥加密的信息只能通过对应的私钥解密，其它私钥绝对不可能解密。
- 确定性：用对应的私钥一定能解密，不用对应的私钥一定不能解密。

### 数字证书和数字签名

现在，又有一个问题，如何保证这条加密信息是由a发出来的？换句话说，C也可以生成一对公私钥，发送给B，然后对B说：“我是A，这是我的公钥”。

这种问题的漏洞在于，每个人都可以生成公钥私钥，但无法根据识别身份。这个时候，有一个第三方的权威机构，A向这家机构发动自己的公钥以及能够证明身份的信息（例如营业执照），完成自己在网络上的“实名认证”。这家权威机构在核实了A的信息和公钥之后，颁发给A一张数字证书，这家机构也叫数字证书颁发机构。有了权威机构的背书，任何人也无法冒充A了，因为现在人们获取公钥都直接从权威机构获取。

现在，A要向B发生信息，首先使用B的公钥加密原始信息，然后再用自己（A）的私钥再进行一道加密，这个过程就是数字签名。B收到加密信息后，首先向第三方权威机构获取A的公钥，然后使用A的公钥进行第一级解密，再用自己（B）的的私钥进行二级解密，就获取了原始信息。

数字证书颁发机构的作用就是完成公钥信息的“实名制”。

第一级加密和数字签名是对称的：
- 第一级加密使用对方的公钥加密
- 第二级数字签名使用自己的私钥加密
- 收到信息后，首先向数字证书颁发机构获取发送方的公钥，完成数字签名信息的解密
- 然后使用自己的私钥解密出原始信息。

总之，原始信息加密解密的方式是：接收的公钥加密，接收方的私钥解密。数字签名的加密解密方式是：发送方的私钥加密，发送到的公钥解密。

### ssh

ssh命令用于登录远程主机

要登录远程主机，使用如下命令：

```
ssh  远程用户名@远程主机
```
此时会提示你输入密码。

输入`exit`退出登录。

如果是第一次登录该远程主机，则默认会将远程主机的公钥追加到文件~/.ssh/known_hosts 的末尾。

### ssh-keygen

ssh-keygen可以用了生成一对公私钥，运行命令后，会提示你：
- 输入私钥的文件名，默认为id_rsa。如果已经有一个私钥而想增加一个，可以自定义一个名称。公钥的名称为`私钥名称.pub`。
- 公钥的密码，默认不设密码

### ssh-copy-id

使用ssh-copy-id将客户端的公钥复制到远程主机的同名家目录的.ssh目录的 `authorized_keys` 文件中。以后就可以直接连接而不用输入密码了。

```
ssh-copy-id -i 公钥路径 远程用户名@远程主机地址
```



