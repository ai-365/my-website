
依赖，是软件包管理的永恒话题，无论是前端领域的npm依赖，还是Linux下的软件包依赖，都是令人比较头疼的问题，这种问题并不是多难的技术问题，而是代码的管理问题。

## 原生包管理方案

以下是早期的两种知名包管理方案：
- debian：使用deb作为二进制格式，使用apt管理deb的依赖
- Redhat：借鉴了debian的思想，使用rpm作为二进制格式，使用yum管理rpm的依赖。

上述的方案我们统一称之为“原生包管理方案”，也就是说只能在少数几个发行版上运行。同时，上述两种方式最明显的问题就是依赖，主要包括：

- 二进制文件之间的依赖。例如一个软件依赖于另一个软件，甚至是另一个软件的特定版本，如果依赖链条中的某个环节出了问题，那么本次安装就会出错。
- 对于本地库文件的依赖。本质上也跟第一点相同，如果本地缺少库文件、或者找不到正确的位置、或者版本不对应，安装就会出错。其实Windows上有时候也有这样的问题，例如偶尔会弹出“缺少某个.dll文件”。

## 跨发行版包管理方案

从2016年左右开始，一些大的发行版厂商推出了新的包管理方式，就是尽量将需要的依赖文件都打包好，避免从外部或发行版本地寻找依赖文件，类似于Windows的msi格式。这样就减少了依赖，虽然这样打包后的体积增大，但是对于现代硬件存储成本来说已经不是问题了。这种格式称之为“跨发行版包管理方案”，也就是说不绑定发行版，直接面向Linux。

遵循这种思想的主要有.appimage格式、snap格式和flatpak格式。

- appimage格式有点像Windows上的“便携软件”，就是解压到/tmp目录下直接运行，这通常适用于即用即走、不依赖本地存储状态的情况。
- snap格式是Ubuntu主导的，为每个snap提供一个隔离的沙箱环境，不过这种方式无法换源。
- flatpak是由社区主导的一种Linux打包规范，其目标是“一次打包，到处运行”，让开发人员和用户能在不同Linux发行版之间共享应用程序。

## 最佳实践

对应现行技术框架下的发行版，个人推荐的软件安装方案的优先顺序是：

```
跨发行版方案 > 原生包管理方案 > 下载二进制执行文件 >>下载源码手动编译
```

而对于跨发行版方案，个人推荐的优先顺序是：

```
flatpak > snap > appimage
```