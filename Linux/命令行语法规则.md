

# 命令行语法规则

## 管道

管道可以说是命令行的灵魂，如同管道的名字一样，管道使得命令行的操作如行云流水一般。

一个实用的例子是求出本目录下文件的数量：

```sh
ls -l    |   nl   |  tail  -1    
```

这里暂且先不考虑链接文件的情况， 本例子先使用`ls -l`将每个文件一行的形式输出，然后使用`nl`为每一行打上行号，然后使用`tail`倒序查看最后一行，这样便得出了本目录下文件的数量。

##  重定向

### 覆写

使用` > ` 符号将左边本来应该输出到终端的内容重定向到文件，例如：

```sh
ls > file.txt
```

### 追加

不过这会覆盖file.txt本来的内容，有些时候我们只是想追加输出，则可以使用` >> ` 符号：

```sh
ls >> file.txt
```

###  将输出和错误分别重定向

如果要将输出和错误定向到不同文件，使用 ` > ` 和 ` 2> ` 符号。 

例如，当前目录中，exist.txt存在，noexist.txt不存在，运行如下命令：

```sh
cat exist.txt noexist.txt > sure.txt 2> error.txt
```

这把 exist.txt 的文件拷贝到sure.txt。而由于noexist.md不存在，所以读取出错，会把错误信息“no such file...”等信息输出到error.txt。

###  将输出和错误集中输出

如下命令将输出和错误发送到同一文件：

```sh
cat exist.txt noexist.txt  >& out.txt 
```

###  丢弃输出

如果要丢弃输出，使用 ` >  /dev/null  2>&1 ` ，例如：

```sh
cat file.txt  >  /dev/null  2>&1
```

###  多个命令组重定向

可以使用多个命令组合重定向，例如：

```sh
pwd; ls; date > file.txt
```

pwd和ls依然会输出到屏幕，只会把date的结果保存到1.md

可以使用括号，先在子shell中执行，然后重定向：

```sh
(pwd ; ls ; date ) > file.txt
```

##  子命令（命令替换）
shell命令行或脚本最有用的特性之一是可以从命令输出中提取信息并将其赋值给变量，称为子命令，也可以叫做命令替换。

有两种等价的方式使用子命令：
- 使用反引号包裹
- 美元符加圆括号： ` $(子命令) `

例如：

```sh
today1=`date`
echo $today1

today2=$(date)
echo $today2
```

命令替换会创建出子 shell来运行指定命令，这是由运行脚本的 shell所生成的一个独立的shell。因此，在子 shell 中运行的命令无法使用脚本中的变量。如果在命令行中使用./路径执行命令，就会创建子 shell，但如果不加路径，则不会创建子 shell。不过，内建的 shell 命令也不会创建子 shell。在命令行中运行脚本时要当心。

##  命令行的Tab补全

使用命令行最多的按键或许就是Tab键了，所以单独使用一小节讲解。Tab键会根据你已经输入的少数几个字符自动猜测这个单词剩下的内容并进行补全。

可以通过bash shell补全的单词有：
- 命令、别名或函数
- 变量，如果以美元符`$`开头，则会寻找当前环境下的变量名
- 用户名，如果以~开头，则shell尝试使用用户名补齐
- 主机名，如果以@开头，则会寻找主机名补全

常见的情况有以下几种。

-  命令补全：例如先输入ec两个字符，按Tab键，Bash会补全成echo。不过Linux命令一般都比较简短，一般都是直接写完整的命令。

-  文件名称补全：这是最实用的功能，一般来说文件名都比较长，如果每次都要输入完整的文件名不仅费时而且极容易出错。此时，只需要输入文件名的前一个或少数几个字符，再按下Tab键就可以自动补全文件名，如果匹配的文件名超过1个，那么终端就会输出匹配的文件名供我们再次输入以缩小范围。

## 通配符

- `*` 匹配任意数量的字符
- `?`  字符占位，表示有且只有一个字符
- `[]`，匹配其中的任何一个单字符
- `{str1,str2}`，匹配以逗号分隔，匹配其中的任何一个单词

通配符在命令行中用的非常多。

例如，输出以.txt的文件名：

```sh
ls  *.txt
```

使用连字符指定范围，例如：

```sh
$ list file[1-3].txt
file1.txt file2.txt file3.txt
```

使用单个字符组成的逻辑或分组，例如如下命令表示匹配以file开头，紧接着以A或B或C结尾的文本文件：

```sh
ls file[ABC].txt
fileA.txt fileB.txt fileC.txt
```

有时候需要用到字符串组成的逻辑或分组，这时候就用到了花括号。例如如下命令表示筛选以txt或md结尾的文件：

```sh
ls *.{txt,md}
```

## 命令的返回值

既然两个命令有依赖性，而这个依赖性的判断地方就在于前一个命令执行的结果。在shell中，如果前一个命令成功执行或逻辑为真，则内置变量环境变量`$?`的值会设为0。如果执行有错误或逻辑为假，则`$?≠0`。例如：

```sh
$  pwd # 成功执行
$  echo $?  # 输出0

$  ls 不存在的文件  # 执行错误
$  echo $?   # 输出2 不同的错误有不同的返回值

$  [ 2 -eq 1 ]  # 不会输出内容，但是这个表达式逻辑值为假
$  echo $?  #  输出1 

$  [ 2 -gt 1 ]  # 不会输出内容，但是这个表达式逻辑值为真
$  echo $?  # 输出0
```

##  单行多命令

有些情况下，可以在一行中同时执行多个逻辑相关的命令，以提高效率。有三种情况：
- `命令1 && 命令2` ： 如果命令1成功执行或逻辑为真`（$?=0）`，则执行命令2。如果命令1执行发生错误或者逻辑为假`（$?≠0）`，则命令2不执行。
- `命令1 || 命令2` ： 如果命令1执行发生错误或者逻辑为假`（$?≠0）`，则命令2执行。如果命令1成功执行或者逻辑为真`（$?=0）`，则命令2不执行。
- `命令1 ; 命令2` ： 两个命令没有相关性，按顺序执行。其中一个命令的成功与否与逻辑真假都不影响其它的命令的执行。

需要说明的是，这三种情况可以随意的组合搭配出自己的逻辑链条，例如比较使用的三元条件表达式：

```sh
expression  && 条件为真时执行 || 条件为假时执行
```

具体的示例如下，这个例子的意思是：如果file.txt存在，就查看其内容；如果不存在，就先新建。

```sh
ls file.txt  && cat file.txt || touch file.txt 
```

再比如：如果目录不存在就新建目录，如果存在就读取文件列表：

```sh
ls dir && ls dir || mkdir dir
```

##  Shell子进程和脚本的执行方式

- 相对路径执行：例如./test，新开一个子进程执行。
- source命令执行：直接在当前进程中执行，不开子进程。
- bash或sh命令执行：与相对路径执行的方式等价，新开一个子进程执行

由于bash命令会新开子进程，所以在设置环境变量时，无法真正的生效，当这个子进程退出时，相当于没有设置环境变量，所以如果要设置环境变量，只能是 `source $HOME/.bashrc`，而不能是 `bash $HOME/.bashrc`。

